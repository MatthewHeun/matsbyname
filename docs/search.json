[{"path":"/articles/about-vector-arguments.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"About Vector Arguments","text":"*apply_byname() family functions used internally many functions matsbyname. functions (unaryapply_byname(), binaryapply_byname(), naryapply_byname()) allow additional arguments, besides matrices transformed, passed via .FUNdots. Getting .FUNdots right can challenging, vignette provides background explanation challenges. reading vignette, callers functions programmers use functions better position take advantage various *apply_byname() functions.","code":""},{"path":"/articles/about-vector-arguments.html","id":"an-example","dir":"Articles","previous_headings":"","what":"An example","title":"About Vector Arguments","text":"see .FUNdots argument works, let’s make example function takes advantage unaryapply_byname(). mysum() adds entries matrix , result depending upon value margin. Structuring mysum() shown provides several interesting capabilities. First, mysum() works single matrices. Second, mysum() works lists. Finally, mysum() works within data frames.","code":"mysum <- function(a, margin = c(1, 2)) {   sum_func <- function(a_mat, margin) {     # When we get here, we will have a single matrix a     if (1 %in% margin & 2 %in% margin) {       return(sum(a_mat))     }     if (margin == 1) {       return(rowSums(a_mat) %>% matrix(nrow = nrow(a_mat)))     }     if (margin == 2) {       return(colSums(a_mat) %>% matrix(ncol = ncol(a_mat)))     }   }   unaryapply_byname(sum_func, a, .FUNdots = list(margin = margin)) } m <- matrix(1:4, nrow = 2, byrow = TRUE) m #>      [,1] [,2] #> [1,]    1    2 #> [2,]    3    4 # Works for single matrices mysum(m, margin = 1) #>      [,1] #> [1,]    3 #> [2,]    7 mysum(m, margin = 2) #>      [,1] [,2] #> [1,]    4    6 mysum(m, margin = c(1, 2)) #> [1] 10 # Works for lists of matrices mysum(list(one = m, two = m), margin = 1) #> $one #>      [,1] #> [1,]    3 #> [2,]    7 #>  #> $two #>      [,1] #> [1,]    3 #> [2,]    7 mysum(list(one = m, two = m), margin = 2) #> $one #>      [,1] [,2] #> [1,]    4    6 #>  #> $two #>      [,1] [,2] #> [1,]    4    6 # Works in data frames and tibbles DF <- tibble::tibble(mcol = list(m, m, m)) res <- DF %>%    dplyr::mutate(     rsums = mysum(mcol, margin = 1),      csums = mysum(mcol, margin = 2)   ) res$rsums #> [[1]] #>      [,1] #> [1,]    3 #> [2,]    7 #>  #> [[2]] #>      [,1] #> [1,]    3 #> [2,]    7 #>  #> [[3]] #>      [,1] #> [1,]    3 #> [2,]    7 res$csums #> [[1]] #>      [,1] [,2] #> [1,]    4    6 #>  #> [[2]] #>      [,1] [,2] #> [1,]    4    6 #>  #> [[3]] #>      [,1] [,2] #> [1,]    4    6"},{"path":"/articles/about-vector-arguments.html","id":"the-problem","dir":"Articles","previous_headings":"","what":"The problem","title":"About Vector Arguments","text":"examples, margin 1 2, c(1, 2) list data frame examples. Let’s see happens margin = c(1, 2) list. understand better happening, let’s try list argument mysum() length 2. margin = c(1, 2) interpreted unaryapply_byname() “use margin = 1 first m list, use margin = 2 second m list. Now see passing margin = c(1, 2) failed list length 3 (list(m, m, m)): unaryapply_byname() applied margin = 1 first m, margin = 2 second m. third m margin available . also see passing margin = c(1, 2) successful list length 2 (list(m, m)): unaryapply_byname() applied margin = 1 first m, margin = 2 second m. case, exactly many items margin (2) items list passed (2). Now understand problem, fix ? words, can apply margin = c(1, 2) entries list(m, m, m)? , better yet, apply margin = 1 first m, margin = 2 second m, margin = c(1, 2) third m?","code":"tryCatch(mysum(list(m, m, m), margin = c(1, 2)),           error = function(e) {strwrap(e, width = 60)}) #> [1] \"Error: In prepare_.FUNdots(), when 'a' is a list, but an\"    #> [2] \"entry in '.FUNdots' is not a list, every top-level argument\" #> [3] \"in .FUNdots must be NULL or have length = 1 or length =\"     #> [4] \"length(a) (= 3). Found length = 2 for argument 'margin',\"    #> [5] \"which is not a list. Consider converting argument 'margin'\"  #> [6] \"into a list of length 1.\" mysum(list(m, m), margin = c(1, 2)) #> [[1]] #>      [,1] #> [1,]    3 #> [2,]    7 #>  #> [[2]] #>      [,1] [,2] #> [1,]    4    6"},{"path":"/articles/about-vector-arguments.html","id":"the-fix","dir":"Articles","previous_headings":"","what":"The fix","title":"About Vector Arguments","text":"Fixes problem identified can provided either caller (partially) programmer three ways: wrap vector arguments list (caller fix), use prep_vector_arg() function (programmer fix), use data frame (caller fix).","code":""},{"path":"/articles/about-vector-arguments.html","id":"wrap-vector-arguments-in-a-list","dir":"Articles","previous_headings":"The fix","what":"Wrap vector arguments in a list","title":"About Vector Arguments","text":"caller specific, flexibility gained. wrapping c(1, 2) list(), caller indicates “Take margin (c(1, 2)), replicate many times items list, using one c(1, 2) item list.” caller can also supply different margins item list matrices. caller must provide either 1 length() items margin argument, else error emitted.","code":"mysum(list(m, m, m), margin = list(c(1, 2))) #> [[1]] #> [1] 10 #>  #> [[2]] #> [1] 10 #>  #> [[3]] #> [1] 10 mysum(list(m, m, m), margin = list(1, 2, c(1, 2))) #> [[1]] #>      [,1] #> [1,]    3 #> [2,]    7 #>  #> [[2]] #>      [,1] [,2] #> [1,]    4    6 #>  #> [[3]] #> [1] 10 tryCatch(mysum(list(m, m, m), margin = list(1, 2)),           error = function(e) {strwrap(e, width = 60)}) #> [1] \"Error: In prepare_.FUNdots(), when both 'a' and '.FUNdots'\" #> [2] \"are lists, each top-level argument in .FUNdots must have\"   #> [3] \"length = 1 or length = length(a) (= 3). Found length = 2\"   #> [4] \"for argument 'margin', which is a list. Consider wrapping\"  #> [5] \"argument 'margin' in a list().\""},{"path":"/articles/about-vector-arguments.html","id":"use-the-prep_vector_arg-function","dir":"Articles","previous_headings":"The fix","what":"Use the prep_vector_arg() function","title":"About Vector Arguments","text":"extent possible, programmers remove burdens users functions. , helpful way automatically wrap vector arguments lists. end, matsbyname includes prep_vector_arg() function. prep_vector_arg() uses heuristics wrap vector arguments lists, needed possible. mysum2() demonstrates use prep_vector_arg(). argument list, vector argument (case margin) list, vector argument’s length greater 1 equal length , prep_vector_arg() wraps vector argument (case margin) list(), thereby relieving caller remember make list. Note length vector argument equal length list , caller’s intention ambiguous, vector argument passed without modification. caller wants c(1, 2) applied item list, caller must wrap c(1, 2) list.","code":"mysum2 <- function(a, margin = c(1, 2)) {   margin <- prep_vector_arg(a, margin)   sum_func <- function(a_mat, margin) {     # When we get here, we will have a single matrix a     if (1 %in% margin & 2 %in% margin) {       return(sum(a_mat))     }     if (margin == 1) {       return(rowSums(a_mat) %>% matrix(nrow = nrow(a_mat)))     }     if (margin == 2) {       return(colSums(a_mat) %>% matrix(ncol = ncol(a_mat)))     }   }   unaryapply_byname(sum_func, a, .FUNdots = list(margin = margin)) } mysum2(list(m, m, m), margin = c(1, 2)) #> [[1]] #> [1] 10 #>  #> [[2]] #> [1] 10 #>  #> [[3]] #> [1] 10 mysum2(list(m, m), margin = c(1, 2)) #> [[1]] #>      [,1] #> [1,]    3 #> [2,]    7 #>  #> [[2]] #>      [,1] [,2] #> [1,]    4    6 mysum2(list(m, m), margin = list(c(1, 2))) #> [[1]] #> [1] 10 #>  #> [[2]] #> [1] 10"},{"path":"/articles/about-vector-arguments.html","id":"use-a-data-frame","dir":"Articles","previous_headings":"The fix","what":"Use a data frame","title":"About Vector Arguments","text":"reason prep_vector_arg() always wrap vector arguments list data frame columns extracted vectors atomic. mistake wrap DF2$margin list() following call mysum2, caller’s intent clearly “apply margin = 1 first row margin = 2 second row. good news within context data frame, caller’s intent unambiguous.","code":"DF2 <- tibble::tibble(mcol = list(m, m), margin = c(1, 2)) DF2 #> # A tibble: 2 × 2 #>   mcol          margin #>   <list>         <dbl> #> 1 <int [2 × 2]>      1 #> 2 <int [2 × 2]>      2 DF2$margin %>% class() #> [1] \"numeric\" res2 <- DF2 %>%    dplyr::mutate(     sums = mysum2(mcol, margin = margin)   ) res2$sums #> [[1]] #>      [,1] #> [1,]    3 #> [2,]    7 #>  #> [[2]] #>      [,1] [,2] #> [1,]    4    6 DF3 <- tibble::tibble(mcol = list(m, m, m), margin = list(1, c(1, 2), c(1, 2))) %>%    dplyr::mutate(     sumcol = mysum2(mcol, margin = margin)   ) DF3$sumcol #> [[1]] #>      [,1] #> [1,]    3 #> [2,]    7 #>  #> [[2]] #> [1] 10 #>  #> [[3]] #> [1] 10"},{"path":"/articles/about-vector-arguments.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"About Vector Arguments","text":"Dealing vector arguments various *apply_byname() functions can tricky. three ways solve problems arise: wrap vector arguments list (caller fix), use prep_vector_arg() function (programmer fix), use data frame (caller fix). vignette illustrated three fixes.","code":""},{"path":"/articles/aggregation-vignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Aggregation in `matsbyname`","text":"matsbyname package provides several functions assist renaming aggregating rows columns matrices. vignette shows use functions.","code":""},{"path":"/articles/aggregation-vignette.html","id":"aggregate_byname","dir":"Articles","previous_headings":"","what":"aggregate_byname()","title":"Aggregation in `matsbyname`","text":"default (aggregation_map = NULL, margin = c(1,2), pattern_type = \"exact\"), aggregate_byname() sums rows columns names, effect remaining row column names unique. aggregation_map can provided, giving instructions rows columns aggregate names results. aggregation_map list named strings. entries list give names rows columns aggregated. names list entries provide names resulting aggregates. margin aggregation performed given margin argument (1 rows, 2 columns). aggregation_map can use regular expressions identify rows columns aggregate. Use pattern_type = \"literal\" feature. Note rows columns aggregated matrices always sorted alphabetically. error aggregate margin leave identically named rows columns. following function call fail, aggregates rows columns (using default margin = c(1,2)) nothing aggregation_map aggregate two “duck” rows. error informative: “Row names unique. Duplicated row names : duck”.","code":"m <- matrix(c(1, 2, 3, 4,                5, 6, 7, 8,                9, 10, 11, 12), nrow = 3, ncol = 4, byrow = TRUE,             dimnames = list(c(\"duck\", \"duck\", \"goose\"),                              c(\"John\", \"Paul\", \"George\", \"Ringo\"))) m #>       John Paul George Ringo #> duck     1    2      3     4 #> duck     5    6      7     8 #> goose    9   10     11    12 aggregate_byname(m) #>       George John Paul Ringo #> duck      10    6    8    12 #> goose     11    9   10    12 m #>       John Paul George Ringo #> duck     1    2      3     4 #> duck     5    6      7     8 #> goose    9   10     11    12 aggregate_byname(m, aggregation_map = list(birds = c(\"duck\", \"goose\"),                                             guitarists = c(\"John\", \"Paul\", \"George\"))) #>       guitarists Ringo #> birds         54    24 m #>       John Paul George Ringo #> duck     1    2      3     4 #> duck     5    6      7     8 #> goose    9   10     11    12 aggregate_byname(m, aggregation_map = list(Beatles = c(\"John\", \"Paul\", \"George\", \"Ringo\")),                   margin = 2) #>       Beatles #> duck       10 #> duck       26 #> goose      42 m #>       John Paul George Ringo #> duck     1    2      3     4 #> duck     5    6      7     8 #> goose    9   10     11    12 aggregate_byname(m, aggregation_map = list(guitarists = \"^[JPG]\"),                   margin = 2, pattern_type = \"literal\") #>       guitarists Ringo #> duck           6     4 #> duck          18     8 #> goose         30    12 m #>       John Paul George Ringo #> duck     1    2      3     4 #> duck     5    6      7     8 #> goose    9   10     11    12 aggregate_byname(m, aggregation_map = list(birds = c(\"duck\", \"goose\"),                                             zguitarists = c(\"John\", \"Paul\", \"George\"))) #>       Ringo zguitarists #> birds    24          54 # Not run aggregate_byname(m, aggregation_map = list(Beatles = c(\"John\", \"Paul\", \"George\", \"Ringo\")))"},{"path":"/articles/aggregation-vignette.html","id":"pieces","dir":"Articles","previous_headings":"","what":"Pieces","title":"Aggregation in `matsbyname`","text":"Commonly, row column names complex, carrying information prefixes, suffixes, prepositional phrases. matsbyname can aggregate pieces name, using RCLabels package internally. ’ll use following matrix demonstrate aggregating pieces. rows columns use different notations names (RCLabels::bracket_notation rows RCLabels::arrow_notation columns). renaming aggregation capabilities matsbyname still work, despite different notations.","code":"m_pieces <- matrix(c(1, 2, 3,                      4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE,                     dimnames = list(c(\"Electricity [from Coal]\", \"Electricity [from Solar]\"),                                     c(\"Motors -> MD\", \"Cars -> MD\", \"LED lamps -> Light\"))) m_pieces #>                          Motors -> MD Cars -> MD LED lamps -> Light #> Electricity [from Coal]             1          2                  3 #> Electricity [from Solar]            4          5                  6"},{"path":"/articles/aggregation-vignette.html","id":"rename_to_piece_byname","dir":"Articles","previous_headings":"","what":"rename_to_piece_byname()","title":"Aggregation in `matsbyname`","text":"Rows columns can renamed prefixes, suffixes, objects prepositions, demonstrated . examples , renaming accomplished specifying notation row column names. notation row column labels can also inferred via RCLabels::infer_notation(). infer notation renaming, set inf_notation = TRUE (default) give list notations notation can inferred notation argument. default, notation = list(RCLabels::notations_list), notation RCLabels::notations_list list . inferring notation, margins can renamed time, despite different notations. margin = list(c(1, 2)) default, code can simpler still. Sometimes, row column label can match one possible notation. example, row names inferred conform RCLabels::bracket_notation, first match RCLabels::notations_list. specify -specific notation, set choose_most_specific = TRUE. choose_most_specific = TRUE, RCLabels::from_notation inferred, suffixes different, renamed rows longer contain “”. Note “noun” synonym “pref”. margin can specified using row column types numerical margin inferred. renamings can used aggregations identically named rows columns summed aggregate_byname(), demonstrated section .","code":"m_pieces #>                          Motors -> MD Cars -> MD LED lamps -> Light #> Electricity [from Coal]             1          2                  3 #> Electricity [from Solar]            4          5                  6 rename_to_piece_byname(m_pieces, piece = \"pref\", margin = 1,                         notation = RCLabels::bracket_notation) #>             Motors -> MD Cars -> MD LED lamps -> Light #> Electricity            1          2                  3 #> Electricity            4          5                  6 rename_to_piece_byname(m_pieces, piece = \"suff\", margin = 1,                         notation = RCLabels::bracket_notation) #>            Motors -> MD Cars -> MD LED lamps -> Light #> from Coal             1          2                  3 #> from Solar            4          5                  6 rename_to_piece_byname(m_pieces, piece = \"from\", margin = 1,                         notation = RCLabels::bracket_notation) #>       Motors -> MD Cars -> MD LED lamps -> Light #> Coal             1          2                  3 #> Solar            4          5                  6 rename_to_piece_byname(m_pieces, piece = \"pref\", margin = 2,                        notation = RCLabels::arrow_notation) #>                          Motors Cars LED lamps #> Electricity [from Coal]       1    2         3 #> Electricity [from Solar]      4    5         6 rename_to_piece_byname(m_pieces, piece = \"suff\", margin = 2,                        notation = RCLabels::arrow_notation) #>                          MD MD Light #> Electricity [from Coal]   1  2     3 #> Electricity [from Solar]  4  5     6 m_pieces #>                          Motors -> MD Cars -> MD LED lamps -> Light #> Electricity [from Coal]             1          2                  3 #> Electricity [from Solar]            4          5                  6 rename_to_piece_byname(m_pieces, piece = \"pref\", margin = 1) #>             Motors -> MD Cars -> MD LED lamps -> Light #> Electricity            1          2                  3 #> Electricity            4          5                  6 rename_to_piece_byname(m_pieces, piece = \"pref\", margin = c(1, 2)) #>             Motors Cars LED lamps #> Electricity      1    2         3 #> Electricity      4    5         6 rename_to_piece_byname(m_pieces, piece = \"pref\") #>             Motors Cars LED lamps #> Electricity      1    2         3 #> Electricity      4    5         6 rename_to_piece_byname(m_pieces, piece = \"suff\") #>            MD MD Light #> from Coal   1  2     3 #> from Solar  4  5     6 rename_to_piece_byname(m_pieces, piece = \"suff\", choose_most_specific = TRUE) #>       MD MD Light #> Coal   1  2     3 #> Solar  4  5     6 rename_to_piece_byname(m_pieces, piece = \"noun\") #>             Motors Cars LED lamps #> Electricity      1    2         3 #> Electricity      4    5         6 m_pieces_with_types <- m_pieces %>%    setrowtype(\"Product\") %>% setcoltype(\"Industry\") m_pieces_with_types #>                          Motors -> MD Cars -> MD LED lamps -> Light #> Electricity [from Coal]             1          2                  3 #> Electricity [from Solar]            4          5                  6 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" m_pieces_with_types %>%    rename_to_piece_byname(piece = \"pref\", margin = \"Product\") #>             Motors -> MD Cars -> MD LED lamps -> Light #> Electricity            1          2                  3 #> Electricity            4          5                  6 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" m_pieces_with_types %>%    rename_to_piece_byname(piece = \"suff\", margin = \"Product\") #>            Motors -> MD Cars -> MD LED lamps -> Light #> from Coal             1          2                  3 #> from Solar            4          5                  6 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" m_pieces_with_types %>%    rename_to_piece_byname(piece = \"from\", margin = \"Product\") #>       Motors -> MD Cars -> MD LED lamps -> Light #> Coal             1          2                  3 #> Solar            4          5                  6 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" m_pieces_with_types %>%    rename_to_piece_byname(piece = \"suff\", margin = \"Product\", choose_most_specific = TRUE) #>       Motors -> MD Cars -> MD LED lamps -> Light #> Coal             1          2                  3 #> Solar            4          5                  6 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" m_pieces_with_types %>%    rename_to_piece_byname(piece = \"suff\", margin = \"Industry\") #>                          MD MD Light #> Electricity [from Coal]   1  2     3 #> Electricity [from Solar]  4  5     6 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/articles/aggregation-vignette.html","id":"aggregate_pieces_byname","dir":"Articles","previous_headings":"","what":"aggregate_pieces_byname()","title":"Aggregation in `matsbyname`","text":"aggregate_pieces_byname() bundles renaming aggregating tasks single function call. First, rows /columns renamed requested piece rename_to_piece_byname() function. , aggregation performed via aggregate_byname(), according aggregation_map pattern_type, provided. default aggregation_map = NULL, identically named pieces aggregated together. aggregation_map supplied, applies requested piece, original row /column names, shown .","code":"m_pieces #>                          Motors -> MD Cars -> MD LED lamps -> Light #> Electricity [from Coal]             1          2                  3 #> Electricity [from Solar]            4          5                  6 # Aggregate Electricity in rows aggregate_pieces_byname(m_pieces, piece = \"pref\", margin = 1,                          notation = RCLabels::bracket_notation) #>             Motors -> MD Cars -> MD LED lamps -> Light #> Electricity            5          7                  9 # Aggregate useful energy types in columns aggregate_pieces_byname(m_pieces, piece = \"suff\", margin = 2,                         notation = RCLabels::arrow_notation) #>                          Light MD #> Electricity [from Coal]      3  3 #> Electricity [from Solar]     6  9 m_pieces #>                          Motors -> MD Cars -> MD LED lamps -> Light #> Electricity [from Coal]             1          2                  3 #> Electricity [from Solar]            4          5                  6 # Aggregate by original energy type aggregate_pieces_byname(m_pieces, piece = \"from\", margin = 1,                          notation = RCLabels::bracket_notation,                          aggregation_map = list(`All sources` = c(\"Coal\", \"Solar\"))) #>             Motors -> MD Cars -> MD LED lamps -> Light #> All sources            5          7                  9  aggregate_pieces_byname(m_pieces, piece = \"suff\", margin = 2,                          notation = RCLabels::arrow_notation,                          aggregation_map = list(`Transport` = \"MD\")) #>                          Light Transport #> Electricity [from Coal]      3         3 #> Electricity [from Solar]     6         9"},{"path":"/articles/aggregation-vignette.html","id":"aggregations-of-lists-and-data-frames-of-matrices","dir":"Articles","previous_headings":"","what":"Aggregations of lists and data frames of matrices","title":"Aggregation in `matsbyname`","text":"functions renaming aggregating can used lists data frames matrices.","code":"m_pieces #>                          Motors -> MD Cars -> MD LED lamps -> Light #> Electricity [from Coal]             1          2                  3 #> Electricity [from Solar]            4          5                  6 res <- rename_to_piece_byname(list(m_pieces, m_pieces),                                piece = list(\"pref\", \"suff\"),                                margin = list(1, 2),                               notation = list(RCLabels::bracket_notation,                                                RCLabels::arrow_notation)) res #> [[1]] #>             Motors -> MD Cars -> MD LED lamps -> Light #> Electricity            1          2                  3 #> Electricity            4          5                  6 #>  #> [[2]] #>                          MD MD Light #> Electricity [from Coal]   1  2     3 #> Electricity [from Solar]  4  5     6 df <- tibble::tibble(mats = list(m_pieces, m_pieces),                       pce = list(\"suff\", \"pref\"),                       mgn = list(1, 2),                       am = list(list(Sources = c(\"Coal\", \"Solar\")),                                 list(Transport = c(\"Motors\", \"Cars\"))),                       notn = list(RCLabels::from_notation, RCLabels::arrow_notation)) df #> # A tibble: 2 × 5 #>   mats          pce       mgn       am               notn      #>   <list>        <list>    <list>    <list>           <list>    #> 1 <dbl [2 × 3]> <chr [1]> <dbl [1]> <named list [1]> <chr [4]> #> 2 <dbl [2 × 3]> <chr [1]> <dbl [1]> <named list [1]> <chr [4]> res2 <- df %>%   dplyr::mutate(     aggregated = aggregate_pieces_byname(mats, piece = pce, margin = mgn,                                           aggregation_map = am, notation = notn)   ) res2 #> # A tibble: 2 × 6 #>   mats          pce       mgn       am               notn      aggregated    #>   <list>        <list>    <list>    <list>           <list>    <list>        #> 1 <dbl [2 × 3]> <chr [1]> <dbl [1]> <named list [1]> <chr [4]> <dbl [1 × 3]> #> 2 <dbl [2 × 3]> <chr [1]> <dbl [1]> <named list [1]> <chr [4]> <dbl [2 × 2]> res2$aggregated[[1]] #>         Motors -> MD Cars -> MD LED lamps -> Light #> Sources            5          7                  9 res2$aggregated[[2]] #>                          LED lamps Transport #> Electricity [from Coal]          3         3 #> Electricity [from Solar]         6         9"},{"path":"/articles/aggregation-vignette.html","id":"aggregation-via-dplyrsummarise","dir":"Articles","previous_headings":"","what":"Aggregation via dplyr::summarise()","title":"Aggregation in `matsbyname`","text":"Another type aggregation aided metadata columns matsindf-style data frame. single numbers, aggregation might look like : aggregation gives unexpected results default arguments sum_byname() function (specifically, .summarise = FALSE), sum_byname() ambiguous data frame. column returned unchanged, element interpreted augend series sums missing addends, case length returned object length input? list objects summed column, returning single item (group), dplyr::summarise() function? (See vignette titled “Using summarise matsbyname” additional detail ambiguity.) example , grouping effect summarise() function, sum_byname(.summarise = FALSE) assumes row val augend without addend. signal intention summarise val column, set .summarise = TRUE call sum_byname(). Note sum_byname(.summarise = TRUE) always returns list column, summarised column contain matrices, must list column. .summarise = TRUE argument works matrices matsindf data frame, .","code":"df_simple <- tibble::tribble(~key, ~val,                               \"A\", 1,                               \"A\", 2,                               \"B\", 10) df_simple #> # A tibble: 3 × 2 #>   key     val #>   <chr> <dbl> #> 1 A         1 #> 2 A         2 #> 3 B        10 df_simple %>%    dplyr::group_by(key) %>%    dplyr::summarise(val = sum(val)) #> # A tibble: 2 × 2 #>   key     val #>   <chr> <dbl> #> 1 A         3 #> 2 B        10 # 2 rows are expected. 3 are observed. df_simple %>%    dplyr::group_by(key) %>%    dplyr::summarise(val = sum_byname(val), .groups = \"drop\") #> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in #> dplyr 1.1.0. #> ℹ Please use `reframe()` instead. #> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()` #>   always returns an ungrouped data frame and adjust accordingly. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> # A tibble: 3 × 2 #>   key     val #>   <chr> <dbl> #> 1 A         1 #> 2 A         2 #> 3 B        10 res <- df_simple %>%    dplyr::group_by(key) %>%    dplyr::summarise(val = sum_byname(val, .summarise = TRUE)) # res$val is a list column. res #> # A tibble: 2 × 2 #>   key   val       #>   <chr> <list>    #> 1 A     <dbl [1]> #> 2 B     <dbl [1]> res$val #> [[1]] #> [1] 3 #>  #> [[2]] #> [1] 10 m <- matrix(c(11, 12, 13,               21, 22, 23), nrow = 2, ncol = 3, byrow = TRUE,              dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\", \"c3\"))) df <- tibble::tibble(key = c(\"A\", \"A\", \"B\"), m = list(m, m, m)) unexpected <- df %>%    dplyr::group_by(key) %>%    dplyr::summarise(m = sum_byname(m), .groups = \"drop\") #> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in #> dplyr 1.1.0. #> ℹ Please use `reframe()` instead. #> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()` #>   always returns an ungrouped data frame and adjust accordingly. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. # 2 rows are expected. 3 are observed. unexpected #> # A tibble: 3 × 2 #>   key   m             #>   <chr> <list>        #> 1 A     <dbl [2 × 3]> #> 2 A     <dbl [2 × 3]> #> 3 B     <dbl [2 × 3]> res <- df %>%    dplyr::group_by(key) %>%    dplyr::summarise(m = sum_byname(m, .summarise = TRUE)) res #> # A tibble: 2 × 2 #>   key   m             #>   <chr> <list>        #> 1 A     <dbl [2 × 3]> #> 2 B     <dbl [2 × 3]> res$m[[1]] #>    c1 c2 c3 #> r1 22 24 26 #> r2 42 44 46 res$m[[2]] #>    c1 c2 c3 #> r1 11 12 13 #> r2 21 22 23"},{"path":"/articles/aggregation-vignette.html","id":"working-with-aggregation-maps","dir":"Articles","previous_headings":"","what":"Working with aggregation maps","title":"Aggregation in `matsbyname`","text":"aggregation map defined named list. source named list often data frame many--one relationships defined. agg_table_to_agg_map() assists converting two-column data frame aggregation map. similar manner, aggregation map can converted data frame assist join operations data frames.","code":"df <- tibble::tribble(~member, ~role, ~band,                        \"John\", \"guitarists\", \"The Beatles\",                        \"Paul\", \"guitarists\", \"The Beatles\",                        \"George\", \"guitarists\", \"The Beatles\",                        \"Ringo\", \"drummers\", \"The Beatles\",                        \"Mick\", \"singers\", \"Rolling Stones\",                        \"Keith\", \"guitarists\", \"Rolling Stones\",                        \"Ronnie\", \"guitarists\", \"Rolling Stones\",                        \"Bill\", \"guitarists\", \"Rolling Stones\",                        \"Charlie\", \"drummers\", \"Rolling Stones\") df #> # A tibble: 9 × 3 #>   member  role       band           #>   <chr>   <chr>      <chr>          #> 1 John    guitarists The Beatles    #> 2 Paul    guitarists The Beatles    #> 3 George  guitarists The Beatles    #> 4 Ringo   drummers   The Beatles    #> 5 Mick    singers    Rolling Stones #> 6 Keith   guitarists Rolling Stones #> 7 Ronnie  guitarists Rolling Stones #> 8 Bill    guitarists Rolling Stones #> 9 Charlie drummers   Rolling Stones bands_membs_agg_map <- agg_table_to_agg_map(df, few_colname = \"band\", many_colname = \"member\") bands_membs_agg_map #> $`Rolling Stones` #> [1] \"Mick\"    \"Keith\"   \"Ronnie\"  \"Bill\"    \"Charlie\" #>  #> $`The Beatles` #> [1] \"John\"   \"Paul\"   \"George\" \"Ringo\" agg_table_to_agg_map(df, few_colname = \"role\", many_colname = \"member\") #> $drummers #> [1] \"Ringo\"   \"Charlie\" #>  #> $guitarists #> [1] \"John\"   \"Paul\"   \"George\" \"Keith\"  \"Ronnie\" \"Bill\"   #>  #> $singers #> [1] \"Mick\" agg_map_to_agg_table(bands_membs_agg_map,                        few_colname = \"bands\",                       many_colname = \"members\") #> # A tibble: 9 × 2 #>   bands          members #>   <chr>          <chr>   #> 1 Rolling Stones Mick    #> 2 Rolling Stones Keith   #> 3 Rolling Stones Ronnie  #> 4 Rolling Stones Bill    #> 5 Rolling Stones Charlie #> 6 The Beatles    John    #> 7 The Beatles    Paul    #> 8 The Beatles    George  #> 9 The Beatles    Ringo"},{"path":"/articles/aggregation-vignette.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Aggregation in `matsbyname`","text":"matsbyname package simplifies aggregation matrix rows columns based row column names pieces row column names. particular functions aggregate_byname(), rename_to_piece_byname(), aggregate_pieces_byname() provide flexibility renaming aggregation can accomplished. working aggregation maps, functions agg_table_to_agg_map() agg_map_to_agg_table() assist conversion one data shape another.","code":""},{"path":"/articles/applybyname-vignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Writing Custom Functions for `matsbyname`","text":"matsbyname package provides many useful functions \"name\" manipulation matrices, lists matrices, matrices columns data frames. However, built-functions may cover possible needs. matsbyname provides three functions situations:","code":""},{"path":"/articles/applybyname-vignette.html","id":"how-the-apply_byname-functions-work","dir":"Articles","previous_headings":"","what":"How the *apply_byname functions work","title":"Writing Custom Functions for `matsbyname`","text":"*apply_byname functions several arguments. FUN mapped expected (case unaryapply_byname, elementapply_byname, cumapply_byname) b (case binaryapply_byname). FUN assume /b arguments single numbers matrices; *apply_byname handles mapping across lists. following sections describe *apply_byname function.","code":""},{"path":"/articles/applybyname-vignette.html","id":"unaryapply_byname","dir":"Articles","previous_headings":"","what":"unaryapply_byname","title":"Writing Custom Functions for `matsbyname`","text":"unaryapply_byname applies FUN single matrix, list matrices, (used dplyr::mutate()) column data frame contains matrices. rowcoltypes argument must one following: simple example follows.","code":"U <- matrix(1:4, ncol = 2, dimnames = list(c(\"p1\", \"p2\"), c(\"i1\", \"i2\"))) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") U ##    i1 i2 ## p1  1  3 ## p2  2  4 ## attr(,\"rowtype\") ## [1] \"Products\" ## attr(,\"coltype\") ## [1] \"Industries\" difference_byname(0, U) ##    i1 i2 ## p1 -1 -3 ## p2 -2 -4 ## attr(,\"rowtype\") ## [1] \"Products\" ## attr(,\"coltype\") ## [1] \"Industries\" unaryapply_byname(`-`, U) ##    i1 i2 ## p1 -1 -3 ## p2 -2 -4 ## attr(,\"rowtype\") ## [1] \"Products\" ## attr(,\"coltype\") ## [1] \"Industries\""},{"path":"/articles/applybyname-vignette.html","id":"elementapply_byname","dir":"Articles","previous_headings":"","what":"elementapply_byname","title":"Writing Custom Functions for `matsbyname`","text":"elementapply_byname applies FUN single matrix, list matrices, (used dplyr::mutate()) column data frame contains matrices. simple example follows.","code":"divide <- function(x, divisor){   x/divisor } m <- matrix(c(1:4), nrow = 2, ncol = 2, dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\"))) %>%    setrowtype(\"row\") %>% setcoltype(\"col\") m ##    c1 c2 ## r1  1  3 ## r2  2  4 ## attr(,\"rowtype\") ## [1] \"row\" ## attr(,\"coltype\") ## [1] \"col\" elementapply_byname(divide, a = m, row = 1, col = 1, .FUNdots = list(divisor = 2)) ##     c1 c2 ## r1 0.5  3 ## r2 2.0  4 ## attr(,\"rowtype\") ## [1] \"row\" ## attr(,\"coltype\") ## [1] \"col\""},{"path":"/articles/applybyname-vignette.html","id":"binaryapply_byname","dir":"Articles","previous_headings":"","what":"binaryapply_byname","title":"Writing Custom Functions for `matsbyname`","text":"binaryapply_byname applies FUN pair matrices, pair lists matrices, (used dplyr::mutate) pair columns data frame contains matrices. match_type must one \"\", \"matmult\", \"none\". rowcoltypes argument (boolean) tells whether apply row column types b output. .organize argument (boolean) tells whether automatically complete b relative sort rows columns completed matrices. Normally, TRUE (default). simple example follows.","code":"U <- matrix(1:4, ncol = 2, dimnames = list(c(\"p1\", \"p2\"), c(\"i1\", \"i2\"))) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") U ##    i1 i2 ## p1  1  3 ## p2  2  4 ## attr(,\"rowtype\") ## [1] \"Products\" ## attr(,\"coltype\") ## [1] \"Industries\" Y <- matrix(1:4, ncol = 2, dimnames = list(c(\"p2\", \"p1\"), c(\"i2\", \"i1\"))) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") Y ##    i2 i1 ## p2  1  3 ## p1  2  4 ## attr(,\"rowtype\") ## [1] \"Products\" ## attr(,\"coltype\") ## [1] \"Industries\" sum_byname(U, Y) ##    i1 i2 ## p1  5  5 ## p2  5  5 ## attr(,\"rowtype\") ## [1] \"Products\" ## attr(,\"coltype\") ## [1] \"Industries\" binaryapply_byname(`+`, U, Y) ##    i1 i2 ## p1  5  5 ## p2  5  5 ## attr(,\"rowtype\") ## [1] \"Products\" ## attr(,\"coltype\") ## [1] \"Industries\""},{"path":"/articles/applybyname-vignette.html","id":"cumapply_byname","dir":"Articles","previous_headings":"","what":"cumapply_byname","title":"Writing Custom Functions for `matsbyname`","text":"cumapply_byname applies FUN cumulatively list numbers, list matrices, (used dplyr::mutate) column data frame. FUN must binary function also allows single argument. result list first element FUN(m[[1]]). >= 2, elements resulting list FUN(m[[]], [[-1]]), result list. Simple examples follow.","code":"cumapply_byname(sum_byname, list(1, 2, 3, 4)) ## [[1]] ## [1] 1 ##  ## [[2]] ## [1] 3 ##  ## [[3]] ## [1] 6 ##  ## [[4]] ## [1] 10 cumapply_byname(hadamardproduct_byname, list(1, 2, 3, 4)) ## [[1]] ## [1] 1 ##  ## [[2]] ## [1] 2 ##  ## [[3]] ## [1] 6 ##  ## [[4]] ## [1] 24"},{"path":"/articles/applybyname-vignette.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Writing Custom Functions for `matsbyname`","text":"various *apply_byname functions allow users extend functionality matsbyname package needed problem domain. functions used extensively matsbyname . fact, matsbyname functions utilize *apply_byname functions, ready prime time!","code":""},{"path":"/articles/matsbyname.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Use Cases and Examples for `matsbyname`","text":"Matrices important mathematical objects, often describe networks flows among nodes. Example networks given following table. power matrices lies ability organize network-wide calculations, thereby simplifying work analysts study entire systems. However, three problems arise performing matrix operations R languages.","code":""},{"path":"/articles/matsbyname.html","id":"problem-1","dir":"Articles","previous_headings":"Introduction","what":"Problem 1","title":"Use Cases and Examples for `matsbyname`","text":"Although built-matrix functions ensure size conformity matrix operands, respect names rows columns (known dimnames R). following example, U represents use matrix contains quantity product used industry, Y represents final demand matrix contains quantity product consumed final demand industries. rows columns order, sum matrices nonsensical. result, analysts performing matrix operations must maintain strict order rows columns across calculations.","code":"productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) U #>    i1 i2 #> p1  1  3 #> p2  2  4 Y <- matrix(1:4, ncol = 2, dimnames = list(rev(productnames), rev(industrynames))) Y #>    i2 i1 #> p2  1  3 #> p1  2  4 # This sum is nonsensical.  Neither row nor column names are respected. U + Y  #>    i1 i2 #> p1  2  6 #> p2  4  8 # Make a new version of Y (Y2), this time with dimnames in same order as U Y2 <- matrix(4:1, ncol = 2, dimnames = list(productnames, industrynames)) Y2 #>    i1 i2 #> p1  4  2 #> p2  3  1 # Now the sum is sensible. Both row and column names are respected. U + Y2 #>    i1 i2 #> p1  5  5 #> p2  5  5"},{"path":"/articles/matsbyname.html","id":"problem-2","dir":"Articles","previous_headings":"Introduction","what":"Problem 2","title":"Use Cases and Examples for `matsbyname`","text":"many cases, operand matrices may different numbers different names rows columns. situation can occur , example, products industries changes across time periods. performing matrix operations, rows columns zeros must added ensure name conformity. analyst’s burden cumbersome. worse problems await. Respecting names (adding rows columns zeroes) can lead inability invert matrices downstream, shown following example.","code":"Y3 <- matrix(5:8, ncol = 2, dimnames = list(c(\"p1\", \"p3\"), c(\"i1\", \"i3\"))) Y3 #>    i1 i3 #> p1  5  7 #> p3  6  8 # Nonsensical because neither row names nor column names are respected.  # The \"p3\" rows and \"i3\" columns of Y3 have been added to  # \"p2\" rows and \"i2\" columns of U. # Row and column names for the sum are taken from the first operand (U). U + Y3 #>    i1 i2 #> p1  6 10 #> p2  8 12 # Rather, need to insert missing rows in both U and Y before summing. U_2000 <- matrix(c(1, 3, 0,                    2, 4, 0,                    0, 0, 0),                  ncol = 3, byrow = TRUE,                   dimnames = list(c(\"p1\", \"p2\", \"p3\"), c(\"i1\", \"i2\", \"i3\"))) Y_2000 <- matrix(c(5, 0, 7,                    0, 0, 0,                     6, 0, 8),                  ncol = 3, byrow = TRUE,                  dimnames = list(c(\"p1\", \"p2\", \"p3\"), c(\"i1\", \"i2\", \"i3\"))) U_2000 #>    i1 i2 i3 #> p1  1  3  0 #> p2  2  4  0 #> p3  0  0  0 Y_2000 #>    i1 i2 i3 #> p1  5  0  7 #> p2  0  0  0 #> p3  6  0  8 U_2000 + Y_2000 #>    i1 i2 i3 #> p1  6  3  7 #> p2  2  4  0 #> p3  6  0  8 # The original U matrix is invertible. solve(U) #>    p1   p2 #> i1 -2  1.5 #> i2  1 -0.5 # The version of U that contains zero rows and columns (U_2000) # is singular and cannot be inverted. tryCatch(solve(U_2000), error = function(err){print(err)}) #> <simpleError in solve.default(U_2000): Lapack routine dgesv: system is exactly singular: U[3,3] = 0>"},{"path":"/articles/matsbyname.html","id":"problem-3","dir":"Articles","previous_headings":"Introduction","what":"Problem 3","title":"Use Cases and Examples for `matsbyname`","text":"Matrix functions provided R languages ensure type conformity matrix operands matrix algebra functions. example matrix multiplication, columns multiplicand must contain type information rows multiplier. columns countries, rows B must also countries (order) %*% B make sense.","code":""},{"path":"/articles/matsbyname.html","id":"matsbyname","dir":"Articles","previous_headings":"","what":"matsbyname","title":"Use Cases and Examples for `matsbyname`","text":"matsbyname package automatically addresses three problems . performs smart matrix operations inserting rows columns zeroes necessary re-ordering rows columns ensure conformity names operand rows columns, respect row column types, enforcing conformity appropriate. features available without analyst intervention, shown following example. addition sum_byname() clean_byname(), matsbyname package contains many additional matrix algebra functions respect names rows columns. Commonly-used functions : sum_byname() difference_byname() hadamardproduct_byname() matrixproduct_byname() quotient_byname() rowsums_byname() colsums_byname() invert_byname(), transpose_byname(). full list functions can found ?matsbyname clicking Index link. Furthermore, matsbyname works well sister package, matsindf. matsindf creates data frames whose entries numbers entire matrices, thereby enabling use matsbyname functions tidyverse functional programming. used together, matsbyname matsindf allow analysts wield simultaneously power matrix mathematics tidyverse functional programming. vignette demonstrates power matrix mathematics performed byname.","code":"# Same as U + Y2, without needing to create Y2. sum_byname(U, Y) #>    i1 i2 #> p1  5  5 #> p2  5  5 # Same as U_2000 + Y_2000, but U and Y3 are unmodified. sum_byname(U, Y3) #>    i1 i2 i3 #> p1  6  3  7 #> p2  2  4  0 #> p3  6  0  8 # Eliminate zero-filled rows and columns. Same result as solve(U). U_2000 %>% clean_byname(margin = c(1,2), clean_value = 0) %>% solve() #>    p1   p2 #> i1 -2  1.5 #> i2  1 -0.5"},{"path":"/articles/matsbyname.html","id":"matsbyname-features","dir":"Articles","previous_headings":"","what":"matsbyname features","title":"Use Cases and Examples for `matsbyname`","text":"matsbyname package several features simplify analyses ensure correctness.","code":""},{"path":"/articles/matsbyname.html","id":"setting-row-and-column-names","dir":"Articles","previous_headings":"matsbyname features","what":"Setting row and column names","title":"Use Cases and Examples for `matsbyname`","text":"preceding examples, row column names provided dimnames argument matrix() function. However, matsbyname provides setcolnames_byname() setrownames_byname() functions perform tasks using pipe operator (%>% |>).","code":"U_2 <- matrix(1:4, ncol = 2) %>%    setrownames_byname(productnames) %>% setcolnames_byname(industrynames) U_2 #>    i1 i2 #> p1  1  3 #> p2  2  4"},{"path":"/articles/matsbyname.html","id":"setting-row-and-column-types","dir":"Articles","previous_headings":"matsbyname features","what":"Setting row and column types","title":"Use Cases and Examples for `matsbyname`","text":"Row column types can understood analogy: row column types matrices matrix algebra units scalars scalar algebra. Just careful tracking units necessary scalar calculations, careful tracking row column types necessary matrix operations. matsbyname keeps track row column types automatically, much burden dealing row column types removed analyst. Row column types character strings stored attributes matrix object, matsbyname functions ensure correctness matrix operations checking row column types, throwing errors needed. Row column types can set functions setrowtype() setcoltype() retrieved functions rowtype() coltype(). Consider matrices , B, C: B can added , row column types identical. However, C added (B), row column types disagree. case, sum possible C transposed prior adding , row column types CT agree. Matrices B can element-multiplied element-divided reason can summed: row column types agree. Note C can matrix-multiplied, column type row type C identical (Industries). result Products--Products matrix. However, B matrix-multiplied, column type (Industries) row type B (Products) different. Analysts encouraged set row column types matrices, thereby taking advantage matsbyname’s type-tracking feature improve matrix-based analyses.","code":"A <- matrix(1:4, ncol = 2) %>%    setrownames_byname(productnames) %>% setcolnames_byname(industrynames) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\") A #>    i1 i2 #> p1  1  3 #> p2  2  4 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" B <- matrix(8:5, ncol = 2) %>%    setrownames_byname(productnames) %>% setcolnames_byname(industrynames) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\") B #>    i1 i2 #> p1  8  6 #> p2  7  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" C <- matrix(1:4, ncol = 2) %>%    setrownames_byname(industrynames) %>% setcolnames_byname(productnames) %>%    setrowtype(\"Industries\") %>% setcoltype(\"Products\") C #>    p1 p2 #> i1  1  3 #> i2  2  4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" sum_byname(A, B) #>    i1 i2 #> p1  9  9 #> p2  9  9 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" tryCatch(sum_byname(A, C), error = function(err){print(err)}) #> <simpleError in organize_args(a, b, fill = 0, match_type = match_type): rowtype(a) (Products) != rowtype(b) (Industries).> sum_byname(A, transpose_byname(C)) #>    i1 i2 #> p1  2  5 #> p2  5  8 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" hadamardproduct_byname(A, B) #>    i1 i2 #> p1  8 18 #> p2 14 20 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" quotient_byname(A, B) #>           i1  i2 #> p1 0.1250000 0.5 #> p2 0.2857143 0.8 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" matrixproduct_byname(A, C) #>    p1 p2 #> p1  7 15 #> p2 10 22 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Products\" tryCatch(matrixproduct_byname(A, B), error = function(err){print(err)}) #> <simpleError in organize_args(a, b, fill = 0, match_type = match_type): coltype(a) != rowtype(b): Industries != Products.>"},{"path":"/articles/matsbyname.html","id":"byname-functions-work-well-with-lists","dir":"Articles","previous_headings":"matsbyname features","what":"*_byname functions work well with lists","title":"Use Cases and Examples for `matsbyname`","text":"Another feature matsbyname package works arguments functions lists matrices, returning lists appropriate.","code":"sum_byname(A, list(B, B)) #> [[1]] #>    i1 i2 #> p1  9  9 #> p2  9  9 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> p1  9  9 #> p2  9  9 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" hadamardproduct_byname(list(A, A), B) #> [[1]] #>    i1 i2 #> p1  8 18 #> p2 14 20 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> p1  8 18 #> p2 14 20 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" matrixproduct_byname(list(A, A), list(C, C)) #> [[1]] #>    p1 p2 #> p1  7 15 #> p2 10 22 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Products\" #>  #> [[2]] #>    p1 p2 #> p1  7 15 #> p2 10 22 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Products\""},{"path":"/articles/matsbyname.html","id":"matsbyname-works-well-with-matsindf","dir":"Articles","previous_headings":"matsbyname features","what":"matsbyname works well with matsindf","title":"Use Cases and Examples for `matsbyname`","text":"matsindf package provides functions collapse tidy data frames matrix elements data frames matrices. Data frames matrices, created matsindf, like magic spreadsheets single cells contain entire matrices. following example demonstrates approach creating data frame matrices.","code":"tidy <- data.frame(   matrix = c(\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"),   row = c(\"p1\", \"p1\", \"p2\", \"p2\", \"p1\", \"p1\", \"p2\", \"p2\"),   col = c(\"i1\", \"i2\", \"i1\", \"i2\", \"i1\", \"i2\", \"i1\", \"i2\"),   vals = c(1, 3, 2, 4, 8, 6, 7, 5) ) %>%   mutate(     rowtype = \"Industries\",     coltype  = \"Products\"   ) tidy #>   matrix row col vals    rowtype  coltype #> 1      A  p1  i1    1 Industries Products #> 2      A  p1  i2    3 Industries Products #> 3      A  p2  i1    2 Industries Products #> 4      A  p2  i2    4 Industries Products #> 5      B  p1  i1    8 Industries Products #> 6      B  p1  i2    6 Industries Products #> 7      B  p2  i1    7 Industries Products #> 8      B  p2  i2    5 Industries Products mats <- tidy %>%   group_by(matrix) %>%   matsindf::collapse_to_matrices(matnames = \"matrix\", matvals = \"vals\",                                  rownames = \"row\", colnames = \"col\",                                  rowtypes = \"rowtype\", coltypes = \"coltype\") %>%   rename(     matrix.name = matrix,     matrix = vals   ) mats #>   matrix.name     matrix #> 1           A 1, 2, 3, 4 #> 2           B 8, 7, 6, 5 mats$matrix[[1]] #>    i1 i2 #> p1  1  3 #> p2  2  4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" mats$matrix[[2]] #>    i1 i2 #> p1  8  6 #> p2  7  5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\""},{"path":"/articles/matsbyname.html","id":"using-matsbyname-with-matsindf","dir":"Articles","previous_headings":"","what":"Using matsbyname with matsindf","title":"Use Cases and Examples for `matsbyname`","text":"matsbyname works well lists, data frame columns implemented lists, matsindf package can create data frames matrices, tidyr dplyr packages work data frames, matsbyname functions can used tidyr dplyr functions (spread mutate) perform matrix algebra within data frames matrices. single matsbyname instruction performs operation rows matsindf data frame. Loops begone!","code":"result <- mats %>%   tidyr::spread(key = matrix.name, value = matrix) %>%   # Duplicate the row to demonstrate byname operating simultaneously   # on all rows of the data frame.   dplyr::bind_rows(., .) %>%   dplyr::mutate(     # Create a column of constants.     c = RCLabels::make_list(x = 1:2, n = 2, lenx = 2),     # Sum all rows of the data frame with a single instruction.     sum = sum_byname(A, B),     # Multiply matrices in the sum column by corresponding constants in the c column.     product = hadamardproduct_byname(c, sum)   ) result #>            A          B c        sum        product #> 1 1, 2, 3, 4 8, 7, 6, 5 1 9, 9, 9, 9     9, 9, 9, 9 #> 2 1, 2, 3, 4 8, 7, 6, 5 2 9, 9, 9, 9 18, 18, 18, 18 result$sum[[1]] #>    i1 i2 #> p1  9  9 #> p2  9  9 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" result$sum[[2]] #>    i1 i2 #> p1  9  9 #> p2  9  9 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" result$product[[1]] #>    i1 i2 #> p1  9  9 #> p2  9  9 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" result$product[[2]] #>    i1 i2 #> p1 18 18 #> p2 18 18 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\""},{"path":"/articles/matsbyname.html","id":"suggested-workflow-using-matsbyname-and-matsindf","dir":"Articles","previous_headings":"","what":"Suggested workflow using matsbyname and matsindf","title":"Use Cases and Examples for `matsbyname`","text":"suggested analysis workflow follows: Munge data tidy data frame columns matrix name, element value, row name, column name, row type, column type, similar tidy . Use matsindf::collapse_to_matrices() create data frame matrices columns matrix names matrices , similar mats . tidyr::pivot_wider() matrices obtain data frame columns matrix, similar result . Perform matrix algebra operations columns matrices using *_byname functions. tidyr::pivot_longer() columns data frame single column matrices. Use matsindf::expand_to_tidy() create tidy data frame matrix elements. tidyr::pivot_wider() data necessary. Graph perform manipulations data. information detailed example workflow, see vignette matsindf package.","code":""},{"path":"/articles/matsbyname.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Use Cases and Examples for `matsbyname`","text":"matsbyname package simplifies analyses row column names respected. provides optional row column types, thereby ensuring valid matrix operations performed. Finally, matsbyname functions work equally well lists allow use *_byname functions tidyr dplyr approaches manipulating data.","code":""},{"path":"/articles/using-summarise-in-matsbyname.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using summarise in matsbyname","text":"matsbyname functions operands specified ... argument ambiguous applied data frame. argument (.summarise) signals intention, allowing ambiguous functions used flexibly data frames.","code":""},{"path":"/articles/using-summarise-in-matsbyname.html","id":"normal-functions","dir":"Articles","previous_headings":"","what":"“Normal” functions","title":"Using summarise in matsbyname","text":"normal functions, + mean(), ambiguity operation data frame. perform operations columns, use dplyr::summarise().","code":"df <- tibble::tribble(~x, ~y, ~z,                         1,  2,  3,                         4,  5,  6) # Typically, operations are done across rows. df %>%    dplyr::mutate(     a = x + y + z,     b = rowMeans(.)   ) #> # A tibble: 2 × 5 #>       x     y     z     a     b #>   <dbl> <dbl> <dbl> <dbl> <dbl> #> 1     1     2     3     6     2 #> 2     4     5     6    15     5 df %>%    dplyr::summarise(     x = sum(x),      y = sum(y),      z = sum(z)   ) #> # A tibble: 1 × 3 #>       x     y     z #>   <dbl> <dbl> <dbl> #> 1     5     7     9 df %>%    dplyr::summarise(     x = mean(x),      y = mean(y),      z = mean(z)   ) #> # A tibble: 1 × 3 #>       x     y     z #>   <dbl> <dbl> <dbl> #> 1   2.5   3.5   4.5"},{"path":"/articles/using-summarise-in-matsbyname.html","id":"matsbynamesum_byname","dir":"Articles","previous_headings":"","what":"matsbyname::sum_byname()","title":"Using summarise in matsbyname","text":"matsbyname::sum_byname() mean data frame? give sums across rows (+), give sums columns (summarise())? ambiguity present *_byname() functions operands specified via ... argument, including matrixproduct_byname(), hadamardproduct_byname(), mean_byname(), etc. resolve ambiguity, use .summarise argument. default value .summarise FALSE, meaning functions normally operate across rows. want perform action columns, set .summarise = TRUE.","code":"df %>%    dplyr::mutate(     a = sum_byname(x, y, z),      b = mean_byname(x, y, z)   ) #> # A tibble: 2 × 5 #>       x     y     z     a     b #>   <dbl> <dbl> <dbl> <dbl> <dbl> #> 1     1     2     3     6     2 #> 2     4     5     6    15     5 df %>%    dplyr::summarise(     x = sum_byname(x, .summarise = TRUE) %>% unlist(),      y = sum_byname(y, .summarise = TRUE) %>% unlist(),      z = sum_byname(z, .summarise = TRUE) %>% unlist()   ) #> # A tibble: 1 × 3 #>       x     y     z #>   <dbl> <dbl> <dbl> #> 1     5     7     9"},{"path":"/articles/using-summarise-in-matsbyname.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Using summarise in matsbyname","text":".summarise argument broadens range applicability many matsbyname functions, especially used data frames. default .summarise = FALSE, meaning operations performed across columns. Set .summarise = TRUE argument signal intent perform operations column.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matthew Heun. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Matthew Kuperus Heun (2023). matsbyname: Implementation Matrix Mathematics. R package version 0.6.2. https://CRAN.R-project.org/package=matsbyname","code":"@Manual{,   title = {matsbyname: An Implementation of Matrix Mathematics},   author = {Matthew Kuperus Heun},   year = {2023},   note = {R package version 0.6.2},   url = {https://CRAN.R-project.org/package=matsbyname}, }"},{"path":"/index.html","id":"matsbyname","dir":"","previous_headings":"","what":"An Implementation of Matrix Mathematics","title":"An Implementation of Matrix Mathematics","text":"R package matsbyname enables matrix mathematics wherein operations performed “name” row column types allowed.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An Implementation of Matrix Mathematics","text":"can install matsbyname CRAN : can install recent development version matsbyname github :","code":"install.packages(\"matsbyname\") # install devtools if not already installed # install.packages(\"devtools\") devtools::install_github(\"MatthewHeun/matsbyname\") # To build vignettes locally, use devtools::install_github(\"MatthewHeun/matsbyname\", build_vignettes = TRUE)"},{"path":"/index.html","id":"history","dir":"","previous_headings":"","what":"History","title":"An Implementation of Matrix Mathematics","text":"functions package used Heun et al. (2018).","code":""},{"path":"/index.html","id":"more-information","dir":"","previous_headings":"","what":"More Information","title":"An Implementation of Matrix Mathematics","text":"Find information, including vignettes function documentation, https://MatthewHeun.github.io/matsbyname/.","code":""},{"path":[]},{"path":"/reference/Iminus_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Subtract a matrix with named rows and columns from a suitably named and sized identity matrix (I) — Iminus_byname","title":"Subtract a matrix with named rows and columns from a suitably named and sized identity matrix (I) — Iminus_byname","text":"order rows columns m may change subtracting , rows columns sorted name prior subtracting . Furthermore, m square, made square subtracting calling complete_and_sort().","code":""},{"path":"/reference/Iminus_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subtract a matrix with named rows and columns from a suitably named and sized identity matrix (I) — Iminus_byname","text":"","code":"Iminus_byname(a)"},{"path":"/reference/Iminus_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subtract a matrix with named rows and columns from a suitably named and sized identity matrix (I) — Iminus_byname","text":"matrix subtracted .","code":""},{"path":"/reference/Iminus_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subtract a matrix with named rows and columns from a suitably named and sized identity matrix (I) — Iminus_byname","text":"difference identity matrix () m. (whose rows columns completed sorted)","code":""},{"path":"/reference/Iminus_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subtract a matrix with named rows and columns from a suitably named and sized identity matrix (I) — Iminus_byname","text":"","code":"m <- matrix(c(-21, -12, -21, -10), ncol = 2, dimnames = list(c(\"b\", \"a\"), c(\"b\", \"a\"))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") # Rows and columns are unsorted diag(1, nrow = 2) - m  #>    b  a #> b 22 21 #> a 12 11 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # Rows and columns are sorted prior to subtracting from the identity matrix Iminus_byname(m)  #>    a  b #> a 11 12 #> b 21 22 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # This also works with lists Iminus_byname(list(m,m)) #> [[1]] #>    a  b #> a 11 12 #> b 21 22 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    a  b #> a 11 12 #> b 21 22 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  # If the m is not square before subtracting from I, # it will be made square by the function complete_and_sort. m2 <- matrix(c(1,2,3,4,5,6), ncol = 2, dimnames = list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\"))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") Iminus_byname(m2) #>    a  b c #> a  0 -4 0 #> b -2 -4 0 #> c -3 -6 1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\""},{"path":"/reference/Matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Matrix amenable to use in the matsbyname package — Matrix","title":"Create a Matrix amenable to use in the matsbyname package — Matrix","text":"matsbyname package uses Matrix objects default data representation, taking advantage sparse matrix capabilities Matrix compared base matrix class. function routes Matrix::Matrix(), important differences. See details.","code":""},{"path":"/reference/Matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Matrix amenable to use in the matsbyname package — Matrix","text":"","code":"Matrix(   data = NA,   nrow = 1,   ncol = 1,   byrow = FALSE,   dimnames = base::dimnames(data),   sparse = NULL,   doDiag = FALSE,   forceCheck = FALSE,   rowtype = matsbyname::rowtype(data),   coltype = matsbyname::coltype(data) )"},{"path":"/reference/Matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Matrix amenable to use in the matsbyname package — Matrix","text":"data optional numeric data vector matrix. nrow data matrix Matrix, desired number rows. Default 1. ncol data matrix Matrix, desired number columns. Default 1. byrow boolean. FALSE (default) Matrix filled columns, otherwise Matrix filled rows. dimnames dimnames attribute Matrix: list two character components. Default base::dimnames(data). sparse boolean NULL. Specifies whether result sparse . default (NULL), Matrix made sparse half entries 0. doDiag boolean indicating diagonalMatrix object returned resulting Matrix diagonal (mathematically). Default FALSE, different Matrix::Matrix(). forceCheck boolean indicating checks structure happen data already Matrix object. Default FALSE. rowtype rowtype result. Default matsbyname::rowtype(data). coltype coltype result. Default matsbyname::coltype(data).","code":""},{"path":"/reference/Matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Matrix amenable to use in the matsbyname package — Matrix","text":"Matrix object.","code":""},{"path":"/reference/Matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Matrix amenable to use in the matsbyname package — Matrix","text":"function NEVER creates symmetric matrix, symmetric matrices respect future changes dimnames, can cause information loss matsbyname context. non-symmetric Matrix assured calling (, \"generalMatrix\") outgoing Matrix object. function enables setting row column types time construction rowtype coltype arguments. function different defaults compared Matrix::Matrix(), including , default doDiag FALSE, default doDiag TRUE Matrix::Matrix(). Preserves rowtype coltype data.","code":""},{"path":"/reference/Matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Matrix amenable to use in the matsbyname package — Matrix","text":"","code":"# matsbyname::Matrix() will not create a Matrix with a symmetric subclass. # dgCMatrix is a general matrix. matsbyname::Matrix(c(1, 0, 2,                       0, 0, 0,                       2, 0, 0), byrow = TRUE, nrow = 3, ncol = 3) #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>            #> [1,] 1 . 2 #> [2,] . . . #> [3,] 2 . . # But Matrix::Matrix() will create a symmetric matrix. # dsCMatrix is a symmetric matrix. Matrix::Matrix(c(1, 0, 2,                   0, 0, 0,                   2, 0, 0), byrow = TRUE, nrow = 3, ncol = 3) #> 3 x 3 sparse Matrix of class \"dsCMatrix\" #>            #> [1,] 1 . 2 #> [2,] . . . #> [3,] 2 . . # matsbyname::Matrix() will not create a diagonal matrix. # dgeMatrix is a general matrix. matsbyname::Matrix(c(1, 0,                       0, 1), byrow = TRUE, nrow = 2, ncol = 2) #> 2 x 2 Matrix of class \"dgeMatrix\" #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 # But Matrix::Matrix() will create a diagonal matrix. # ddiMatrix is a diagonal matrix. Matrix::Matrix(c(1, 0,                   0, 1), byrow = TRUE, nrow = 2, ncol = 2) #> 2 x 2 diagonal matrix of class \"ddiMatrix\" #>      [,1] [,2] #> [1,]    1    . #> [2,]    .    1"},{"path":"/reference/abs_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Absolute value of matrix elements — abs_byname","title":"Absolute value of matrix elements — abs_byname","text":"Absolute value matrix elements","code":""},{"path":"/reference/abs_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Absolute value of matrix elements — abs_byname","text":"","code":"abs_byname(a)"},{"path":"/reference/abs_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Absolute value of matrix elements — abs_byname","text":"matrix list matrices.","code":""},{"path":"/reference/abs_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Absolute value of matrix elements — abs_byname","text":"element replaced absolute value.","code":""},{"path":"/reference/abs_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Absolute value of matrix elements — abs_byname","text":"","code":"abs_byname(1) #> [1] 1 abs_byname(-1) #> [1] 1 m <- matrix(c(-10,1,1,100), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industry\") %>% setcoltype(\"Commodity\") m #>     c1  c2 #> i1 -10   1 #> i2   1 100 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\" abs_byname(m) #>    c1  c2 #> i1 10   1 #> i2  1 100 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\""},{"path":"/reference/aggregate_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate rows and columns in a matrix — aggregate_byname","title":"Aggregate rows and columns in a matrix — aggregate_byname","text":"Rows (margin = 1), columns (margin = 2), (margin = c(1, 2), default) aggregated according aggregation_map.","code":""},{"path":"/reference/aggregate_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate rows and columns in a matrix — aggregate_byname","text":"","code":"aggregate_byname(   a,   aggregation_map = NULL,   margin = c(1, 2),   pattern_type = \"exact\" )"},{"path":"/reference/aggregate_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate rows and columns in a matrix — aggregate_byname","text":"matrix list matrices whose rows columns aggregated. aggregation_map named list rows columns aggregated (NULL). See details. margin 1, 2, c(1, 2) row aggregation, column aggregation, . string, margin can row column type. Default c(1, 2). pattern_type See RCLabels::make_or_pattern(). Default \"exact\".","code":""},{"path":"/reference/aggregate_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate rows and columns in a matrix — aggregate_byname","text":"version aggregated rows /columns","code":""},{"path":"/reference/aggregate_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate rows and columns in a matrix — aggregate_byname","text":"aggregation_map NULL (default), rows (columns ) name aggregated together. aggregation_map NULL, must named list. name aggregation_map item name row column output contain specified aggregation. value item aggregation_map must vector names rows columns . names value aggregated inserted output name value. example aggregation_map = list(new_row = c(\"r1\", \"r2\")) aggregate rows \"r1\" \"r2\", delete rows \"r1\" \"r2\", insert new row whose name \"new_row\" whose value sum rows \"r1\" \"r2'. values aggregation_map interpreted regular expressions, escaped using Hmisc::escapeRegex() prior use. margin can string, case interpreted row column type. string margin match row column type, returned unmodified. Note aggregation one margin sort aggregated margin, margin guaranteed unique names.","code":""},{"path":"/reference/aggregate_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate rows and columns in a matrix — aggregate_byname","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following object is masked from ‘package:testthat’: #>  #>     matches #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(tibble) m <- matrix(1:9, byrow = TRUE, nrow = 3,              dimnames = list(c(\"r2\", \"r1\", \"r1\"), c(\"c2\", \"c1\", \"c1\"))) %>%    setrowtype(\"rows\") %>% setcoltype(\"cols\") # Aggregate all rows by establishing an aggregation map (`am`) am <- list(new_row = c(\"r1\", \"r2\")) aggregate_byname(m, aggregation_map = am, margin = 1) #>         c2 c1 c1 #> new_row 12 15 18 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" # aggregate_byname() also works with lists and in data frames m1 <- matrix(42, nrow = 1, dimnames = list(c(\"r1\"), c(\"c1\"))) m2 <- matrix(1:4, byrow = TRUE, nrow = 2,               dimnames = list(c(\"a\", \"a\"), c(\"a\", \"a\"))) m3 <- matrix(1:9, byrow = TRUE, nrow = 3,               dimnames = list(c(\"r2\", \"r1\", \"r1\"), c(\"c2\", \"c1\", \"c1\"))) DF <- tibble(m = list(m1, m1, m1, m2, m2, m2, m3, m3, m3),               margin = list(1, 2, c(1,2), 1, 2, c(1, 2), 1, 2, c(1, 2))) %>%    mutate(     aggregated = aggregate_byname(m, margin = margin),    ) m1 #>    c1 #> r1 42 DF$aggregated[[1]] # by rows #>    c1 #> r1 42 DF$aggregated[[2]] # by cols #>    c1 #> r1 42 DF$aggregated[[3]] # by rows and cols #>    c1 #> r1 42 m2 #>   a a #> a 1 2 #> a 3 4 DF$aggregated[[4]] # by rows #>   a a #> a 4 6 DF$aggregated[[5]] # by cols #>   a #> a 3 #> a 7 DF$aggregated[[6]] # by rows and cols #>    a #> a 10 m3 #>    c2 c1 c1 #> r2  1  2  3 #> r1  4  5  6 #> r1  7  8  9 DF$aggregated[[7]] # by rows #>    c2 c1 c1 #> r1 11 13 15 #> r2  1  2  3 DF$aggregated[[8]] # by cols #>    c1 c2 #> r2  5  1 #> r1 11  4 #> r1 17  7 DF$aggregated[[9]] # by rows and cols #>    c1 c2 #> r1 28 11 #> r2  5  1"},{"path":"/reference/aggregate_pieces_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate a matrix by pieces of row and/or column names — aggregate_pieces_byname","title":"Aggregate a matrix by pieces of row and/or column names — aggregate_pieces_byname","text":"Aggregate matrix (list matrices column matsindf data frame) pieces row column names.","code":""},{"path":"/reference/aggregate_pieces_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate a matrix by pieces of row and/or column names — aggregate_pieces_byname","text":"","code":"aggregate_pieces_byname(   a,   piece,   margin = list(c(1, 2)),   inf_notation = TRUE,   notation = list(RCLabels::notations_list),   choose_most_specific = FALSE,   prepositions = list(RCLabels::prepositions_list),   aggregation_map = NULL,   pattern_type = \"exact\" )"},{"path":"/reference/aggregate_pieces_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate a matrix by pieces of row and/or column names — aggregate_pieces_byname","text":"matrix list matrices. piece character string indicating piece row column names retain, one \"noun\", \"pps\", \"pref\" \"suff\", preposition, indicating part row column name retained. margin character, row type column type renamed. integer, margin renamed. Default c(1, 2), meaning rows (margin = 1) columns (margin = 2) renamed. inf_notation boolean tells whether infer notation. Default TRUE. notation notation used row column labels. Default list(RCLabels::notations_list). default value wrapped list, RCLabels::notations_list , , list. See RCLabels. choose_most_specific boolean indicates whether -specific notation inferred one notation matches row column label allow_multiple = FALSE. FALSE, first matching notation notations returned allow_multiple = FALSE. Default FALSE. prepositions Prepositions can used row column label. Default RCLabels::prepositions_list. aggregation_map named list rows columns aggregated (NULL). See details. pattern_type See RCLabels::make_or_pattern(). Default \"exact\".","code":""},{"path":"/reference/aggregate_pieces_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate a matrix by pieces of row and/or column names — aggregate_pieces_byname","text":"version rows /columns aggregated according aggregation_map.","code":""},{"path":"/reference/aggregate_pieces_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate a matrix by pieces of row and/or column names — aggregate_pieces_byname","text":"convenience function bundles two others common use cases: rename_to_piece_byname() followed aggregate_byname(). Note renaming piece, may rows columns identically named. identically named names included aggregation_map, error result. , aggregate_byname() called twice; first aggregation_map = NULL sweep rows columns identically named renaming second aggregation_map = aggregation_map sum desired rows columns. See examples. aggregation_map NULL (default), rows (columns ) name aggregated together. aggregation_map NULL, must named list. name aggregation_map item name row column output contain specified aggregation. value item aggregation_map must vector names rows columns . names value aggregated inserted output name value. example aggregation_map = list(new_row = c(\"r1\", \"r2\")) aggregate rows \"r1\" \"r2\", delete rows \"r1\" \"r2\", insert new row whose name \"new_row\" whose value sum rows \"r1\" \"r2'. values aggregation_map interpreted regular expressions, escaped using Hmisc::escapeRegex() prior use. aggregation_map aggregate pieces, full, original row /column names.","code":""},{"path":"/reference/aggregate_pieces_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate a matrix by pieces of row and/or column names — aggregate_pieces_byname","text":"","code":"a <- matrix(c(1, 2, 3,                4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE,              dimnames = list(c(\"a [from b]\", \"c [from d]\"),                              c(\"e [from f]\", \"g [from h]\", \"i [from j]\"))) a %>%   aggregate_pieces_byname(piece = \"suff\",                            notation = RCLabels::from_notation,                           aggregation_map = list(rows = c(\"b\", \"d\"),                                                   cols = c(\"h\", \"j\"))) #>      cols f #> rows   16 5 m <- matrix(c(1, 0, 0,                0, 1, 1,                0, 1, 1), nrow = 3, ncol = 3, byrow = TRUE,              dimnames = list(c(\"Gasoline [from Oil refineries]\",                                \"Electricity [from Main activity producer electricity plants]\",                                \"Electricity [from Hydro]\"),                             c(\"Automobiles\", \"LED lamps\", \"CFL lamps\"))) %>%   setrowtype(\"Product\") %>% setcoltype(\"Industry\") mT <- transpose_byname(m) # Aggregate the \"Electricity\" rows. aggregate_pieces_byname(m, piece = \"noun\", margin = \"Product\",                         notation = RCLabels::bracket_notation) #>             Automobiles LED lamps CFL lamps #> Electricity           0         2         2 #> Gasoline              1         0         0 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" # Also works in a list. aggregate_pieces_byname(a = list(m, mT), piece = \"noun\",                          margin = \"Product\",                         notation = RCLabels::bracket_notation) #> [[1]] #>             Automobiles LED lamps CFL lamps #> Electricity           0         2         2 #> Gasoline              1         0         0 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" #>  #> [[2]] #>             Electricity Gasoline #> Automobiles           0        1 #> LED lamps             2        0 #> CFL lamps             2        0 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  # Use an aggregation map aggregate_pieces_byname(a = list(m, mT), piece = \"noun\",                          margin = \"Product\",                         aggregation_map = list(list(final = c(\"Electricity\", \"Gasoline\"))),                         notation = RCLabels::bracket_notation) #> [[1]] #>       Automobiles LED lamps CFL lamps #> final           1         2         2 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" #>  #> [[2]] #>             final #> Automobiles     1 #> LED lamps       2 #> CFL lamps       2 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  # Also works in a data frame. df <- tibble::tibble(m = list(m, mT),                       pce = \"noun\",                      mgn = \"Product\",                      agg_map = list(list(final = c(\"Electricity\", \"Gasoline\"))),                       notn = list(RCLabels::bracket_notation)) %>%   dplyr::mutate(     agg = aggregate_pieces_byname(a = m, piece = pce, margin = mgn,                                    aggregation_map = agg_map,                                   notation = notn)   ) df$agg #> [[1]] #>       Automobiles LED lamps CFL lamps #> final           1         2         2 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" #>  #> [[2]] #>             final #> Automobiles     1 #> LED lamps       2 #> CFL lamps       2 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" #>  # Works when renaming to the piece results in identical row or col names. b <- matrix(1:6, nrow = 3, ncol = 2,              dimnames = list(c(\"a [from b]\", \"c [from d]\", \"c [from e]\"),                              c(\"c1\", \"c2\"))) b #>            c1 c2 #> a [from b]  1  4 #> c [from d]  2  5 #> c [from e]  3  6 # This aggregation works, because the \"c\" rows # are aggregated before applying the aggregation_map, # which, itself, does NOT aggregate the \"c\" rows. b %>%    aggregate_pieces_byname(piece = \"noun\",                           margin = 1,                           inf_notation = FALSE,                            notation = RCLabels::bracket_notation,                            aggregation_map = list(f = c(\"a\", \"b\"))) #>   c1 c2 #> c  5 11 #> f  1  4"},{"path":"/reference/aggregate_to_pref_suff_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate a matrix to prefixes or suffixes of row and/or column names — aggregate_to_pref_suff_byname","title":"Aggregate a matrix to prefixes or suffixes of row and/or column names — aggregate_to_pref_suff_byname","text":"Row column names often constructed form prefix_start prefix prefix_end suffix_start suffix suffix_end described notation vector. (See notation_vec().) function performs aggregation prefix suffix according notation vector.","code":""},{"path":"/reference/aggregate_to_pref_suff_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate a matrix to prefixes or suffixes of row and/or column names — aggregate_to_pref_suff_byname","text":"","code":"aggregate_to_pref_suff_byname(   a,   aggregation_map = NULL,   keep,   margin = c(1, 2),   notation,   pattern_type = \"exact\" )"},{"path":"/reference/aggregate_to_pref_suff_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate a matrix to prefixes or suffixes of row and/or column names — aggregate_to_pref_suff_byname","text":"matrix list matrices aggregated prefix suffix. aggregation_map See aggregate_byname(). keep See rename_to_pref_suff_byname() margin dimension aggregation performed; 1 rows, 2 columns, c(1, 2) . notation See notation_vec(). pattern_type See aggregate_byname().","code":""},{"path":"/reference/aggregate_to_pref_suff_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate a matrix to prefixes or suffixes of row and/or column names — aggregate_to_pref_suff_byname","text":"aggregated version .","code":""},{"path":"/reference/aggregate_to_pref_suff_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate a matrix to prefixes or suffixes of row and/or column names — aggregate_to_pref_suff_byname","text":"function convenience function, bundles sequential calls two helper functions, rename_to_pref_suff_byname() aggregate_byname(). arguments passed helper functions.","code":""},{"path":"/reference/aggregate_to_pref_suff_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate a matrix to prefixes or suffixes of row and/or column names — aggregate_to_pref_suff_byname","text":"","code":"# This function is superseded.  # Instead, use `aggregate_pieces_byname()`. # For example: m <- matrix((1:9), byrow = TRUE, nrow = 3,              dimnames = list(c(\"r1 -> b\", \"r2 -> b\", \"r3 -> a\"), c(\"c1 -> z\", \"c2 -> y\", \"c3 -> y\"))) m #>         c1 -> z c2 -> y c3 -> y #> r1 -> b       1       2       3 #> r2 -> b       4       5       6 #> r3 -> a       7       8       9 aggregate_pieces_byname(m, piece = \"pref\", notation = RCLabels::arrow_notation) #>    c1 c2 c3 #> r1  1  2  3 #> r2  4  5  6 #> r3  7  8  9 aggregate_pieces_byname(m, piece = \"suff\", notation = RCLabels::arrow_notation) #>    y z #> a 17 7 #> b 16 5  # Original examples: # Aggregation by prefixes does nothing more than rename, because all prefixes are different. # Doing renaming like this (without also aggregating) is potentially dangerous, because   # some rows and some columns could end up with same names. aggregate_to_pref_suff_byname(m, keep = \"pref\", notation = RCLabels::arrow_notation) #>    c1 c2 c3 #> r1  1  2  3 #> r2  4  5  6 #> r3  7  8  9 # Aggregation by suffix reduces the number of rows and columns,  # because there are same suffixes in both rows and columns aggregate_to_pref_suff_byname(m, keep = \"suff\", notation = RCLabels::arrow_notation) #>    y z #> a 17 7 #> b 16 5"},{"path":"/reference/aggregation_map_helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregation map conversions — aggregation_map_helpers","title":"Aggregation map conversions — aggregation_map_helpers","text":"Aggregation many--operation specifics summed comprise broader categories. Examples include \"John\", \"Paul\", \"George\", \"Ringo\" aggregated \"Beatles\"; \"Mick\", \"Keith\", \"Ronnie\", \"Bill\", \"Charlie\" aggregated \"Stones\". aggregation map named list describes aggregation performed. aggregation map examples list(Beatles = c(\"John\", \"Paul\", \"George\", \"Ringo\"),  Stones = c(\"Mick\", \"Keith\", \"Ronnie\", \"Bill\", \"Charlie\")) Aggregation maps can generated many shapes data. functions assist translating different data shapes aggregation maps.","code":""},{"path":"/reference/aggregation_map_helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregation map conversions — aggregation_map_helpers","text":"","code":"agg_table_to_agg_map(.df, few_colname, many_colname)  agg_map_to_agg_table(aggregation_map, few_colname, many_colname)"},{"path":"/reference/aggregation_map_helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregation map conversions — aggregation_map_helpers","text":".df data frame aggregation map extracted. few_colname string name column data frame corresponds \"\" aggregated categories. many_colname string name column data frame corresponds \"many\" specific items aggregated. aggregation_map aggregation map converted data frame.","code":""},{"path":"/reference/aggregation_map_helpers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregation map conversions — aggregation_map_helpers","text":"agg_table_to_agg_map(), aggregation map. agg_map_to_agg_table(), data.frame, probably tibble.","code":""},{"path":"/reference/aggregation_map_helpers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregation map conversions — aggregation_map_helpers","text":"","code":"bands <- tibble::tribble(~band, ~members,                           \"The Beatles\", \"John\",                           \"The Beatles\", \"Paul\",                           \"The Beatles\", \"George\",                           \"The Beatles\", \"Ringo\",                           # Rejects duplicates and NA                          \"The Beatles\", \"Ringo\",                          \"The Beatles\", NA,                           \"Rolling Stones\", \"Mick\",                           \"Rolling Stones\", \"Keith\",                          \"Rolling Stones\", \"Ronnie\",                          \"Rolling Stones\", \"Bill\",                          \"Rolling Stones\", \"Charlie\") agg_map <- agg_table_to_agg_map(bands,                                   few_colname = \"band\",                                  many_colname = \"members\") agg_map #> $`Rolling Stones` #> [1] \"Mick\"    \"Keith\"   \"Ronnie\"  \"Bill\"    \"Charlie\" #>  #> $`The Beatles` #> [1] \"John\"   \"Paul\"   \"George\" \"Ringo\"  #>  agg_map_to_agg_table(agg_map, few_colname = \"bands\", many_colname = \"members\") #> # A tibble: 9 × 2 #>   bands          members #>   <chr>          <chr>   #> 1 Rolling Stones Mick    #> 2 Rolling Stones Keith   #> 3 Rolling Stones Ronnie  #> 4 Rolling Stones Bill    #> 5 Rolling Stones Charlie #> 6 The Beatles    John    #> 7 The Beatles    Paul    #> 8 The Beatles    George  #> 9 The Beatles    Ringo"},{"path":"/reference/all_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Are all matrix elements TRUE? — all_byname","title":"Are all matrix elements TRUE? — all_byname","text":"Tells whether elements matrix true.","code":""},{"path":"/reference/all_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are all matrix elements TRUE? — all_byname","text":"","code":"all_byname(a)"},{"path":"/reference/all_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are all matrix elements TRUE? — all_byname","text":"matrix list matrices","code":""},{"path":"/reference/all_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are all matrix elements TRUE? — all_byname","text":"TRUE elements TRUE, FALSE otherwise","code":""},{"path":"/reference/all_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Are all matrix elements TRUE? — all_byname","text":"can matrix list matrices.","code":""},{"path":"/reference/all_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are all matrix elements TRUE? — all_byname","text":"","code":"all_byname(matrix(rep(TRUE, times = 4), nrow = 2, ncol = 2)) #> [1] TRUE all_byname(matrix(c(TRUE, FALSE), nrow = 2, ncol = 1)) #> [1] FALSE"},{"path":"/reference/and_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"And ","title":"And ","text":"Operands logical, although numerical operands accepted. Numerical operands interpreted FALSE 0 TRUE number.","code":""},{"path":"/reference/and_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"And ","text":"","code":"and_byname(..., .summarise = FALSE)"},{"path":"/reference/and_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"And ","text":"... Operands logical function. .summarise Tells whether operation accomplished across lists (FALSE) lists (TRUE).","code":""},{"path":"/reference/and_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"And ","text":"Logical applied operands.","code":""},{"path":"/reference/and_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"And ","text":"","code":"and_byname(TRUE) #> [1] TRUE and_byname(FALSE) #> [1] FALSE and_byname(list(TRUE, FALSE), list(TRUE, TRUE), list(TRUE, TRUE), list(TRUE, TRUE)) #> [[1]] #> [1] TRUE #>  #> [[2]] #> [1] FALSE #>  m1 <- matrix(c(TRUE, TRUE, TRUE, FALSE), nrow = 2, ncol = 2,    dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\"))) m2 <- matrix(c(TRUE, FALSE, TRUE, TRUE), nrow = 2, ncol = 2,   dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\"))) and_byname(m1, m1) #>      c1    c2 #> r1 TRUE  TRUE #> r2 TRUE FALSE and_byname(m1, m2) #>       c1    c2 #> r1  TRUE  TRUE #> r2 FALSE FALSE and_byname(list(m1, m1), list(m1, m1), list(m2, m2)) #> [[1]] #>       c1    c2 #> r1  TRUE  TRUE #> r2 FALSE FALSE #>  #> [[2]] #>       c1    c2 #> r1  TRUE  TRUE #> r2 FALSE FALSE #>  and_byname(list(m1, m1), list(m1, m1), list(m2, m2), .summarise = TRUE) #> [[1]] #>      c1    c2 #> r1 TRUE  TRUE #> r2 TRUE FALSE #>  #> [[2]] #>      c1    c2 #> r1 TRUE  TRUE #> r2 TRUE FALSE #>  #> [[3]] #>       c1   c2 #> r1  TRUE TRUE #> r2 FALSE TRUE #>"},{"path":"/reference/any_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Are any matrix elements TRUE? — any_byname","title":"Are any matrix elements TRUE? — any_byname","text":"Tells whether elements matrix true.","code":""},{"path":"/reference/any_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are any matrix elements TRUE? — any_byname","text":"","code":"any_byname(a)"},{"path":"/reference/any_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are any matrix elements TRUE? — any_byname","text":"matrix list matrices","code":""},{"path":"/reference/any_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are any matrix elements TRUE? — any_byname","text":"TRUE elements TRUE, FALSE otherwise","code":""},{"path":"/reference/any_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Are any matrix elements TRUE? — any_byname","text":"can matrix list matrices.","code":""},{"path":"/reference/any_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are any matrix elements TRUE? — any_byname","text":"","code":"any_byname(matrix(c(TRUE, FALSE), nrow = 2, ncol = 1)) #> [1] TRUE any_byname(matrix(rep(FALSE, times = 4), nrow = 2, ncol = 2)) #> [1] FALSE"},{"path":"/reference/binaryapply_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a binary function ","title":"Apply a binary function ","text":"either b missing NULL, 0 passed FUN place. Note either b lists, elements must named . names list elements applied output.","code":""},{"path":"/reference/binaryapply_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a binary function ","text":"","code":"binaryapply_byname(   FUN,   a,   b,   .FUNdots = NULL,   match_type = c(\"all\", \"matmult\", \"none\"),   set_rowcoltypes = TRUE,   .organize = TRUE )"},{"path":"/reference/binaryapply_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a binary function ","text":"FUN binary function applied \"name\" b. first operand FUN. b second operand FUN. .FUNdots list additional named arguments passed FUN. match_type one \"\", \"matmult\", \"none\". b matrices, \"\" (default) indicates rowtypes must match rowtypes b coltypes must match coltypes b. \"matmult\", coltypes must match rowtypes b. \"none\", neither coltypes rowtypes checked. set_rowcoltypes tells whether apply row column types b output. Set TRUE (default) apply row column types output. Set FALSE, apply row column types output. .organize boolean tells whether automatically complete b relative sort rows columns completed matrices. Normally, TRUE (default). However, FUN takes responsibility, set FALSE.","code":""},{"path":"/reference/binaryapply_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a binary function ","text":"result applying FUN \"name\" b.","code":""},{"path":"/reference/binaryapply_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a binary function ","text":"","code":"productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") Y <- matrix(1:4, ncol = 2, dimnames = list(rev(productnames), rev(industrynames))) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") sum_byname(U, Y) #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" binaryapply_byname(`+`, U, Y) #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\""},{"path":"/reference/clean_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean (delete) rows or columns of matrices that contain exclusively clean_value — clean_byname","title":"Clean (delete) rows or columns of matrices that contain exclusively clean_value — clean_byname","text":"Cleaning performed entries row column , depending value margin, within +/- tol clean_value. Internally, values deemed within +/- tol abs(x - clean_value) <= tol.","code":""},{"path":"/reference/clean_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean (delete) rows or columns of matrices that contain exclusively clean_value — clean_byname","text":"","code":"clean_byname(a, margin = c(1, 2), clean_value = 0, tol = 0)"},{"path":"/reference/clean_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean (delete) rows or columns of matrices that contain exclusively clean_value — clean_byname","text":"matrix cleaned. margin dimension cleaning occur, 1 rows, 2 columns, c(1, 2) rows columns. Default c(1, 2). clean_value undesirable value. Default 0. tol tolerance value deemed equal clean_value. Default 0.","code":""},{"path":"/reference/clean_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean (delete) rows or columns of matrices that contain exclusively clean_value — clean_byname","text":"\"cleaned\" matrix, expunged rows columns contain exclusively clean_value.","code":""},{"path":"/reference/clean_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clean (delete) rows or columns of matrices that contain exclusively clean_value — clean_byname","text":"concern machine precision, might want call function tol = .Machine$double.eps. row (margin = 1) column (margin = 2) contains exclusively clean_value (within tol), row column deleted matrix.","code":""},{"path":"/reference/clean_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clean (delete) rows or columns of matrices that contain exclusively clean_value — clean_byname","text":"","code":"m <- matrix(c(-20, 1, -20, 2), nrow = 2, dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\"))) m #>     c1  c2 #> r1 -20 -20 #> r2   1   2 m %>% clean_byname(margin = 1, clean_value = -20) # Eliminates -20, -20 row #>    c1 c2 #> r2  1  2 # Nothing cleaned, because no columns contain all 0's (the default clean_value). m %>% clean_byname(margin = 2)  #>     c1  c2 #> r1 -20 -20 #> r2   1   2 # Also works with lists list(m, m) %>% clean_byname(margin = 1, clean_value = -20) #> [[1]] #>    c1 c2 #> r2  1  2 #>  #> [[2]] #>    c1 c2 #> r2  1  2 #>  # Also works with data frames DF <- data.frame(m = I(list())) DF[[1,\"m\"]] <- m DF[[2,\"m\"]] <- m DF %>% clean_byname(margin = 1, clean_value = -20) #> $m #> $m[[1]] #>    c1 c2 #> r2  1  2 #>  #> $m[[2]] #>    c1 c2 #> r2  1  2 #>  #>  m2 <- matrix(c(-20, -20, 0, -20, -20, 0, -20, -20, -20), nrow = 3,              dimnames = list(c(\"r1\", \"r2\", \"r3\"), c(\"c1\", \"c2\", \"c3\")) ) m2 #>     c1  c2  c3 #> r1 -20 -20 -20 #> r2 -20 -20 -20 #> r3   0   0 -20 clean_byname(m2, margin = c(1,2), clean_value = -20) #>    c1 c2 #> r3  0  0 DF2 <- data.frame(m2 = I(list())) DF2[[1, \"m2\"]] <- m2 DF2[[2, \"m2\"]] <- m2 DF2 %>% clean_byname(margin = c(1, 2), clean_value = -20) #> $m2 #> $m2[[1]] #>    c1 c2  c3 #> r3  0  0 -20 #>  #> $m2[[2]] #>     c1  c2 #> r1 -20 -20 #> r2 -20 -20 #> r3   0   0 #>  #>"},{"path":"/reference/colprods_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Column products, sorted by name — colprods_byname","title":"Column products, sorted by name — colprods_byname","text":"Calculates column products (product elements column) matrix. optional rowname resulting row vector can supplied. rowname NULL NA (default), row name set row type given rowtype().","code":""},{"path":"/reference/colprods_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Column products, sorted by name — colprods_byname","text":"","code":"colprods_byname(a, rowname = NA)"},{"path":"/reference/colprods_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Column products, sorted by name — colprods_byname","text":"matrix data frame column products desired. rowname Name output row containing column products.","code":""},{"path":"/reference/colprods_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Column products, sorted by name — colprods_byname","text":"row vector type matrix containing column products .","code":""},{"path":"/reference/colprods_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Column products, sorted by name — colprods_byname","text":"","code":"library(dplyr) M <- matrix(c(1:6), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 3:1))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") colprods_byname(M) #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" colprods_byname(M, rowname = \"E.ktoe\") #>        c1 c2 c3 #> E.ktoe 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" M %>% colprods_byname %>% rowprods_byname #>            Commodities #> Industries         720 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # This also works with lists colprods_byname(list(M, M)) #> [[1]] #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  colprods_byname(list(M, M), rowname = \"E.ktoe\") #> [[1]] #>        c1 c2 c3 #> E.ktoe 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>        c1 c2 c3 #> E.ktoe 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  colprods_byname(list(M, M), rowname = NA) #> [[1]] #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  colprods_byname(list(M, M), rowname = NULL) #> [[1]] #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  DF <- data.frame(M = I(list())) DF[[1,\"M\"]] <- M DF[[2,\"M\"]] <- M colprods_byname(DF$M[[1]]) #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" colprods_byname(DF$M) #> [[1]] #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>            c1 c2 c3 #> Industries 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  colprods_byname(DF$M, \"prods\") #> [[1]] #>       c1 c2 c3 #> prods 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>       c1 c2 c3 #> prods 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  res <- DF %>% mutate(   cs = colprods_byname(M),   cs2 = colprods_byname(M, rowname = \"prod\") ) res$cs2 #> [[1]] #>      c1 c2 c3 #> prod 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>      c1 c2 c3 #> prod 30 12  2 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>"},{"path":"/reference/colsums_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Column sums, sorted by name — colsums_byname","title":"Column sums, sorted by name — colsums_byname","text":"Calculates column sums matrix premultiplying identity vector (containing 1's). contrast colSums (returns numeric result), return value colsums_byname matrix. optional rowname resulting row vector can supplied. rowname NA (default), row name set row type given rowtype(). rowname set NULL, row name returned empty.","code":""},{"path":"/reference/colsums_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Column sums, sorted by name — colsums_byname","text":"","code":"colsums_byname(a, rowname = NA)"},{"path":"/reference/colsums_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Column sums, sorted by name — colsums_byname","text":"matrix list matrices column sums desired. rowname name output row containing column sums.","code":""},{"path":"/reference/colsums_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Column sums, sorted by name — colsums_byname","text":"row vector type matrix containing column sums .","code":""},{"path":"/reference/colsums_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Column sums, sorted by name — colsums_byname","text":"","code":"library(dplyr) colsums_byname(42) #> [1] 42 m <- matrix(c(1:6), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 3:1))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") m #>    c3 c2 c1 #> i1  1  3  5 #> i2  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" colsums_byname(m) #>            c1 c2 c3 #> Industries 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" colsums_byname(m, rowname = \"E.ktoe\") #>        c1 c2 c3 #> E.ktoe 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" m %>%    colsums_byname() %>%    rowsums_byname() #>            Commodities #> Industries          21 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # This also works with lists colsums_byname(list(m, m)) #> [[1]] #>            c1 c2 c3 #> Industries 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>            c1 c2 c3 #> Industries 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  colsums_byname(list(m, m), rowname = \"E.ktoe\") #> [[1]] #>        c1 c2 c3 #> E.ktoe 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>        c1 c2 c3 #> E.ktoe 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  colsums_byname(list(m, m), rowname = NA) #> [[1]] #>            c1 c2 c3 #> Industries 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>            c1 c2 c3 #> Industries 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  colsums_byname(list(m, m), rowname = NULL) #> [[1]] #>      c1 c2 c3 #> [1,] 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>      c1 c2 c3 #> [1,] 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  DF <- data.frame(m = I(list())) DF[[1,\"m\"]] <- m DF[[2,\"m\"]] <- m colsums_byname(DF$m[[1]]) #>            c1 c2 c3 #> Industries 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" colsums_byname(DF$m) #> [[1]] #>            c1 c2 c3 #> Industries 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>            c1 c2 c3 #> Industries 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  colsums_byname(DF$m, \"sums\") #> [[1]] #>      c1 c2 c3 #> sums 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>      c1 c2 c3 #> sums 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  res <- DF %>% mutate(   cs = colsums_byname(m),   cs2 = colsums_byname(m, rowname = \"sum\") ) res$cs2 #> [[1]] #>     c1 c2 c3 #> sum 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>     c1 c2 c3 #> sum 11  7  3 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>"},{"path":"/reference/coltype.html","id":null,"dir":"Reference","previous_headings":"","what":"Column type — coltype","title":"Column type — coltype","text":"Extracts column type .","code":""},{"path":"/reference/coltype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Column type — coltype","text":"","code":"coltype(a)"},{"path":"/reference/coltype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Column type — coltype","text":"object want extract column types.","code":""},{"path":"/reference/coltype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Column type — coltype","text":"column type .","code":""},{"path":"/reference/coltype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Column type — coltype","text":"","code":"commoditynames <- c(\"c1\", \"c2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %>%   setrowtype(rowtype = \"Commodities\") %>% setcoltype(\"Industries\") coltype(U) #> [1] \"Industries\" # This also works for lists coltype(list(U,U)) #> [[1]] #> [1] \"Industries\" #>  #> [[2]] #> [1] \"Industries\" #>"},{"path":"/reference/compare_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare matrix entries to a value — compare_byname","title":"Compare matrix entries to a value — compare_byname","text":"Compares matrix entries value, returning matrix size containing TRUE FALSE values result applying compare_fun val entries .","code":""},{"path":"/reference/compare_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare matrix entries to a value — compare_byname","text":"","code":"compare_byname(a, compare_fun = c(\"==\", \"!=\", \"<\", \"<=\", \">=\", \">\"), val = 0)"},{"path":"/reference/compare_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare matrix entries to a value — compare_byname","text":"matrix list matrices whose values counted according compare_fun compare_fun comparison function, one \"==\", \"!=\", \"<\", \"<=\", \">=\", \">\". Default \"==\". val single value entries matrix compared. Default 0.","code":""},{"path":"/reference/compare_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare matrix entries to a value — compare_byname","text":"logical matrix size containing TRUE criterion met, FALSE otherwise","code":""},{"path":"/reference/compare_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare matrix entries to a value — compare_byname","text":"","code":"m <- matrix(c(0, 1, 2, 3, 4, 0), nrow = 3, ncol = 2) compare_byname(m, \"<\", 3) #>      [,1]  [,2] #> [1,] TRUE FALSE #> [2,] TRUE FALSE #> [3,] TRUE  TRUE compare_byname(list(m,m), \"<\", 3) #> [[1]] #>      [,1]  [,2] #> [1,] TRUE FALSE #> [2,] TRUE FALSE #> [3,] TRUE  TRUE #>  #> [[2]] #>      [,1]  [,2] #> [1,] TRUE FALSE #> [2,] TRUE FALSE #> [3,] TRUE  TRUE #>"},{"path":"/reference/complete_and_sort.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete matrices relative to one another and sort into same row, column order — complete_and_sort","title":"Complete matrices relative to one another and sort into same row, column order — complete_and_sort","text":"Completes matrix relative , thereby assuring matrices row column names. Missing rows columns (relative matrix) filled fill. Thereafter, rows columns matrices sorted order (name). complete rows m1 relative columns m2, set m2 argument transpose_byname(m2).","code":""},{"path":"/reference/complete_and_sort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete matrices relative to one another and sort into same row, column order — complete_and_sort","text":"","code":"complete_and_sort(   a,   b,   fill = 0,   margin = c(1, 2),   roworder = NA,   colorder = NA )"},{"path":"/reference/complete_and_sort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Complete matrices relative to one another and sort into same row, column order — complete_and_sort","text":"first matrix b second (optional) matrix. fill rows columns added b contain value fill (double). margin Specifies dimension(s) b completing sorting occur roworder Specifies custom ordering rows returned matrices. Unspecified rows dropped. colorder Specifies custom ordering columns returned matrices. Unspecified columns dropped.","code":""},{"path":"/reference/complete_and_sort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Complete matrices relative to one another and sort into same row, column order — complete_and_sort","text":"named list containing completed sorted versions b.","code":""},{"path":"/reference/complete_and_sort.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Complete matrices relative to one another and sort into same row, column order — complete_and_sort","text":"margin nearly semantic meaning base::apply(). rows , give 1; columns , give 2; rows columns, give c(1,2), default value. m1 specified, rows m1 completed sorted relative columns m1. neither m1 m2 dimnames, m1 m2 returned unmodified. one m1 m2 dimnames, error thrown.","code":""},{"path":"/reference/complete_and_sort.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Complete matrices relative to one another and sort into same row, column order — complete_and_sort","text":"","code":"m1 <- matrix(c(1:6), nrow=3, dimnames = list(c(\"r1\", \"r2\", \"r3\"), c(\"c2\", \"c1\"))) m2 <- matrix(c(7:12), ncol=3, dimnames = list(c(\"r3\", \"r4\"), c(\"c2\", \"c3\", \"c4\"))) complete_and_sort(m1) #>    c1 c2 r1 r2 r3 #> c1  0  0  0  0  0 #> c2  0  0  0  0  0 #> r1  4  1  0  0  0 #> r2  5  2  0  0  0 #> r3  6  3  0  0  0 complete_and_sort(m1, m2) #> $a #>    c1 c2 c3 c4 #> r1  4  1  0  0 #> r2  5  2  0  0 #> r3  6  3  0  0 #> r4  0  0  0  0 #>  #> $b #>    c1 c2 c3 c4 #> r1  0  0  0  0 #> r2  0  0  0  0 #> r3  0  7  9 11 #> r4  0  8 10 12 #>  complete_and_sort(m1, m2, roworder = c(\"r3\", \"r2\", \"r1\")) #> $a #>    c1 c2 c3 c4 #> r3  6  3  0  0 #> r2  5  2  0  0 #> r1  4  1  0  0 #>  #> $b #>    c1 c2 c3 c4 #> r3  0  7  9 11 #> r2  0  0  0  0 #> r1  0  0  0  0 #>  complete_and_sort(m1, m2, colorder = c(\"c4\", \"c3\")) # Drops un-specified columns #> $a #>    c4 c3 #> r1  0  0 #> r2  0  0 #> r3  0  0 #> r4  0  0 #>  #> $b #>    c4 c3 #> r1  0  0 #> r2  0  0 #> r3 11  9 #> r4 12 10 #>  complete_and_sort(m1, m2, margin = 1) #> $a #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #> r4  0  0 #>  #> $b #>    c2 c3 c4 #> r1  0  0  0 #> r2  0  0  0 #> r3  7  9 11 #> r4  8 10 12 #>  complete_and_sort(m1, m2, margin = 2) #> $a #>    c1 c2 c3 c4 #> r1  4  1  0  0 #> r2  5  2  0  0 #> r3  6  3  0  0 #>  #> $b #>    c1 c2 c3 c4 #> r3  0  7  9 11 #> r4  0  8 10 12 #>  complete_and_sort(m1, t(m2)) #> $a #>    c1 c2 r3 r4 #> c2  0  0  0  0 #> c3  0  0  0  0 #> c4  0  0  0  0 #> r1  4  1  0  0 #> r2  5  2  0  0 #> r3  6  3  0  0 #>  #> $b #>    c1 c2 r3 r4 #> c2  0  0  7  8 #> c3  0  0  9 10 #> c4  0  0 11 12 #> r1  0  0  0  0 #> r2  0  0  0  0 #> r3  0  0  0  0 #>  complete_and_sort(m1, t(m2), margin = 1) #> $a #>    c2 c1 #> c2  0  0 #> c3  0  0 #> c4  0  0 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> $b #>    r3 r4 #> c2  7  8 #> c3  9 10 #> c4 11 12 #> r1  0  0 #> r2  0  0 #> r3  0  0 #>  complete_and_sort(m1, t(m2), margin = 2) #> $a #>    c1 c2 r3 r4 #> r1  4  1  0  0 #> r2  5  2  0  0 #> r3  6  3  0  0 #>  #> $b #>    c1 c2 r3 r4 #> c2  0  0  7  8 #> c3  0  0  9 10 #> c4  0  0 11 12 #>  v <- matrix(1:6, ncol=2, dimnames=list(c(\"r3\", \"r1\", \"r2\"), c(\"c2\", \"c1\"))) complete_and_sort(v, v) #> $a #>    c1 c2 #> r1  5  2 #> r2  6  3 #> r3  4  1 #>  #> $b #>    c1 c2 #> r1  5  2 #> r2  6  3 #> r3  4  1 #>  # Also works with lists complete_and_sort(list(m1,m1), list(m2,m2)) #> $a #> $a[[1]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #> r4  0  0 #>  #> $a[[2]] #>    c1 c2 c3 c4 #> r1  4  1  0  0 #> r2  5  2  0  0 #> r3  6  3  0  0 #>  #>  #> $b #> $b[[1]] #>    c2 c3 c4 #> r1  0  0  0 #> r2  0  0  0 #> r3  7  9 11 #> r4  8 10 12 #>  #> $b[[2]] #>    c1 c2 c3 c4 #> r3  0  7  9 11 #> r4  0  8 10 12 #>  #>"},{"path":"/reference/complete_rows_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete rows and columns in one matrix relative to another — complete_rows_cols","title":"Complete rows and columns in one matrix relative to another — complete_rows_cols","text":"\"Completing\" rows columns means contains union rows columns mat, missing data represented value fill (0, default), fillrow, fillcol.","code":""},{"path":"/reference/complete_rows_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete rows and columns in one matrix relative to another — complete_rows_cols","text":"","code":"complete_rows_cols(   a = NULL,   mat = NULL,   fill = 0,   fillrow = NULL,   fillcol = NULL,   margin = c(1, 2) )"},{"path":"/reference/complete_rows_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Complete rows and columns in one matrix relative to another — complete_rows_cols","text":"matrix list matrix objects completed. can Matrix objects, . mat matrix Matrix dimnames extracted purposes completing respect mat. fill Rows columns added contain value fill. (Default 0.) fillrow row vector type matrix column names . rows added fillrow. non-NULL, fillrow takes precedence fillcol fill case conflicts. fillcol column vector type matrix row names . columns added fillcol. non-NULL, fillcol takes precedence fill case conflicts. margin Specifies subscript(s) completion occur margin nearly semantic meaning base::apply() rows , give 1; columns , give 2; rows columns, give c(1,2), default value.","code":""},{"path":"/reference/complete_rows_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Complete rows and columns in one matrix relative to another — complete_rows_cols","text":"modified version possibly containing additional rows columns whose names obtained mat whose values obtained fillrow, fillcol fill (order preference).","code":""},{"path":"/reference/complete_rows_cols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Complete rows and columns in one matrix relative to another — complete_rows_cols","text":"Note complete_rows_cols(mat1, mat2) complete_rows_cols(mat2, mat1) guaranteed order rows columns. (values matrix guaranteed positions.) dimnames(mat) NULL, returned unmodified. either mat missing names margin (row column), error given. non-NULL, named, mat NULL (default), completed relative , meaning made square, containing union row column names . conditions, warning given. mat non-NULL dimnames mat determined (, example, mat dimnames), completed relative warning given. added rows columns created one fill* arguments. conflicts arise, precedence among fill* arguments fillrow fillcol fill.","code":""},{"path":"/reference/complete_rows_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Complete rows and columns in one matrix relative to another — complete_rows_cols","text":"","code":"m1 <- matrix(c(1:6), nrow=3, dimnames = list(c(\"r1\", \"r2\", \"r3\"), c(\"c1\", \"c2\"))) m1 #>    c1 c2 #> r1  1  4 #> r2  2  5 #> r3  3  6 m2 <- matrix(c(7:12), ncol=3, dimnames = list(c(\"r2\", \"r3\"), c(\"c2\", \"c3\", \"c4\"))) m2 #>    c2 c3 c4 #> r2  7  9 11 #> r3  8 10 12 complete_rows_cols(m1, m2) # Adds empty column c4 #>    c1 c2 c3 c4 #> r1  1  4  0  0 #> r2  2  5  0  0 #> r3  3  6  0  0 complete_rows_cols(m1, t(m2)) # Creates r2, r3 columns; c2, c3, c4 rows #>    c1 c2 r2 r3 #> r1  1  4  0  0 #> r2  2  5  0  0 #> r3  3  6  0  0 #> c2  0  0  0  0 #> c3  0  0  0  0 #> c4  0  0  0  0 complete_rows_cols(m1, m2, margin = 1) # No changes because r2 and r3 already present in m1 #>    c1 c2 #> r1  1  4 #> r2  2  5 #> r3  3  6 complete_rows_cols(m1, m2, margin = 2) # Adds empty columns c3 and c4 #>    c1 c2 c3 c4 #> r1  1  4  0  0 #> r2  2  5  0  0 #> r3  3  6  0  0 complete_rows_cols(m1, t(m2), margin = 1) # Adds empty rows c2, c3, c4 #>    c1 c2 #> r1  1  4 #> r2  2  5 #> r3  3  6 #> c2  0  0 #> c3  0  0 #> c4  0  0 complete_rows_cols(m1, m2, fill = 100) # Adds columns c3 and c4 with 100's #>    c1 c2  c3  c4 #> r1  1  4 100 100 #> r2  2  5 100 100 #> r3  3  6 100 100 complete_rows_cols(m1, m1) # Nothing added, because everything already present #>    c1 c2 #> r1  1  4 #> r2  2  5 #> r3  3  6 complete_rows_cols(m1, t(m1)) # Adds empty c1, c2 rows; Adds empty r1, r2, r3 columns #>    c1 c2 r1 r2 r3 #> r1  1  4  0  0  0 #> r2  2  5  0  0  0 #> r3  3  6  0  0  0 #> c1  0  0  0  0  0 #> c2  0  0  0  0  0 # Same as previous. With missing matrix, complete relative to transpose of m1. complete_rows_cols(m1)  #>    c1 c2 r1 r2 r3 #> r1  1  4  0  0  0 #> r2  2  5  0  0  0 #> r3  3  6  0  0  0 #> c1  0  0  0  0  0 #> c2  0  0  0  0  0 # Adds rows r10, r11; cols c10, c11 complete_rows_cols(m1, matrix(0, nrow = 2, ncol = 2,                                dimnames = list(c(\"r10\", \"r11\"), c(\"c10\", \"c11\"))))  #>     c1 c2 c10 c11 #> r1   1  4   0   0 #> r2   2  5   0   0 #> r3   3  6   0   0 #> r10  0  0   0   0 #> r11  0  0   0   0 # Also works with lists complete_rows_cols(a = list(m1,m1)) #> [[1]] #>    c1 c2 r1 r2 r3 #> r1  1  4  0  0  0 #> r2  2  5  0  0  0 #> r3  3  6  0  0  0 #> c1  0  0  0  0  0 #> c2  0  0  0  0  0 #>  #> [[2]] #>    c1 c2 r1 r2 r3 #> r1  1  4  0  0  0 #> r2  2  5  0  0  0 #> r3  3  6  0  0  0 #> c1  0  0  0  0  0 #> c2  0  0  0  0  0 #>  complete_rows_cols(a = list(m1,m1), mat = list(m2,m2)) #> [[1]] #>    c1 c2 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[2]] #>    c1 c2 c3 c4 #> r1  1  4  0  0 #> r2  2  5  0  0 #> r3  3  6  0  0 #>  # No changes because r2, r3 already present in m1 complete_rows_cols(a = list(m1,m1), mat = list(m2,m2), margin = 1)  #> [[1]] #>    c1 c2 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[2]] #>    c1 c2 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  complete_rows_cols(a = list(m1,m1), mat = list(m2,m2), margin = 2) #> [[1]] #>    c1 c2 c3 c4 #> r1  1  4  0  0 #> r2  2  5  0  0 #> r3  3  6  0  0 #>  #> [[2]] #>    c1 c2 c3 c4 #> r1  1  4  0  0 #> r2  2  5  0  0 #> r3  3  6  0  0 #>  complete_rows_cols(a = list(m1,m1),                     mat = RCLabels::make_list(matrix(0,                                                     nrow = 2,                                                      ncol = 2,                                                      dimnames = list(c(\"r10\", \"r11\"),                                                                      c(\"c10\", \"c11\"))),                                               n = 2, lenx = 1)) #> [[1]] #>     c1 c2 #> r1   1  4 #> r2   2  5 #> r3   3  6 #> r10  0  0 #> r11  0  0 #>  #> [[2]] #>    c1 c2 c10 c11 #> r1  1  4   0   0 #> r2  2  5   0   0 #> r3  3  6   0   0 #>  # fillrow or fillcol can be specified a <- matrix(c(11, 12, 21, 22), byrow = TRUE, nrow = 2, ncol = 2,              dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\"))) b <- matrix(c(1:6), byrow = TRUE, nrow = 3, ncol = 2,              dimnames = list(c(\"r1\", \"r2\", \"r3\"), c(\"c1\", \"c2\"))) fillrow <- matrix(c(31, 32), byrow = TRUE, nrow = 1, ncol = 2,                    dimnames = list(\"r42\", c(\"c1\", \"c2\"))) complete_rows_cols(a = a, mat = b, fillrow = fillrow) #>    c1 c2 #> r1 11 12 #> r2 21 22 #> r3 31 32"},{"path":"/reference/count_vals_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Count the number of matrix entries that meet a criterion — count_vals_byname","title":"Count the number of matrix entries that meet a criterion — count_vals_byname","text":"Expressions can written natural way count_vals_byname(m, \"<=\", 1).","code":""},{"path":"/reference/count_vals_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count the number of matrix entries that meet a criterion — count_vals_byname","text":"","code":"count_vals_byname(   a,   compare_fun = c(\"==\", \"!=\", \"<\", \"<=\", \">=\", \">\"),   val = 0 )"},{"path":"/reference/count_vals_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count the number of matrix entries that meet a criterion — count_vals_byname","text":"matrix list matrices whose values counted according compare_fun. compare_fun comparison function, one \"==\", \"!=\", \"<\", \"<=\", \">\", \">=\". Default \"==\". val value matrix entries compared. Default 0.","code":""},{"path":"/reference/count_vals_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count the number of matrix entries that meet a criterion — count_vals_byname","text":"integer indicating number entries meet specified criterion","code":""},{"path":"/reference/count_vals_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count the number of matrix entries that meet a criterion — count_vals_byname","text":"Either single matrix list matrices can given argument. compare_fun can specified string (\"!=\") back-quoted function (`!=`).","code":""},{"path":"/reference/count_vals_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count the number of matrix entries that meet a criterion — count_vals_byname","text":"","code":"m <- matrix(c(0, 1, 2, 3, 4, 0), nrow = 3, ncol = 2) count_vals_byname(m) # uses defaults: compare_fun = \"==\" and val = 0 #> [1] 2 count_vals_byname(m, compare_fun = \"!=\") #> [1] 4 count_vals_byname(m, compare_fun = `!=`) #> [1] 4 # Write expressions in a natural way count_vals_byname(m, \"<=\", 1) #> [1] 3 # Also works for lists count_vals_byname(list(m,m), \"<=\", 1) #> [[1]] #> [1] 3 #>  #> [[2]] #> [1] 3 #>"},{"path":"/reference/count_vals_incols_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Count the number of matrix entries in columns that meet a criterion — count_vals_incols_byname","title":"Count the number of matrix entries in columns that meet a criterion — count_vals_incols_byname","text":"Expressions can written natural way count_vals_incols_byname(m, \"<=\", 1).","code":""},{"path":"/reference/count_vals_incols_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count the number of matrix entries in columns that meet a criterion — count_vals_incols_byname","text":"","code":"count_vals_incols_byname(   a,   compare_fun = c(\"==\", \"!=\", \"<\", \"<=\", \">=\", \">\"),   val = 0 )"},{"path":"/reference/count_vals_incols_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count the number of matrix entries in columns that meet a criterion — count_vals_incols_byname","text":"matrix list matrices whose values counted columns according compare_fun compare_fun comparison function, one \"==\", \"!=\", \"<\", \"<=\", \">\", \">=\". Default \"==\" val value matrix entries compared. Default 0.","code":""},{"path":"/reference/count_vals_incols_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count the number of matrix entries in columns that meet a criterion — count_vals_incols_byname","text":"matrix single row indicating number entries meet specified criterion column ","code":""},{"path":"/reference/count_vals_incols_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count the number of matrix entries in columns that meet a criterion — count_vals_incols_byname","text":"Either single matrix list matrices can given argument. compare_fun can specified string (\"!=\") back-quoted function (`!=`).","code":""},{"path":"/reference/count_vals_incols_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count the number of matrix entries in columns that meet a criterion — count_vals_incols_byname","text":"","code":"m <- matrix(c(0, 1, 2, 3, 4, 0), nrow = 3, ncol = 2) count_vals_incols_byname(m) # uses defaults: compare_fun = \"==\" and val = 0 #>      [,1] [,2] #> [1,]    1    1 count_vals_incols_byname(m, compare_fun = \"!=\") #>      [,1] [,2] #> [1,]    2    2 count_vals_incols_byname(m, compare_fun = `!=`) #>      [,1] [,2] #> [1,]    2    2 # Write expressions in a natural way count_vals_incols_byname(m, \"<=\", 1) #>      [,1] [,2] #> [1,]    2    1 # Also works for lists count_vals_incols_byname(list(m,m), \"<=\", 1) #> [[1]] #>      [,1] [,2] #> [1,]    2    1 #>  #> [[2]] #>      [,1] [,2] #> [1,]    2    1 #>"},{"path":"/reference/count_vals_inrows_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Count the number of matrix entries in rows that meet a criterion — count_vals_inrows_byname","title":"Count the number of matrix entries in rows that meet a criterion — count_vals_inrows_byname","text":"Expressions can written natural way count_vals_inrows_byname(m, \"<=\", 1).","code":""},{"path":"/reference/count_vals_inrows_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count the number of matrix entries in rows that meet a criterion — count_vals_inrows_byname","text":"","code":"count_vals_inrows_byname(   a,   compare_fun = c(\"==\", \"!=\", \"<\", \"<=\", \">=\", \">\"),   val = 0 )"},{"path":"/reference/count_vals_inrows_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count the number of matrix entries in rows that meet a criterion — count_vals_inrows_byname","text":"matrix list matrices whose values counted rows according compare_fun compare_fun comparison function, one \"==\", \"!=\", \"<\", \"<=\", \">\", \">=\". Default \"==\". val value matrix entries compared. Default 0.","code":""},{"path":"/reference/count_vals_inrows_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count the number of matrix entries in rows that meet a criterion — count_vals_inrows_byname","text":"matrix single column indicating number entries meet specified criterion row ","code":""},{"path":"/reference/count_vals_inrows_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count the number of matrix entries in rows that meet a criterion — count_vals_inrows_byname","text":"Either single matrix list matrices can given argument. compare_fun can specified string (\"!=\") back-quoted function (`!=`).","code":""},{"path":"/reference/count_vals_inrows_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count the number of matrix entries in rows that meet a criterion — count_vals_inrows_byname","text":"","code":"m <- matrix(c(0, 1, 2, 3, 4, 0), nrow = 3, ncol = 2) count_vals_inrows_byname(m) # uses defaults: compare_fun = \"==\" and val = 0 #>      [,1] #> [1,]    1 #> [2,]    0 #> [3,]    1 count_vals_inrows_byname(m, compare_fun = \"!=\") #>      [,1] #> [1,]    1 #> [2,]    2 #> [3,]    1 count_vals_inrows_byname(m, compare_fun = `!=`) #>      [,1] #> [1,]    1 #> [2,]    2 #> [3,]    1 # Write expressions in a natural way count_vals_inrows_byname(m, \"<=\", 1) #>      [,1] #> [1,]    1 #> [2,]    1 #> [3,]    1 # Also works for lists count_vals_inrows_byname(list(m,m), \"<=\", 1) #> [[1]] #>      [,1] #> [1,]    1 #> [2,]    1 #> [3,]    1 #>  #> [[2]] #>      [,1] #> [1,]    1 #> [2,]    1 #> [3,]    1 #>"},{"path":"/reference/create_colvec_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Create column vectors from data — create_colvec_byname","title":"Create column vectors from data — create_colvec_byname","text":"function takes data .dat creates column vectors.","code":""},{"path":"/reference/create_colvec_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create column vectors from data — create_colvec_byname","text":"","code":"create_colvec_byname(   .dat,   dimnames = NA,   colname = NA,   matrix.class = c(\"matrix\", \"Matrix\") )"},{"path":"/reference/create_colvec_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create column vectors from data — create_colvec_byname","text":".dat Data converted column vectors. dimnames dimension names used creating column vector, list format, data frame column containing list dimension names used observation. colname name column colvector. matrix.class One \"matrix\" \"Matrix\". \"matrix\" creates base::matrix object matrix() function. \"Matrix\" creates Matrix::Matrix object using matsbyname::Matrix() function. Default \"matrix\".","code":""},{"path":"/reference/create_colvec_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create column vectors from data — create_colvec_byname","text":"column vector, list column vectors, data frame column column vectors, depending value .dat class.","code":""},{"path":"/reference/create_colvec_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create column vectors from data — create_colvec_byname","text":"row column names resulting column vector taken names .dat colname. set, dimnames overrides names .dat colname. function \"byname\" function can accept single number, vector, list, data frame .dat. Row types column types taken row type column type attributes .dat.","code":""},{"path":"/reference/create_colvec_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create column vectors from data — create_colvec_byname","text":"","code":"# Works with single numbers create_colvec_byname(c(r1 = 1) %>% setrowtype(\"rt\") %>% setcoltype(\"ct\"),                       colname = \"r1\") #>    r1 #> r1  1 #> attr(,\"rowtype\") #> [1] \"rt\" #> attr(,\"coltype\") #> [1] \"ct\" # Works with vectors create_colvec_byname(c(r1 = 1, r2 = 2), colname = \"c1\") #>    c1 #> r1  1 #> r2  2 # Works with a list create_colvec_byname(list(c(r1 = 1, r2 = 2), c(R1 = 3, R2 = 4, R3 = 5)),                       colname = list(\"c1\", \"C1\")) #> [[1]] #>    c1 #> r1  1 #> r2  2 #>  #> [[2]] #>    C1 #> R1  3 #> R2  4 #> R3  5 #>  # Works in a tibble, too. # (Must be a tibble, not a data frame, so that names are preserved.) dat <- list(c(r1 = 1, r2 = 2),             c(R1 = 2, R2 = 3),              c(r1 = 1, r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6)) cnms <- list(\"c1\", \"C1\", \"c1\") df1 <- tibble::tibble(dat, cnms) df1 #> # A tibble: 3 × 2 #>   dat       cnms      #>   <list>    <list>    #> 1 <dbl [2]> <chr [1]> #> 2 <dbl [2]> <chr [1]> #> 3 <dbl [6]> <chr [1]> df1 <- df1 %>%   dplyr::mutate(     colvec_col = create_colvec_byname(dat, colname = cnms)   ) df1$colvec_col[[1]] #>    c1 #> r1  1 #> r2  2 df1$colvec_col[[2]] #>    C1 #> R1  2 #> R2  3 df1$colvec_col[[3]] #>    c1 #> r1  1 #> r2  2 #> r3  3 #> r4  4 #> r5  5 #> r6  6"},{"path":"/reference/create_matrix_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a ","title":"Create a ","text":"function creates \"byname\" matrix, list matrices, .dat, depending input arguments. function similar matrix(), \"byname\" characteristics.","code":""},{"path":"/reference/create_matrix_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a ","text":"","code":"create_matrix_byname(   .dat,   nrow,   ncol,   byrow = FALSE,   dimnames,   matrix.class = c(\"matrix\", \"Matrix\") )"},{"path":"/reference/create_matrix_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a ","text":".dat data used create matrix, list format, data frame column containing list data used observation. nrow number rows used create matrix, list format, data frame column containing list number rows used observation. ncol number columns used create matrix, list format, data frame column containing list number columns used observation. byrow argument stating whether matrix filled rows columns (FALSE column, TRUE row), list format, data frame column containing list byrow argument observation. Default FALSE. dimnames dimension names used creating matrices, list format, data frame column containing list dimension names used observation. matrix.class One \"matrix\" \"Matrix\". \"matrix\" creates base::matrix object matrix() function. \"Matrix\" creates Matrix::Matrix object using matsbyname::Matrix() function. Default \"matrix\".","code":""},{"path":"/reference/create_matrix_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a ","text":"matrix, list matrices, column data frame, depending input arguments.","code":""},{"path":"/reference/create_matrix_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a ","text":"Row column names taken dimnames argument. row column type information .dat preserved output. created object(s) can type base::matrix Matrix::Matrix, latter enables sparse objects save memory disk.","code":""},{"path":"/reference/create_matrix_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a ","text":"","code":"create_matrix_byname(c(1, 2), nrow = 2, ncol = 1,                      dimnames = list(c(\"r1\", \"r2\"), \"c1\")) #>    c1 #> r1  1 #> r2  2 create_matrix_byname(list(1, 2), nrow = list(1, 1), ncol = list(1,1),                       dimnames = list(list(\"r1\", \"c1\"), list(\"R1\", \"C1\"))) #> [[1]] #>    c1 #> r1  1 #>  #> [[2]] #>    C1 #> R1  2 #>"},{"path":"/reference/create_rowvec_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Create row vectors from data — create_rowvec_byname","title":"Create row vectors from data — create_rowvec_byname","text":"function takes data .dat creates row vectors.","code":""},{"path":"/reference/create_rowvec_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create row vectors from data — create_rowvec_byname","text":"","code":"create_rowvec_byname(   .dat,   dimnames = NA,   rowname = NA,   matrix.class = c(\"matrix\", \"Matrix\") )"},{"path":"/reference/create_rowvec_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create row vectors from data — create_rowvec_byname","text":".dat Data converted row vectors. dimnames dimension names used creating row vector, list format, data frame column containing list dimension names used observation. rowname name row row vector. matrix.class One \"matrix\" \"Matrix\". \"matrix\" creates base::matrix object matrix() function. \"Matrix\" creates Matrix::Matrix object using matsbyname::Matrix() function. Default \"matrix\".","code":""},{"path":"/reference/create_rowvec_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create row vectors from data — create_rowvec_byname","text":"row vector, list row vectors, data frame column row vectors, depending values .dat class.","code":""},{"path":"/reference/create_rowvec_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create row vectors from data — create_rowvec_byname","text":"row column names resulting row vector taken rowname names .dat. set, dimnames overrides rowname names .dat. Row types column types taken row type column type attributes .dat. function \"byname\" function can accept single number, vector, list, data frame .dat.","code":""},{"path":"/reference/create_rowvec_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create row vectors from data — create_rowvec_byname","text":"","code":"# Works with single numbers create_rowvec_byname(c(c1 = 1) %>% setrowtype(\"rt\") %>% setcoltype(\"ct\"), rowname = \"r1\") #>    c1 #> r1  1 #> attr(,\"rowtype\") #> [1] \"rt\" #> attr(,\"coltype\") #> [1] \"ct\" # Works with vectors create_rowvec_byname(c(c1 = 1, c2 = 2), rowname = \"r1\") #>    c1 c2 #> r1  1  2 # Works with a list create_rowvec_byname(list(c(c1 = 1, c2 = 2), c(C1 = 3, C2 = 4, C3 = 5)),                       rowname = list(\"r1\", \"R1\")) #> [[1]] #>    c1 c2 #> r1  1  2 #>  #> [[2]] #>    C1 C2 C3 #> R1  3  4  5 #>  # Works in a tibble, too. # (Must be a tibble, not a data frame, so that names are preserved.) dat <- list(c(c1 = 1),             c(C1 = 2, C2 = 3),              c(c1 = 1, c2 = 2, c3 = 3, c4 = 4, c5 = 5, c6 = 6)) rnms <- list(\"r1\", \"R1\", \"r1\") df1 <- tibble::tibble(dat, rnms) df1 #> # A tibble: 3 × 2 #>   dat       rnms      #>   <list>    <list>    #> 1 <dbl [1]> <chr [1]> #> 2 <dbl [2]> <chr [1]> #> 3 <dbl [6]> <chr [1]> df1 <- df1 %>%   dplyr::mutate(     rowvec_col = create_rowvec_byname(dat, rowname = rnms)   ) df1$rowvec_col[[1]] #>    c1 #> r1  1 df1$rowvec_col[[2]] #>    C1 C2 #> R1  2  3 df1$rowvec_col[[3]] #>    c1 c2 c3 c4 c5 c6 #> r1  1  2  3  4  5  6"},{"path":"/reference/cumapply_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function cumulatively to a list of matrices or numbers — cumapply_byname","title":"Apply a function cumulatively to a list of matrices or numbers — cumapply_byname","text":"FUN must binary function also accepts single argument. result list first element FUN([[1]]). >= 2, elements FUN([[]], [[-1]]), result list.","code":""},{"path":"/reference/cumapply_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function cumulatively to a list of matrices or numbers — cumapply_byname","text":"","code":"cumapply_byname(FUN, a)"},{"path":"/reference/cumapply_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function cumulatively to a list of matrices or numbers — cumapply_byname","text":"FUN function applied list matrices numbers FUN applied cumulatively","code":""},{"path":"/reference/cumapply_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function cumulatively to a list of matrices or numbers — cumapply_byname","text":"list length containing cumulative application FUN ","code":""},{"path":"/reference/cumapply_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a function cumulatively to a list of matrices or numbers — cumapply_byname","text":"naryapply_byname() cumapply_byname() similar. differences can described considering data frame. naryapply_byname() applies FUN several columns (variables) data frame. example, sum_byname() applied several variables gives another column containing sums across row data frame. cumapply_byname() applies FUN successive entries single column. example sum_byname() applied single column gives sum numbers column.","code":""},{"path":"/reference/cumapply_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function cumulatively to a list of matrices or numbers — cumapply_byname","text":"","code":"cumapply_byname(sum, list(1, 2, 3, 4)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 6 #>  #> [[4]] #> [1] 10 #>  cumapply_byname(sum_byname, list(1, 2, 3, 4)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 6 #>  #> [[4]] #> [1] 10 #>  cumapply_byname(prod, list(1, 2, 3, 4)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 6 #>  #> [[4]] #> [1] 24 #>  cumapply_byname(hadamardproduct_byname, list(1, 2, 3, 4)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 6 #>  #> [[4]] #> [1] 24 #>"},{"path":"/reference/cumprod_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative element-product that respects row and column names — cumprod_byname","title":"Cumulative element-product that respects row and column names — cumprod_byname","text":"Provides cumulative element-products along list column data frame. single number, returned. list numbers, list representing cumulative product numbers returned. single matrix, returned. list matrices, list representing cumulative product matrices returned. case, entry returned list product \"name,\" row column names matrices respected.","code":""},{"path":"/reference/cumprod_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative element-product that respects row and column names — cumprod_byname","text":"","code":"cumprod_byname(a)"},{"path":"/reference/cumprod_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative element-product that respects row and column names — cumprod_byname","text":"number, list numbers, matrix list matrices cumulative element product desired.","code":""},{"path":"/reference/cumprod_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative element-product that respects row and column names — cumprod_byname","text":"single number, list numbers, single matrix, list matrices, depending nature .","code":""},{"path":"/reference/cumprod_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative element-product that respects row and column names — cumprod_byname","text":"function respects groups variable data frame.","code":""},{"path":"/reference/cumprod_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative element-product that respects row and column names — cumprod_byname","text":"","code":"cumprod_byname(list(1, 2, 3, 4, 5)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 6 #>  #> [[4]] #> [1] 24 #>  #> [[5]] #> [1] 120 #>  m1 <- matrix(c(1), nrow = 1, ncol = 1, dimnames = list(\"r1\", \"c1\")) %>%   setrowtype(\"row\") %>% setcoltype(\"col\") m2 <- matrix(c(2), nrow = 1, ncol = 1, dimnames = list(\"r2\", \"c2\")) %>%   setrowtype(\"row\") %>% setcoltype(\"col\") m3 <- matrix(c(3), nrow = 1, ncol = 1, dimnames = list(\"r3\", \"c3\")) %>%   setrowtype(\"row\") %>% setcoltype(\"col\") cumprod_byname(list(m1, m2, m3)) #> [[1]] #>    c1 #> r1  1 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  #> [[2]] #>    c1 c2 #> r1  0  0 #> r2  0  0 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  #> [[3]] #>    c1 c2 c3 #> r1  0  0  0 #> r2  0  0  0 #> r3  0  0  0 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>"},{"path":"/reference/cumsum_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative sum that respects row and column names — cumsum_byname","title":"Cumulative sum that respects row and column names — cumsum_byname","text":"Provides cumulative sums along list column data frame. single number, returned. list numbers, list representing cumulative sum numbers returned. single matrix, returned. list matrices, list representing cumulative sum matrices returned. case, entry returned list sum \"name,\" row column names matrices respected.","code":""},{"path":"/reference/cumsum_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative sum that respects row and column names — cumsum_byname","text":"","code":"cumsum_byname(a)"},{"path":"/reference/cumsum_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative sum that respects row and column names — cumsum_byname","text":"number, list numbers, matrix list matrices cumulative sum desired.","code":""},{"path":"/reference/cumsum_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative sum that respects row and column names — cumsum_byname","text":"single number, list numbers, single matrix, list matrices, depending nature .","code":""},{"path":"/reference/cumsum_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative sum that respects row and column names — cumsum_byname","text":"cumulative sums desired context data frame, groups data frame respected mutate used. See examples.","code":""},{"path":"/reference/cumsum_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative sum that respects row and column names — cumsum_byname","text":"","code":"library(dplyr) library(tibble) m1 <- matrix(c(1), nrow = 1, ncol = 1, dimnames = list(\"r1\", \"c1\")) %>%    setrowtype(\"row\") %>% setcoltype(\"col\") m2 <- matrix(c(2), nrow = 1, ncol = 1, dimnames = list(\"r2\", \"c2\")) %>%    setrowtype(\"row\") %>% setcoltype(\"col\") m3 <- matrix(c(3), nrow = 1, ncol = 1, dimnames = list(\"r3\", \"c3\")) %>%    setrowtype(\"row\") %>% setcoltype(\"col\") cumsum_byname(list(m1, m2, m3)) #> [[1]] #>    c1 #> r1  1 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  #> [[2]] #>    c1 c2 #> r1  1  0 #> r2  0  2 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  #> [[3]] #>    c1 c2 c3 #> r1  1  0  0 #> r2  0  2  0 #> r3  0  0  3 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  # Groups are respected in the context of mutate. tibble(grp = c(\"A\", \"A\", \"B\"), m = list(m1, m2, m3)) %>% group_by(grp) %>%    mutate(m2 = cumsum_byname(m)) #> # A tibble: 3 × 3 #> # Groups:   grp [2] #>   grp   m             m2            #>   <chr> <list>        <list>        #> 1 A     <dbl [1 × 1]> <dbl [1 × 1]> #> 2 A     <dbl [1 × 1]> <dbl [2 × 2]> #> 3 B     <dbl [1 × 1]> <dbl [1 × 1]>"},{"path":"/reference/data.html","id":null,"dir":"Reference","previous_headings":"","what":"Data pronoun — .data","title":"Data pronoun — .data","text":"See rlang::.data details.","code":""},{"path":"/reference/data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data pronoun — .data","text":"","code":".data"},{"path":"/reference/difference_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Name-wise subtraction of matrices — difference_byname","title":"Name-wise subtraction of matrices — difference_byname","text":"Name-wise subtraction matrices","code":""},{"path":"/reference/difference_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name-wise subtraction of matrices — difference_byname","text":"","code":"difference_byname(minuend, subtrahend)"},{"path":"/reference/difference_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name-wise subtraction of matrices — difference_byname","text":"minuend matrix constant subtrahend matrix constant Performs union sorting row column names prior differencing. Zeroes inserted missing matrix elements.","code":""},{"path":"/reference/difference_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name-wise subtraction of matrices — difference_byname","text":"matrix representing name-wise difference minuend subtrahend","code":""},{"path":"/reference/difference_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name-wise subtraction of matrices — difference_byname","text":"","code":"library(dplyr) difference_byname(100, 50) #> [1] 50 commoditynames <- c(\"c1\", \"c2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") G <- matrix(rev(1:4), ncol = 2, dimnames = list(rev(commoditynames), rev(industrynames))) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") U - G # Non-sensical. Row and column names not respected. #>    i1 i2 #> c1 -3  1 #> c2 -1  3 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" difference_byname(U, G) # Row and column names respected! Should be all zeroes. #>    i1 i2 #> c1  0  0 #> c2  0  0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" difference_byname(100, U) #>    i1 i2 #> c1 99 97 #> c2 98 96 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" difference_byname(10, G) #>    i1 i2 #> c1  9  7 #> c2  8  6 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" difference_byname(G) # When subtrahend is missing, return minuend (in this case, G). #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" difference_byname(subtrahend = G) # When minuend is missing, return - subtrahend (in this case, -G) #>    i1 i2 #> c1 -1 -3 #> c2 -2 -4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" # This also works with lists difference_byname(list(100, 100), list(50, 50)) #> [[1]] #> [1] 50 #>  #> [[2]] #> [1] 50 #>  difference_byname(list(U,U), list(G,G)) #> [[1]] #>    i1 i2 #> c1  0  0 #> c2  0  0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  0  0 #> c2  0  0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- data.frame(U = I(list()), G = I(list())) DF[[1,\"U\"]] <- U DF[[2,\"U\"]] <- U DF[[1,\"G\"]] <- G DF[[2,\"G\"]] <- G difference_byname(DF$U, DF$G) #> [[1]] #>    i1 i2 #> c1  0  0 #> c2  0  0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  0  0 #> c2  0  0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF %>% mutate(diffs = difference_byname(U, G)) #>            U          G      diffs #> 1 1, 2, 3, 4 4, 3, 2, 1 0, 0, 0, 0 #> 2 1, 2, 3, 4 4, 3, 2, 1 0, 0, 0, 0"},{"path":"/reference/eigenvalues_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate eigenvalues of a matrix — eigenvalues_byname","title":"Calculate eigenvalues of a matrix — eigenvalues_byname","text":"Calculate eigenvalues matrix list matrices.","code":""},{"path":"/reference/eigenvalues_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate eigenvalues of a matrix — eigenvalues_byname","text":"","code":"eigenvalues_byname(a)"},{"path":"/reference/eigenvalues_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate eigenvalues of a matrix — eigenvalues_byname","text":"matrix list matrices.","code":""},{"path":"/reference/eigenvalues_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate eigenvalues of a matrix — eigenvalues_byname","text":"vector eigenvalues.","code":""},{"path":"/reference/eigenvalues_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate eigenvalues of a matrix — eigenvalues_byname","text":"function pairs eigenvectors_byname(); first value result eigenvalue eigenvector reported first column result eigenvectors_byname(). second value result eigenvalue eigenvector reported second column result eigenvectors_byname(). Etc. Internally, function uses base::eigen(.values = TRUE). complete_rows_cols() called prior calculating eigenvalues.","code":""},{"path":"/reference/eigenvalues_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate eigenvalues of a matrix — eigenvalues_byname","text":"","code":"m <- matrix(c( 4,  6, 10,                 3, 10, 13,                -2, -6, -8), byrow = TRUE, nrow = 3, ncol = 3,              dimnames = list(c(\"p1\", \"p2\", \"p3\"), c(\"p1\", \"p2\", \"p3\"))) m #>    p1 p2 p3 #> p1  4  6 10 #> p2  3 10 13 #> p3 -2 -6 -8 eigenvalues_byname(m) #> [1] 4.000000e+00 2.000000e+00 3.864957e-17 eigenvalues_byname(list(m, 2*m)) #> [[1]] #> [1] 4.000000e+00 2.000000e+00 3.864957e-17 #>  #> [[2]] #> [1] 8.000000e+00 4.000000e+00 7.729914e-17 #>  DF <- tibble::tibble(m_col = list(m, 2*m)) %>%    dplyr::mutate(     eigen_col = eigenvalues_byname(m_col)   ) DF$eigen_col[[1]] #> [1] 4.000000e+00 2.000000e+00 3.864957e-17 DF$eigen_col[[2]] #> [1] 8.000000e+00 4.000000e+00 7.729914e-17"},{"path":"/reference/eigenvectors_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate eigenvectors of a matrix — eigenvectors_byname","title":"Calculate eigenvectors of a matrix — eigenvectors_byname","text":"Calculate eigenvectors matrix list matrices.","code":""},{"path":"/reference/eigenvectors_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate eigenvectors of a matrix — eigenvectors_byname","text":"","code":"eigenvectors_byname(a)"},{"path":"/reference/eigenvectors_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate eigenvectors of a matrix — eigenvectors_byname","text":"matrix list matrices.","code":""},{"path":"/reference/eigenvectors_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate eigenvectors of a matrix — eigenvectors_byname","text":"matrix whose columns eigenvectors .","code":""},{"path":"/reference/eigenvectors_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate eigenvectors of a matrix — eigenvectors_byname","text":"function pairs eigenvalues_byname(); first column resulting matrix eigenvector first eigenvalue reported eigenvalues_byname(). second column resulting matrix eigenvector second eigenvalue reported eigenvalues_byname(). Etc. Internally, function uses base::eigen(). complete_rows_cols() called prior calculating eigenvectors.","code":""},{"path":"/reference/eigenvectors_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate eigenvectors of a matrix — eigenvectors_byname","text":"","code":"m <- matrix(c( 4,  6, 10,                 3, 10, 13,                -2, -6, -8), byrow = TRUE, nrow = 3, ncol = 3,              dimnames = list(c(\"p1\", \"p2\", \"p3\"), c(\"p1\", \"p2\", \"p3\"))) m #>    p1 p2 p3 #> p1  4  6 10 #> p2  3 10 13 #> p3 -2 -6 -8 eigenvectors_byname(m) #>            [,1]       [,2]       [,3] #> [1,]  0.4574957  0.4082483 -0.5773503 #> [2,]  0.7624929 -0.8164966 -0.5773503 #> [3,] -0.4574957  0.4082483  0.5773503 eigenvectors_byname(list(m, 2*m)) #> [[1]] #>            [,1]       [,2]       [,3] #> [1,]  0.4574957  0.4082483 -0.5773503 #> [2,]  0.7624929 -0.8164966 -0.5773503 #> [3,] -0.4574957  0.4082483  0.5773503 #>  #> [[2]] #>            [,1]       [,2]       [,3] #> [1,]  0.4574957  0.4082483 -0.5773503 #> [2,]  0.7624929 -0.8164966 -0.5773503 #> [3,] -0.4574957  0.4082483  0.5773503 #>  DF <- tibble::tibble(m_col = list(m, 2*m)) %>%    dplyr::mutate(     eigen_col = eigenvectors_byname(m_col)   ) DF$eigen_col[[1]] #>            [,1]       [,2]       [,3] #> [1,]  0.4574957  0.4082483 -0.5773503 #> [2,]  0.7624929 -0.8164966 -0.5773503 #> [3,] -0.4574957  0.4082483  0.5773503 DF$eigen_col[[2]] #>            [,1]       [,2]       [,3] #> [1,]  0.4574957  0.4082483 -0.5773503 #> [2,]  0.7624929 -0.8164966 -0.5773503 #> [3,] -0.4574957  0.4082483  0.5773503"},{"path":"/reference/elementapply_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to an element of a matrix specified by rows and columns — elementapply_byname","title":"Apply a function to an element of a matrix specified by rows and columns — elementapply_byname","text":"FUN applied element specified row col.","code":""},{"path":"/reference/elementapply_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to an element of a matrix specified by rows and columns — elementapply_byname","text":"","code":"elementapply_byname(FUN, a, row, col, .FUNdots = NULL)"},{"path":"/reference/elementapply_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to an element of a matrix specified by rows and columns — elementapply_byname","text":"FUN unary function applied specified rows columns argument FUN row row name element FUN applied col column name element FUN applied .FUNdots list additional arguments FUN. (Default NULL.)","code":""},{"path":"/reference/elementapply_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to an element of a matrix specified by rows and columns — elementapply_byname","text":", FUN applied element row col","code":""},{"path":"/reference/elementapply_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a function to an element of a matrix specified by rows and columns — elementapply_byname","text":"row col can row column names integer indices mix .","code":""},{"path":"/reference/elementapply_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to an element of a matrix specified by rows and columns — elementapply_byname","text":"","code":"divide <- function(x, divisor){   x/divisor } m <- matrix(c(1:4), nrow = 2, ncol = 2, dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\"))) %>%    setrowtype(\"row\") %>% setcoltype(\"col\") elementapply_byname(divide, a = m, row = 1, col = 1, .FUNdots = list(divisor = 2)) #>     c1 c2 #> r1 0.5  3 #> r2 2.0  4 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" elementapply_byname(divide, a = m, row = 1, col = 2, .FUNdots = list(divisor = 10)) #>    c1  c2 #> r1  1 0.3 #> r2  2 4.0 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" elementapply_byname(divide, a = m, row = \"r2\", col = \"c2\", .FUNdots = list(divisor = 100)) #>    c1   c2 #> r1  1 3.00 #> r2  2 0.04 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\""},{"path":"/reference/equal_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare two matrices ","title":"Compare two matrices ","text":"operands matrices, completed sorted relative one another prior comparison.","code":""},{"path":"/reference/equal_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare two matrices ","text":"","code":"equal_byname(..., .summarise = FALSE, tol = 0)"},{"path":"/reference/equal_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare two matrices ","text":"... Operands compared. .summarise Tells whether operation accomplished across lists (FALSE) lists (TRUE). tol double tells precisely equal values b must . Default 0.","code":""},{"path":"/reference/equal_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare two matrices ","text":"TRUE iff information equal, including row column types row column names entries matrices.","code":""},{"path":"/reference/equal_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare two matrices ","text":"Comparisons made equal_matrix_or_Matrix(, b, tolerance = abs(tol)) variations among numbers within tol still return TRUE. EXACT comparison needed, use identical_byname(), compares using identical(, b). tol single value applies items ....","code":""},{"path":"/reference/equal_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare two matrices ","text":"","code":"a <- matrix(1:4, nrow = 2) b <- matrix(1:4, nrow = 2) equal_byname(a, b) #> [1] TRUE equal_byname(a, b + 1e-100) #> [1] TRUE identical_byname(a, b + 1e-100) #> [1] FALSE a <- a %>% setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") equal_byname(a, b) # FALSE because a has row and column types, but b does not. #> [1] FALSE b <- b %>% setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") equal_byname(a, b) #> [1] TRUE dimnames(a) <- list(c(\"i1\", \"i2\"), c(\"c1\", \"c2\")) dimnames(b) <- list(c(\"c1\", \"c2\"), c(\"i1\", \"i2\")) equal_byname(a, b) # FALSE, because row and column names are not equal #> [1] FALSE dimnames(b) <- dimnames(a) equal_byname(a, b) #> [1] TRUE"},{"path":"/reference/exp_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential of matrix elements — exp_byname","title":"Exponential of matrix elements — exp_byname","text":"Gives exponential elements matrix list matrices","code":""},{"path":"/reference/exp_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential of matrix elements — exp_byname","text":"","code":"exp_byname(a)"},{"path":"/reference/exp_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential of matrix elements — exp_byname","text":"matrix list matrices","code":""},{"path":"/reference/exp_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential of matrix elements — exp_byname","text":"M element replaced exponential","code":""},{"path":"/reference/exp_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential of matrix elements — exp_byname","text":"","code":"exp_byname(1) #> [1] 2.718282 m <- matrix(c(log(10),log(1),               log(1),log(100)),                byrow = TRUE, nrow = 2, ncol = 2,               dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industry\") %>% setcoltype(\"Commodity\") m #>          c1      c2 #> i1 2.302585 0.00000 #> i2 0.000000 4.60517 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\" exp_byname(m) #>    c1  c2 #> i1 10   1 #> i2  1 100 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\""},{"path":"/reference/fractionize_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute fractions of matrix entries — fractionize_byname","title":"Compute fractions of matrix entries — fractionize_byname","text":"function divides entries specified sum, thereby \"fractionizing\" matrix.","code":""},{"path":"/reference/fractionize_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute fractions of matrix entries — fractionize_byname","text":"","code":"fractionize_byname(a, margin, inf_becomes = .Machine$double.xmax)"},{"path":"/reference/fractionize_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute fractions of matrix entries — fractionize_byname","text":"matrix fractionized. margin 1 (rows), entry divided row's sum. 2 (columns), entry divided column's sum. c(1,2) (rows columns), entry divided sum entries . inf_becomes value substitute Inf produced division. Default .Machine$double.xmax. Another reasonable value Inf. Set NULL disable substitution. inf_becomes passed hatinv_byname().","code":""},{"path":"/reference/fractionize_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute fractions of matrix entries — fractionize_byname","text":"fractionized matrix dimensions row column types .","code":""},{"path":"/reference/fractionize_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute fractions of matrix entries — fractionize_byname","text":"","code":"M <- matrix(c(1, 5,               4, 5),             nrow = 2, ncol = 2, byrow = TRUE,              dimnames = list(c(\"p1\", \"p2\"), c(\"i1\", \"i2\"))) %>%              setcoltype(\"Products\") %>% setrowtype(\"Industries\") fractionize_byname(M, margin = c(1,2)) #>            i1        i2 #> p1 0.06666667 0.3333333 #> p2 0.26666667 0.3333333 #> attr(,\"coltype\") #> [1] \"Products\" #> attr(,\"rowtype\") #> [1] \"Industries\" fractionize_byname(M, margin = 1) #>           i1        i2 #> p1 0.1666667 0.8333333 #> p2 0.4444444 0.5555556 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" fractionize_byname(M, margin = 2) #>     i1  i2 #> p1 0.2 0.5 #> p2 0.8 0.5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\""},{"path":"/reference/geometricmean_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Name- and element-wise geometric mean of two matrices. — geometricmean_byname","title":"Name- and element-wise geometric mean of two matrices. — geometricmean_byname","text":"Gives geometric mean corresponding entries b.","code":""},{"path":"/reference/geometricmean_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name- and element-wise geometric mean of two matrices. — geometricmean_byname","text":"","code":"geometricmean_byname(..., .summarise = FALSE)"},{"path":"/reference/geometricmean_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name- and element-wise geometric mean of two matrices. — geometricmean_byname","text":"... operands; constants, matrices, lists matrices .summarise Tells whether operation accomplished across lists (FALSE) lists (TRUE).","code":""},{"path":"/reference/geometricmean_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name- and element-wise geometric mean of two matrices. — geometricmean_byname","text":"name-wise geometric mean operands","code":""},{"path":"/reference/geometricmean_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Name- and element-wise geometric mean of two matrices. — geometricmean_byname","text":"function performs union sorting row column names prior performing geometric mean. Zeroes inserted missing matrix elements.","code":""},{"path":"/reference/geometricmean_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name- and element-wise geometric mean of two matrices. — geometricmean_byname","text":"","code":"library(dplyr) geometricmean_byname(10, 1000) #> [1] 100 geometricmean_byname(10, 1000, 100000) #> [1] 1000 commoditynames <- c(\"c1\", \"c2\") industrynames <- \"i1\" U <- matrix(c(10, 1000), ncol = 1, nrow = 2, dimnames = list(commoditynames, industrynames)) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") G <- matrix(c(1e3, 1e5), ncol = 1, nrow = 2,              dimnames = list(rev(commoditynames), rev(industrynames))) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") # Non-sensical. Row and column names not respected. sqrt(U*G) #>       i1 #> c1   100 #> c2 10000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" # Row and column names respected! geometricmean_byname(U, G) #>      i1 #> c1 1000 #> c2 1000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" geometricmean_byname(1000, U) #>      i1 #> c1  100 #> c2 1000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" geometricmean_byname(10, G) #>      i1 #> c1 1000 #> c2  100 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" # This also works with lists geometricmean_byname(list(10, 1000), list(1000, 10)) #> [[1]] #> [1] 100 #>  #> [[2]] #> [1] 100 #>  geometricmean_byname(list(U,U), list(G,G)) #> [[1]] #>      i1 #> c1 1000 #> c2 1000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>      i1 #> c1 1000 #> c2 1000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- data.frame(U = I(list()), G = I(list())) DF[[1,\"U\"]] <- U DF[[2,\"U\"]] <- U DF[[1,\"G\"]] <- G DF[[2,\"G\"]] <- G geometricmean_byname(DF$U, DF$G) #> [[1]] #>      i1 #> c1 1000 #> c2 1000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>      i1 #> c1 1000 #> c2 1000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF %>% mutate(geomeans = geometricmean_byname(U, G)) #>          U           G   geomeans #> 1 10, 1000 1000, 1e+05 1000, 1000 #> 2 10, 1000 1000, 1e+05 1000, 1000"},{"path":"/reference/getcolnames_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets column names — getcolnames_byname","title":"Gets column names — getcolnames_byname","text":"Gets column names way amenable use chaining operations functional programming way","code":""},{"path":"/reference/getcolnames_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets column names — getcolnames_byname","text":"","code":"getcolnames_byname(a)"},{"path":"/reference/getcolnames_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets column names — getcolnames_byname","text":"matrix data frame column names retrieved","code":""},{"path":"/reference/getcolnames_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets column names — getcolnames_byname","text":"Column names m.","code":""},{"path":"/reference/getcolnames_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gets column names — getcolnames_byname","text":"","code":"m <- matrix(c(1:6), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:3))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") getcolnames_byname(m) #> [1] \"c1\" \"c2\" \"c3\" # This also works for lists getcolnames_byname(list(m,m)) #> [[1]] #> [1] \"c1\" \"c2\" \"c3\" #>  #> [[2]] #> [1] \"c1\" \"c2\" \"c3\" #>  DF <- data.frame(m = I(list())) DF[[1,\"m\"]] <- m DF[[2,\"m\"]] <- m getcolnames_byname(DF$m) #> [[1]] #> [1] \"c1\" \"c2\" \"c3\" #>  #> [[2]] #> [1] \"c1\" \"c2\" \"c3\" #>"},{"path":"/reference/getrownames_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets row names — getrownames_byname","title":"Gets row names — getrownames_byname","text":"Gets row names way amenable use chaining operations functional programming way","code":""},{"path":"/reference/getrownames_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets row names — getrownames_byname","text":"","code":"getrownames_byname(a)"},{"path":"/reference/getrownames_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets row names — getrownames_byname","text":"matrix data frame row names retrieved","code":""},{"path":"/reference/getrownames_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets row names — getrownames_byname","text":"row names ","code":""},{"path":"/reference/getrownames_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gets row names — getrownames_byname","text":"","code":"m <- matrix(c(1:6), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:3))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") getrownames_byname(m) #> [1] \"i1\" \"i2\" # This also works for lists getrownames_byname(list(m,m)) #> [[1]] #> [1] \"i1\" \"i2\" #>  #> [[2]] #> [1] \"i1\" \"i2\" #>  DF <- data.frame(m = I(list())) DF[[1,\"m\"]] <- m DF[[2,\"m\"]] <- m getrownames_byname(DF$m) #> [[1]] #> [1] \"i1\" \"i2\" #>  #> [[2]] #> [1] \"i1\" \"i2\" #>"},{"path":"/reference/getzerorowcolnames_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Names of zero rows and columns — getzerorowcolnames_byname","title":"Names of zero rows and columns — getzerorowcolnames_byname","text":"matrix rows columns full zeroes, singular, inverted. function returns names rows columns full zeroes.","code":""},{"path":"/reference/getzerorowcolnames_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Names of zero rows and columns — getzerorowcolnames_byname","text":"","code":"getzerorowcolnames_byname(a, tol = 1e-06)"},{"path":"/reference/getzerorowcolnames_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Names of zero rows and columns — getzerorowcolnames_byname","text":"matrix list matrices. tol allowable deviation 0 element.","code":""},{"path":"/reference/getzerorowcolnames_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Names of zero rows and columns — getzerorowcolnames_byname","text":"vector names zero rows columns.","code":""},{"path":"/reference/getzerorowcolnames_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Names of zero rows and columns — getzerorowcolnames_byname","text":"","code":"m <- matrix(c(1, 0, 1,               1, 0, 0,                0, 0, 0),             dimnames = list(c(\"r1\", \"r2\", \"r3\"), c(\"c1\", \"c2\", \"c3\")),              nrow = 3, ncol = 3, byrow = TRUE) m #>    c1 c2 c3 #> r1  1  0  1 #> r2  1  0  0 #> r3  0  0  0 getzerorowcolnames_byname(m) #> [1] \"r3\" \"c2\""},{"path":"/reference/hadamardproduct_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Name-wise matrix Hadamard multiplication — hadamardproduct_byname","title":"Name-wise matrix Hadamard multiplication — hadamardproduct_byname","text":"Performs union sorting names rows columns multiplicand multiplier sequential multiplication step. Zeroes inserted missing matrix elements. ensures dimensions multiplicand multiplier conformable sequential multiplication.","code":""},{"path":"/reference/hadamardproduct_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name-wise matrix Hadamard multiplication — hadamardproduct_byname","text":"","code":"hadamardproduct_byname(..., .summarise = FALSE)"},{"path":"/reference/hadamardproduct_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name-wise matrix Hadamard multiplication — hadamardproduct_byname","text":"... Operands; constants, matrices, lists matrices. .summarise TRUE, operands multiplied lists. FALSE (default), items multiplied across lists.","code":""},{"path":"/reference/hadamardproduct_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name-wise matrix Hadamard multiplication — hadamardproduct_byname","text":"Name-wise element product operands.","code":""},{"path":"/reference/hadamardproduct_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Name-wise matrix Hadamard multiplication — hadamardproduct_byname","text":"Hadamard product also known entrywise product.","code":""},{"path":"/reference/hadamardproduct_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name-wise matrix Hadamard multiplication — hadamardproduct_byname","text":"","code":"library(dplyr) hadamardproduct_byname(2, 2) #> [1] 4 commoditynames <- c(\"c1\", \"c2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") G <- matrix(1:4, ncol = 2, dimnames = list(rev(commoditynames), rev(industrynames))) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") U * G # Not what is desired, because names aren't aligned #>    i1 i2 #> c1  1  9 #> c2  4 16 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" hadamardproduct_byname(U, G) #>    i1 i2 #> c1  4  6 #> c2  6  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" hadamardproduct_byname(U, G, G) #>    i1 i2 #> c1 16 12 #> c2 18  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" hadamardproduct_byname(U, 0) #>    i1 i2 #> c1  0  0 #> c2  0  0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" hadamardproduct_byname(0, G) #>    i1 i2 #> c1  0  0 #> c2  0  0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" # This also works with lists hadamardproduct_byname(list(U, U), list(G, G)) #> [[1]] #>    i1 i2 #> c1  4  6 #> c2  6  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  4  6 #> c2  6  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- data.frame(U = I(list()), G = I(list())) DF[[1,\"U\"]] <- U DF[[2,\"U\"]] <- U DF[[1,\"G\"]] <- G DF[[2,\"G\"]] <- G hadamardproduct_byname(DF$U, DF$G) #> [[1]] #>    i1 i2 #> c1  4  6 #> c2  6  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  4  6 #> c2  6  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF %>% mutate(entrywiseprods = hadamardproduct_byname(U, G)) #>            U          G entrywiseprods #> 1 1, 2, 3, 4 1, 2, 3, 4     4, 6, 6, 4 #> 2 1, 2, 3, 4 1, 2, 3, 4     4, 6, 6, 4 # Also works down lists with `.summarise = TRUE`. hadamardproduct_byname(list(U, G), .summarise = TRUE) #> [[1]] #>    i1 i2 #> c1  4  6 #> c2  6  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>"},{"path":"/reference/hatinv_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Hatize and invert a vector — hatinv_byname","title":"Hatize and invert a vector — hatinv_byname","text":"dividing rows columns matrix elements vector, vector elements placed diagonal new matrix, diagonal matrix inverted, result pre- post-multiplied matrix. function performs hatizing inverting vector v one step takes advantage computational efficiencies achieve desired result. computational shortcut apparent one observes matrix produced hatizing inverting vector diagonal matrix whose non-zero elements numerical inverses individual elements v. function first inverts element v places inverted elements diagonal diagonal matrix.","code":""},{"path":"/reference/hatinv_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hatize and invert a vector — hatinv_byname","text":"","code":"hatinv_byname(v, keep = NULL, inf_becomes = .Machine$double.xmax)"},{"path":"/reference/hatinv_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hatize and invert a vector — hatinv_byname","text":"v vector hatized inverted. keep See hatize_byname(). inf_becomes value substitute Inf produced inversion process. Default .Machine$double.xmax. Another reasonable value Inf. Set NULL disable substitution.","code":""},{"path":"/reference/hatinv_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hatize and invert a vector — hatinv_byname","text":"square diagonal matrix inverted elements v diagonal","code":""},{"path":"/reference/hatinv_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hatize and invert a vector — hatinv_byname","text":"Note function gives result invert_byname(hatize_byname(v)), except invert_byname(hatize_byname(v)) fails due singular matrix error elements v zero. function give inf_becomes diagonal result zero element v, arguably better answer. sign Inf preserved substitution. default value inf_becomes .Machine$double.xmax. Set inf_becomes NULL disable behavior. default behavior helpful cases result hatinv_byname() later multiplied 0 obtain 0. Multiplying Inf 0 gives NaN effectively end stream calculations.","code":""},{"path":"/reference/hatinv_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hatize and invert a vector — hatinv_byname","text":"","code":"v <- matrix(1:10, ncol = 1, dimnames = list(c(paste0(\"i\", 1:10)), c(\"c1\"))) %>%   setrowtype(\"Industries\") %>% setcoltype(NA) r <- matrix(1:5, nrow = 1, dimnames = list(c(\"r1\"), c(paste0(\"c\", 1:5)))) %>%   setrowtype(NA) %>% setcoltype(\"Commodities\") hatinv_byname(v, keep = \"rownames\") #>     i1 i10  i2        i3   i4  i5        i6        i7    i8        i9 #> i1   1 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i10  0 0.1 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i2   0 0.0 0.5 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i3   0 0.0 0.0 0.3333333 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i4   0 0.0 0.0 0.0000000 0.25 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i5   0 0.0 0.0 0.0000000 0.00 0.2 0.0000000 0.0000000 0.000 0.0000000 #> i6   0 0.0 0.0 0.0000000 0.00 0.0 0.1666667 0.0000000 0.000 0.0000000 #> i7   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.1428571 0.000 0.0000000 #> i8   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.125 0.0000000 #> i9   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.1111111 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" hatinv_byname(r, keep = \"colnames\") #>    c1  c2        c3   c4  c5 #> c1  1 0.0 0.0000000 0.00 0.0 #> c2  0 0.5 0.0000000 0.00 0.0 #> c3  0 0.0 0.3333333 0.00 0.0 #> c4  0 0.0 0.0000000 0.25 0.0 #> c5  0 0.0 0.0000000 0.00 0.2 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Commodities\" # This function also works with lists. hatinv_byname(list(v, v), keep = \"rownames\") #> [[1]] #>     i1 i10  i2        i3   i4  i5        i6        i7    i8        i9 #> i1   1 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i10  0 0.1 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i2   0 0.0 0.5 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i3   0 0.0 0.0 0.3333333 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i4   0 0.0 0.0 0.0000000 0.25 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i5   0 0.0 0.0 0.0000000 0.00 0.2 0.0000000 0.0000000 0.000 0.0000000 #> i6   0 0.0 0.0 0.0000000 0.00 0.0 0.1666667 0.0000000 0.000 0.0000000 #> i7   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.1428571 0.000 0.0000000 #> i8   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.125 0.0000000 #> i9   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.1111111 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>     i1 i10  i2        i3   i4  i5        i6        i7    i8        i9 #> i1   1 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i10  0 0.1 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i2   0 0.0 0.5 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i3   0 0.0 0.0 0.3333333 0.00 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i4   0 0.0 0.0 0.0000000 0.25 0.0 0.0000000 0.0000000 0.000 0.0000000 #> i5   0 0.0 0.0 0.0000000 0.00 0.2 0.0000000 0.0000000 0.000 0.0000000 #> i6   0 0.0 0.0 0.0000000 0.00 0.0 0.1666667 0.0000000 0.000 0.0000000 #> i7   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.1428571 0.000 0.0000000 #> i8   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.125 0.0000000 #> i9   0 0.0 0.0 0.0000000 0.00 0.0 0.0000000 0.0000000 0.000 0.1111111 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  # Watch out for 0 values v2 <- matrix(0:1, ncol = 1, dimnames = list(c(paste0(\"i\", 0:1)), c(\"p1\"))) %>%   setrowtype(\"Industries\") %>% setcoltype(NA) # Produces singular matrix error if (FALSE) v2 %>% hatize_byname() %>% invert_byname # Handles 0 values well hatinv_byname(v2, keep = \"rownames\") #>               i0 i1 #> i0 1.797693e+308  0 #> i1  0.000000e+00  1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" hatinv_byname(v2, inf_becomes = 42, keep = \"rownames\") #>    i0 i1 #> i0 42  0 #> i1  0  1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" hatinv_byname(v2, inf_becomes = NA, keep = \"rownames\") #>    i0 i1 #> i0 NA  0 #> i1  0  1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" # Deals with 1x1 matrices well, if the `keep` argument is set. m <- matrix(42, nrow = 1, ncol = 1, dimnames = list(\"r1\", \"c1\")) %>%    setrowtype(\"Product -> Industry\") %>%    setcoltype(\"Industry -> Product\") m %>%    hatinv_byname(keep = \"rownames\") #>            r1 #> r1 0.02380952 #> attr(,\"rowtype\") #> [1] \"Product -> Industry\" #> attr(,\"coltype\") #> [1] \"Product -> Industry\" m %>%    hatinv_byname(keep = \"colnames\") #>            c1 #> c1 0.02380952 #> attr(,\"rowtype\") #> [1] \"Industry -> Product\" #> attr(,\"coltype\") #> [1] \"Industry -> Product\""},{"path":"/reference/hatize_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a diagonal ","title":"Creates a diagonal ","text":"\"hat\" matrix (diagonal matrix) one non-zero elements along diagonal. \"hatize\" vector place elements diagonal otherwise-zero square matrix. v must matrix object least one two dimensions length 1 (.e., vector). names dimensions hatized matrix taken dimension v 1. Note row names column names sorted prior forming \"hat\" matrix.","code":""},{"path":"/reference/hatize_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a diagonal ","text":"","code":"hatize_byname(v, keep = NULL)"},{"path":"/reference/hatize_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a diagonal ","text":"v vector \"hat\" matrix created. keep One \"rownames\" \"colnames\" NULL. NULL, default, names kept dimension size 1.","code":""},{"path":"/reference/hatize_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a diagonal ","text":"square \"hat\" matrix size equal length v.","code":""},{"path":"/reference/hatize_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a diagonal ","text":"Hatizing 1x1 vector potentially undefined. argument keep determines whether keep \"rownames\" \"colnames\". default keep NULL, meanding function attempt figure dimension's names used hatized matrix output. vector v ever 1x1, best set value keep writing code calls hatize_byname(). caller specifies keep = \"colnames\" v column vector, error thrown. caller specifies keep = \"rownames\" v row vector, error thrown.","code":""},{"path":"/reference/hatize_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a diagonal ","text":"","code":"v <- matrix(1:10, ncol = 1, dimnames = list(c(paste0(\"i\", 1:10)), c(\"c1\"))) %>%   setrowtype(\"Industries\") %>% setcoltype(NA) v #>     c1 #> i1   1 #> i2   2 #> i3   3 #> i4   4 #> i5   5 #> i6   6 #> i7   7 #> i8   8 #> i9   9 #> i10 10 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] NA hatize_byname(v, keep = \"rownames\") #>     i1 i10 i2 i3 i4 i5 i6 i7 i8 i9 #> i1   1   0  0  0  0  0  0  0  0  0 #> i10  0  10  0  0  0  0  0  0  0  0 #> i2   0   0  2  0  0  0  0  0  0  0 #> i3   0   0  0  3  0  0  0  0  0  0 #> i4   0   0  0  0  4  0  0  0  0  0 #> i5   0   0  0  0  0  5  0  0  0  0 #> i6   0   0  0  0  0  0  6  0  0  0 #> i7   0   0  0  0  0  0  0  7  0  0 #> i8   0   0  0  0  0  0  0  0  8  0 #> i9   0   0  0  0  0  0  0  0  0  9 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" r <- matrix(1:5, nrow = 1, dimnames = list(c(\"r1\"), c(paste0(\"c\", 1:5)))) %>%   setrowtype(NA) %>% setcoltype(\"Commodities\") r #>    c1 c2 c3 c4 c5 #> r1  1  2  3  4  5 #> attr(,\"rowtype\") #> [1] NA #> attr(,\"coltype\") #> [1] \"Commodities\" hatize_byname(r, keep = \"colnames\") #>    c1 c2 c3 c4 c5 #> c1  1  0  0  0  0 #> c2  0  2  0  0  0 #> c3  0  0  3  0  0 #> c4  0  0  0  4  0 #> c5  0  0  0  0  5 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Commodities\" # This also works with lists. hatize_byname(list(v, v), keep = \"rownames\") #> [[1]] #>     i1 i10 i2 i3 i4 i5 i6 i7 i8 i9 #> i1   1   0  0  0  0  0  0  0  0  0 #> i10  0  10  0  0  0  0  0  0  0  0 #> i2   0   0  2  0  0  0  0  0  0  0 #> i3   0   0  0  3  0  0  0  0  0  0 #> i4   0   0  0  0  4  0  0  0  0  0 #> i5   0   0  0  0  0  5  0  0  0  0 #> i6   0   0  0  0  0  0  6  0  0  0 #> i7   0   0  0  0  0  0  0  7  0  0 #> i8   0   0  0  0  0  0  0  0  8  0 #> i9   0   0  0  0  0  0  0  0  0  9 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>     i1 i10 i2 i3 i4 i5 i6 i7 i8 i9 #> i1   1   0  0  0  0  0  0  0  0  0 #> i10  0  10  0  0  0  0  0  0  0  0 #> i2   0   0  2  0  0  0  0  0  0  0 #> i3   0   0  0  3  0  0  0  0  0  0 #> i4   0   0  0  0  4  0  0  0  0  0 #> i5   0   0  0  0  0  5  0  0  0  0 #> i6   0   0  0  0  0  0  6  0  0  0 #> i7   0   0  0  0  0  0  0  7  0  0 #> i8   0   0  0  0  0  0  0  0  8  0 #> i9   0   0  0  0  0  0  0  0  0  9 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  # A 1x1 column vector is a degenerate case.  # Row names and rowtype are transferred to the column. matrix(42, nrow = 1, ncol = 1, dimnames = list(\"r1\")) %>%    setrowtype(\"Product -> Industry\") %>%    hatize_byname(keep = \"rownames\") #>    r1 #> r1 42 #> attr(,\"rowtype\") #> [1] \"Product -> Industry\" #> attr(,\"coltype\") #> [1] \"Product -> Industry\" # A 1x1 row vector is a degenerate case.  # Column names and coltype are transferred to the row. matrix(42, nrow = 1, ncol = 1, dimnames = list(NULL, \"c1\")) %>%    setcoltype(\"Industry -> Product\") %>%    hatize_byname(keep = \"colnames\") #>    c1 #> c1 42 #> attr(,\"coltype\") #> [1] \"Industry -> Product\" #> attr(,\"rowtype\") #> [1] \"Industry -> Product\" # A 1x1 matrix with both row and column names generates a failure. if (FALSE) { matrix(42, nrow = 1, ncol = 1, dimnames = list(\"r1\", \"c1\")) %>%    setrowtype(\"Product -> Industry\") %>%    setcoltype(\"Industry -> Product\") %>%    hatize_byname() } # But you could specify which you want keep, row names or column names. m <- matrix(42, nrow = 1, ncol = 1, dimnames = list(\"r1\", \"c1\")) %>%    setrowtype(\"Product -> Industry\") %>%    setcoltype(\"Industry -> Product\") m #>    c1 #> r1 42 #> attr(,\"rowtype\") #> [1] \"Product -> Industry\" #> attr(,\"coltype\") #> [1] \"Industry -> Product\" m %>%    hatize_byname(keep = \"rownames\") #>    r1 #> r1 42 #> attr(,\"rowtype\") #> [1] \"Product -> Industry\" #> attr(,\"coltype\") #> [1] \"Product -> Industry\" m %>%    hatize_byname(keep = \"colnames\") #>    c1 #> c1 42 #> attr(,\"rowtype\") #> [1] \"Industry -> Product\" #> attr(,\"coltype\") #> [1] \"Industry -> Product\""},{"path":"/reference/identical_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare two matrices ","title":"Compare two matrices ","text":"operands matrices, completed sorted relative one another prior comparison.","code":""},{"path":"/reference/identical_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare two matrices ","text":"","code":"identical_byname(..., .summarise = FALSE)"},{"path":"/reference/identical_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare two matrices ","text":"... Operands compared. .summarise Tells whether operation accomplished across lists (FALSE) lists (TRUE).","code":""},{"path":"/reference/identical_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare two matrices ","text":"TRUE iff information identical, including row column types row column names entries matrices.","code":""},{"path":"/reference/identical_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare two matrices ","text":"Comparisons made identical(, b) variations among numbers within computational precision return FALSE. fuzzy comparison needed, use equal_byname, compares using isTRUE(.equal(, b)).","code":""},{"path":"/reference/identical_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare two matrices ","text":"","code":"a <- matrix(1:4, nrow = 2) b <- matrix(1:4, nrow = 2) identical_byname(a, b) #> [1] TRUE identical_byname(a, b + 1e-100) #> [1] FALSE a <- a %>% setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") identical_byname(a, b) # FALSE because a has row and column types, but b does not. #> [1] FALSE b <- b %>% setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") identical_byname(a, b) #> [1] TRUE dimnames(a) <- list(c(\"i1\", \"i2\"), c(\"c1\", \"c2\")) dimnames(b) <- list(c(\"c1\", \"c2\"), c(\"i1\", \"i2\")) identical_byname(a, b) # FALSE, because row and column names are not equal #> [1] FALSE dimnames(b) <- dimnames(a) identical_byname(a, b) #> [1] TRUE"},{"path":"/reference/identize_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Named identity matrix or vector — identize_byname","title":"Named identity matrix or vector — identize_byname","text":"Creates identity matrix () vector () size names row column types .","code":""},{"path":"/reference/identize_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Named identity matrix or vector — identize_byname","text":"","code":"identize_byname(a, margin = c(1, 2))"},{"path":"/reference/identize_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Named identity matrix or vector — identize_byname","text":"matrix whose names dimensions preserved identity matrix vector margin determines whether identity vector matrix returned. See details.","code":""},{"path":"/reference/identize_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Named identity matrix or vector — identize_byname","text":"identity matrix vector.","code":""},{"path":"/reference/identize_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Named identity matrix or vector — identize_byname","text":"Behaviour different values margin follows: margin = 1, makes column matrix filled 1s. Row names type taken row names type . Column name type column type . margin = 2, make row matrix filled 1s. Column names type taken column name type . Row name type row type . list(c(1,2)) (default), make identity matrix 1s diagonal. Row column names sorted output.","code":""},{"path":"/reference/identize_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Named identity matrix or vector — identize_byname","text":"","code":"M <- matrix(1:16, ncol = 4, dimnames=list(c(paste0(\"i\", 1:4)), paste0(\"c\", 1:4))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") identize_byname(M) #>    c1 c2 c3 c4 #> i1  1  0  0  0 #> i2  0  1  0  0 #> i3  0  0  1  0 #> i4  0  0  0  1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" identize_byname(M, margin = c(1,2)) #>    c1 c2 c3 c4 #> i1  1  0  0  0 #> i2  0  1  0  0 #> i3  0  0  1  0 #> i4  0  0  0  1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" identize_byname(M, margin = 1) #>    Commodities #> i1           1 #> i2           1 #> i3           1 #> i4           1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" identize_byname(M, margin = 2) #>            c1 c2 c3 c4 #> Industries  1  1  1  1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" N <- matrix(c(-21, -12, -21, -10), ncol = 2, dimnames = list(c(\"b\", \"a\"), c(\"b\", \"a\"))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") identize_byname(N) #>   b a #> b 1 0 #> a 0 1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # This also works with lists identize_byname(list(M, M)) #> [[1]] #>    Commodities #> i1           1 #> i2           1 #> i3           1 #> i4           1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>            c1 c2 c3 c4 #> Industries  1  1  1  1 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>"},{"path":"/reference/invert_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Invert a matrix — invert_byname","title":"Invert a matrix — invert_byname","text":"function transposes row column names well row column types. Rows columns sorted prior inverting.","code":""},{"path":"/reference/invert_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invert a matrix — invert_byname","text":"","code":"invert_byname(a, method = c(\"solve\", \"QR\", \"SVD\"), tol = .Machine$double.eps)"},{"path":"/reference/invert_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Invert a matrix — invert_byname","text":"matrix inverted. must square. method One \"solve\", \"QR\", \"SVD\". Default \"solve\". See details. tol tolerance detecting linear dependencies columns . Default .Machine$double.eps.","code":""},{"path":"/reference/invert_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Invert a matrix — invert_byname","text":"inversion .","code":""},{"path":"/reference/invert_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Invert a matrix — invert_byname","text":"method argument specifies method used calculating inverse. \"solve\" uses base::solve() value tol. \"QR\" uses base::solve.qr() value tol. \"SVD\" uses matrixcalc::svd.inverse(), ignoring tol argument. tol method single values apply matrices . singular matrix, names zero rows columns reported error message.","code":""},{"path":"/reference/invert_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Invert a matrix — invert_byname","text":"","code":"m <- matrix(c(10,0,0,100), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industry\") %>% setcoltype(\"Commodity\") m #>    c1  c2 #> i1 10   0 #> i2  0 100 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\" invert_byname(m) #>     i1   i2 #> c1 0.1 0.00 #> c2 0.0 0.01 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Industry\" matrixproduct_byname(m, invert_byname(m)) #>    i1 i2 #> i1  1  0 #> i2  0  1 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Industry\" matrixproduct_byname(invert_byname(m), m) #>    c1 c2 #> c1  1  0 #> c2  0  1 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Commodity\" invert_byname(list(m,m)) #> [[1]] #>     i1   i2 #> c1 0.1 0.00 #> c2 0.0 0.01 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Industry\" #>  #> [[2]] #>     i1   i2 #> c1 0.1 0.00 #> c2 0.0 0.01 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Industry\" #>  invert_byname(m, method = \"QR\") #>     i1   i2 #> c1 0.1 0.00 #> c2 0.0 0.01 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Industry\" invert_byname(m, method = \"SVD\") #>     i1   i2 #> c1 0.1 0.00 #> c2 0.0 0.01 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/reference/is.Matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object a Matrix? — is.Matrix","title":"Is an object a Matrix? — is.Matrix","text":"Arguably, function Matrix package, . include convenience.","code":""},{"path":"/reference/is.Matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object a Matrix? — is.Matrix","text":"","code":"is.Matrix(a)"},{"path":"/reference/is.Matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object a Matrix? — is.Matrix","text":"object queried Matrix.","code":""},{"path":"/reference/is.Matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is an object a Matrix? — is.Matrix","text":"boolean. TRUE Matrix, FALSE otherwise.","code":""},{"path":"/reference/is.Matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is an object a Matrix? — is.Matrix","text":"function vectorized. .Matrix() wrapper inherits(, \"Matrix).","code":""},{"path":"/reference/is.Matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is an object a Matrix? — is.Matrix","text":"","code":"is.Matrix(matrix(42)) #> [1] FALSE is.Matrix(Matrix::Matrix(42)) #> [1] TRUE"},{"path":"/reference/is_matrix_or_Matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Tells whether an object is one of a matrix or a Matrix — is_matrix_or_Matrix","title":"Tells whether an object is one of a matrix or a Matrix — is_matrix_or_Matrix","text":"Often, helps know whether object matrix Matrix, care . function helps situations.","code":""},{"path":"/reference/is_matrix_or_Matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tells whether an object is one of a matrix or a Matrix — is_matrix_or_Matrix","text":"","code":"is_matrix_or_Matrix(a)"},{"path":"/reference/is_matrix_or_Matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tells whether an object is one of a matrix or a Matrix — is_matrix_or_Matrix","text":"object want know matrix Matrix.","code":""},{"path":"/reference/is_matrix_or_Matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tells whether an object is one of a matrix or a Matrix — is_matrix_or_Matrix","text":"TRUE matrix Matrix. FALSE otherwise.","code":""},{"path":"/reference/is_matrix_or_Matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tells whether an object is one of a matrix or a Matrix — is_matrix_or_Matrix","text":"","code":"is_matrix_or_Matrix(42) #> [1] FALSE is_matrix_or_Matrix(matrix(42)) #> [1] TRUE is_matrix_or_Matrix(Matrix::Matrix(42)) #> [1] TRUE is_matrix_or_Matrix(matsbyname::Matrix(42)) #> [1] TRUE"},{"path":"/reference/iszero_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Test whether this is the zero matrix — iszero_byname","title":"Test whether this is the zero matrix — iszero_byname","text":"Note function tests whether elements abs() <= tol. default value tol 1e-6. , can set tol = 0 discover EXACTLY zero matrix.","code":""},{"path":"/reference/iszero_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test whether this is the zero matrix — iszero_byname","text":"","code":"iszero_byname(a, tol = 1e-06)"},{"path":"/reference/iszero_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test whether this is the zero matrix — iszero_byname","text":"matrix list matrices. tol allowable deviation 0 element. Interpreted absolute value.","code":""},{"path":"/reference/iszero_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test whether this is the zero matrix — iszero_byname","text":"TRUE Iff zero matrix within tol.","code":""},{"path":"/reference/iszero_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test whether this is the zero matrix — iszero_byname","text":"","code":"zero <- matrix(0, nrow = 50, ncol = 50) iszero_byname(zero) #> [1] TRUE nonzero <- matrix(1:4, nrow = 2) iszero_byname(nonzero) #> [1] FALSE # Also works for lists iszero_byname(list(zero, nonzero)) #> [[1]] #> [1] TRUE #>  #> [[2]] #> [1] FALSE #>  # And it works for data frames DF <- data.frame(A = I(list()), B = I(list())) DF[[1,\"A\"]] <- zero DF[[2,\"A\"]] <- nonzero DF[[1,\"B\"]] <- nonzero DF[[2,\"B\"]] <- zero iszero_byname(DF$A) #> [[1]] #> [1] TRUE #>  #> [[2]] #> [1] FALSE #>  iszero_byname(DF$B) #> [[1]] #> [1] FALSE #>  #> [[2]] #> [1] TRUE #>  iszero_byname(matrix(1e-10, nrow = 2)) #> [1] TRUE iszero_byname(matrix(1e-10, nrow = 2), tol = 1e-11) #> [1] FALSE"},{"path":"/reference/kvec_from_template_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a constant vector from matrix a — kvec_from_template_byname","title":"Create a constant vector from matrix a — kvec_from_template_byname","text":"function creates vector using template k value. Row names taken row names . column name output given colname. Row column types transferred output, directly.","code":""},{"path":"/reference/kvec_from_template_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a constant vector from matrix a — kvec_from_template_byname","text":"","code":"kvec_from_template_byname(a, k = 1, colname = NA, column = TRUE)"},{"path":"/reference/kvec_from_template_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a constant vector from matrix a — kvec_from_template_byname","text":"template matrix column vector. k value entries output column vector. colname name output vector's 1-sized dimension (column column TRUE, row otherwise). column Tells whether column vector (TRUE, default) row vector (FALSE) created.","code":""},{"path":"/reference/kvec_from_template_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a constant vector from matrix a — kvec_from_template_byname","text":"vector vector formed .","code":""},{"path":"/reference/kvec_from_template_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a constant vector from matrix a — kvec_from_template_byname","text":"column TRUE, output column vector row names taken row names column named colname. column FALSE, output row vevtor column names taken column names row named colname. class Matrix, output object Matrix. Otherwise, class output object matrix.","code":""},{"path":"/reference/kvec_from_template_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a constant vector from matrix a — kvec_from_template_byname","text":"","code":"kvec_from_template_byname(matrix(42, nrow = 4, ncol = 2,                                  dimnames = list(c(\"r1\", \"r2\", \"r3\", \"r4\"), c(\"c1\", \"c2\"))),                            colname = \"new column\") #>    new column #> r1          1 #> r2          1 #> r3          1 #> r4          1 kvec_from_template_byname(matrix(42, nrow = 4, ncol = 2,                                  dimnames = list(c(\"r1\", \"r2\", \"r3\", \"r4\"), c(\"c1\", \"c2\"))),                            colname = \"new row\", column = FALSE) #>         c1 c2 #> new row  1  1"},{"path":"/reference/list_of_rows_or_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Named list of rows or columns of matrices — list_of_rows_or_cols","title":"Named list of rows or columns of matrices — list_of_rows_or_cols","text":"function takes matrix m converts list single-row (margin == 1) single-column(margin == 2) matrices. item list named row (margin == 1) column (margin == 2).","code":""},{"path":"/reference/list_of_rows_or_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Named list of rows or columns of matrices — list_of_rows_or_cols","text":"","code":"list_of_rows_or_cols(a, margin)"},{"path":"/reference/list_of_rows_or_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Named list of rows or columns of matrices — list_of_rows_or_cols","text":"matrix list matrices (say, column data frame) margin margin matrices extracted (1 rows, 2 columns)","code":""},{"path":"/reference/list_of_rows_or_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Named list of rows or columns of matrices — list_of_rows_or_cols","text":"named list rows columns extracted m","code":""},{"path":"/reference/list_of_rows_or_cols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Named list of rows or columns of matrices — list_of_rows_or_cols","text":"Note result provides column vectors, regardless value margin.","code":""},{"path":"/reference/list_of_rows_or_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Named list of rows or columns of matrices — list_of_rows_or_cols","text":"","code":"m <- matrix(data = c(1:6),              nrow = 2, ncol = 3,              dimnames = list(c(\"p1\", \"p2\"), c(\"i1\", \"i2\", \"i3\"))) %>%   setrowtype(rowtype = \"Products\") %>% setcoltype(coltype = \"Industries\") list_of_rows_or_cols(m, margin = 1) #> $p1 #>    p1 #> i1  1 #> i2  3 #> i3  5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  #> $p2 #>    p2 #> i1  2 #> i2  4 #> i3  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  list_of_rows_or_cols(m, margin = 2) #> $i1 #>    i1 #> p1  1 #> p2  2 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> $i2 #>    i2 #> p1  3 #> p2  4 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> $i3 #>    i3 #> p1  5 #> p2  6 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>"},{"path":"/reference/log_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Logarithm of matrix elements — log_byname","title":"Logarithm of matrix elements — log_byname","text":"Specify base log base argument.","code":""},{"path":"/reference/log_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logarithm of matrix elements — log_byname","text":"","code":"log_byname(a, base = exp(1))"},{"path":"/reference/log_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logarithm of matrix elements — log_byname","text":"matrix list matrices. base base logarithm (default exp(1), giving natural logarithm).","code":""},{"path":"/reference/log_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logarithm of matrix elements — log_byname","text":"M element replaced base base logarithm","code":""},{"path":"/reference/log_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logarithm of matrix elements — log_byname","text":"","code":"log_byname(exp(1)) #> [1] 1 m <- matrix(c(10,1,1,100), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industry\") %>% setcoltype(\"Commodity\") m #>    c1  c2 #> i1 10   1 #> i2  1 100 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\" log_byname(m) #>          c1      c2 #> i1 2.302585 0.00000 #> i2 0.000000 4.60517 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\" log_byname(m, base = 10) #>    c1 c2 #> i1  1  0 #> i2  0  2 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\""},{"path":"/reference/logarithmicmean_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Name- and element-wise logarithmic mean of matrices — logarithmicmean_byname","title":"Name- and element-wise logarithmic mean of matrices — logarithmicmean_byname","text":"logarithmic mean corresponding entries b 0 = 0 b = 0, = b, (b - ) / (log(b) - log()) otherwise.","code":""},{"path":"/reference/logarithmicmean_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name- and element-wise logarithmic mean of matrices — logarithmicmean_byname","text":"","code":"logarithmicmean_byname(a, b, base = exp(1))"},{"path":"/reference/logarithmicmean_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name- and element-wise logarithmic mean of matrices — logarithmicmean_byname","text":"first operand (matrix constant value lists ). b second operand (matrix constant value lists ). base base logarithm used computing logarithmic mean. (Default base = exp(1).)","code":""},{"path":"/reference/logarithmicmean_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name- and element-wise logarithmic mean of matrices — logarithmicmean_byname","text":"matrix representing name-wise logarithmic mean b.","code":""},{"path":"/reference/logarithmicmean_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Name- and element-wise logarithmic mean of matrices — logarithmicmean_byname","text":"function performs union sorting row column names prior performing logarithmic mean. Zeroes inserted missing matrix elements. Internally, third condition implemented (b - ) / log(b/). Note (b - ) / log(b/) = (- b) / log(/b), logarithmic mean commutative; order arguments b change result.","code":""},{"path":"/reference/logarithmicmean_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name- and element-wise logarithmic mean of matrices — logarithmicmean_byname","text":"","code":"library(dplyr) m1 <- matrix(c(1:6), nrow = 3, ncol = 2) %>%    setrownames_byname(c(\"r1\", \"r2\", \"r3\")) %>% setcolnames_byname(c(\"c1\", \"c2\")) %>%    setrowtype(\"row\") %>% setcoltype(\"col\") m2 <- matrix(c(7:12), nrow = 3, ncol = 2) %>%    setrownames_byname(c(\"r2\", \"r3\", \"r4\")) %>% setcolnames_byname(c(\"c2\", \"c3\")) %>%    setrowtype(\"row\") %>% setcoltype(\"col\") logarithmicmean_byname(m1, m2) #>    c1       c2 c3 #> r1  0 0.000000  0 #> r2  0 5.944027  0 #> r3  0 6.952119  0 #> r4  0 0.000000  0 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" # This also works with lists logarithmicmean_byname(list(m1, m1), list(m2, m2)) #> [[1]] #>    c1       c2 c3 #> r1  0 0.000000  0 #> r2  0 5.944027  0 #> r3  0 6.952119  0 #> r4  0 0.000000  0 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  #> [[2]] #>    c1       c2 c3 #> r1  0 0.000000  0 #> r2  0 5.944027  0 #> r3  0 6.952119  0 #> r4  0 0.000000  0 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  DF <- data.frame(m1 = I(list()), m2 = I(list())) DF[[1,\"m1\"]] <- m1 DF[[2,\"m1\"]] <- m1 DF[[1,\"m2\"]] <- m2 DF[[2,\"m2\"]] <- m2 logarithmicmean_byname(DF$m1, DF$m2) #> [[1]] #>    c1       c2 c3 #> r1  0 0.000000  0 #> r2  0 5.944027  0 #> r3  0 6.952119  0 #> r4  0 0.000000  0 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  #> [[2]] #>    c1       c2 c3 #> r1  0 0.000000  0 #> r2  0 5.944027  0 #> r3  0 6.952119  0 #> r4  0 0.000000  0 #> attr(,\"rowtype\") #> [1] \"row\" #> attr(,\"coltype\") #> [1] \"col\" #>  DF %>% mutate(logmeans = logarithmicmean_byname(m1, m2)) #>             m1           m2 #> 1 1, 2, 3,.... 7, 8, 9,.... #> 2 1, 2, 3,.... 7, 8, 9,.... #>                                                                                                                 logmeans #> 1 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 5.944027, 6.952119, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000 #> 2 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 5.944027, 6.952119, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000"},{"path":"/reference/logmean.html","id":null,"dir":"Reference","previous_headings":"","what":"Logarithmic mean of two numbers — logmean","title":"Logarithmic mean of two numbers — logmean","text":"Calculates logarithmic mean two numbers.","code":""},{"path":"/reference/logmean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logarithmic mean of two numbers — logmean","text":"","code":"logmean(a, b, base = exp(1))"},{"path":"/reference/logmean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logarithmic mean of two numbers — logmean","text":"first operand (must non-negative) b second operand (must non-negative) base base logarithm used calculation. (Default exp(1).)","code":""},{"path":"/reference/logmean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logarithmic mean of two numbers — logmean","text":"0 = 0 b = 0; x1 == b; (- b) / log(/b, base = base) values b","code":""},{"path":"/reference/logmean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Logarithmic mean of two numbers — logmean","text":"internal helper function logarithmicmean_byname.","code":""},{"path":"/reference/logmean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logarithmic mean of two numbers — logmean","text":"","code":"matsbyname:::logmean(0, 0) # 0 #> [1] 0 matsbyname:::logmean(0, 1) # 0 #> [1] 0 matsbyname:::logmean(1, 0) # 0 #> [1] 0 matsbyname:::logmean(1, 1) # 1 #> [1] 1 matsbyname:::logmean(2, 1) #> [1] 1.442695 matsbyname:::logmean(1, 2) # commutative #> [1] 1.442695 matsbyname:::logmean(1, 10) # base = exp(1), the default #> [1] 3.90865 matsbyname:::logmean(1, 10, base = 10) #> [1] 9"},{"path":"/reference/make_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Makes a list of items in x, regardless of x's type — make_list","title":"Makes a list of items in x, regardless of x's type — make_list","text":"Repeats x necessary make n . try simplify x.","code":""},{"path":"/reference/make_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Makes a list of items in x, regardless of x's type — make_list","text":"","code":"make_list(x, n, lenx = ifelse(is.vector(x), length(x), 1))"},{"path":"/reference/make_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Makes a list of items in x, regardless of x's type — make_list","text":"x object duplicated n number times duplicated lenx length item x. Normally lenx taken length(x), x list, may wish list duplicated several times. case, set lenx = 1.","code":""},{"path":"/reference/make_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Makes a list of items in x, regardless of x's type — make_list","text":"list x duplicated n times","code":""},{"path":"/reference/make_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Makes a list of items in x, regardless of x's type — make_list","text":"","code":"m <- matrix(c(1:6), nrow=3, dimnames = list(c(\"r1\", \"r2\", \"r3\"), c(\"c2\", \"c1\"))) make_list(m, n = 1) #> [[1]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  make_list(m, n = 2) #> [[1]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[2]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  make_list(m, n = 5) #> [[1]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[2]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[3]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[4]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[5]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  make_list(list(c(1,2), c(1,2)), n = 4) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 #>  #> [[4]] #> [1] 1 2 #>  m <- matrix(1:4, nrow = 2) l <- list(m, m+100) make_list(l, n = 4) #> [[1]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  #> [[2]] #>      [,1] [,2] #> [1,]  101  103 #> [2,]  102  104 #>  #> [[3]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  #> [[4]] #>      [,1] [,2] #> [1,]  101  103 #> [2,]  102  104 #>  make_list(l, n = 1) # Warning because l is trimmed. #> Warning: n not evenly divisible by length(x) #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 make_list(l, n = 5) # Warning because length(l) (i.e., 2) not evenly divisible by 5 #> Warning: n not evenly divisible by length(x) #> [[1]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  #> [[2]] #>      [,1] [,2] #> [1,]  101  103 #> [2,]  102  104 #>  #> [[3]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  #> [[4]] #>      [,1] [,2] #> [1,]  101  103 #> [2,]  102  104 #>  #> [[5]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  make_list(list(c(\"r10\", \"r11\"), c(\"c10\", \"c11\")), n = 2) # Confused by x being a list #> [[1]] #> [1] \"r10\" \"r11\" #>  #> [[2]] #> [1] \"c10\" \"c11\" #>  make_list(list(c(\"r10\", \"r11\"), c(\"c10\", \"c11\")), n = 2, lenx = 1) # Fix by setting lenx = 1 #> [[1]] #> [[1]][[1]] #> [1] \"r10\" \"r11\" #>  #> [[1]][[2]] #> [1] \"c10\" \"c11\" #>  #>  #> [[2]] #> [[2]][[1]] #> [1] \"r10\" \"r11\" #>  #> [[2]][[2]] #> [1] \"c10\" \"c11\" #>  #>"},{"path":"/reference/margin_from_types_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate row and column types to integer margins — margin_from_types_byname","title":"Translate row and column types to integer margins — margin_from_types_byname","text":"Converts row column types integer margins, based types. types character vector, types returned unmodified. types character vector, integer vector returned corresponding margins types found. types found row column types , NA_integer_ returned.","code":""},{"path":"/reference/margin_from_types_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate row and column types to integer margins — margin_from_types_byname","text":"","code":"margin_from_types_byname(a, types)"},{"path":"/reference/margin_from_types_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate row and column types to integer margins — margin_from_types_byname","text":"matrix list matrices. types character vector list character vectors representing row column types whose corresponding integer margins determined.","code":""},{"path":"/reference/margin_from_types_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate row and column types to integer margins — margin_from_types_byname","text":"vector integers list vectors integers corresponding margins types exist.","code":""},{"path":"/reference/margin_from_types_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate row and column types to integer margins — margin_from_types_byname","text":"","code":"# Works for single matrices m <- matrix(1) %>%   setrowtype(\"Product\") %>% setcoltype(\"Industry\") margin_from_types_byname(m, \"Product\") #> [1] 1 margin_from_types_byname(m, \"Industry\") #> [1] 2 margin_from_types_byname(m, c(\"Product\", \"Industry\")) #> [1] 1 2 margin_from_types_byname(m, c(\"Industry\", \"Product\")) #> [1] 1 2 # Works for lists of matrices margin_from_types_byname(list(m, m), types = \"Product\") #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 #>  margin_from_types_byname(list(m, m), types = \"Industry\") #> [[1]] #> [1] 2 #>  #> [[2]] #> [1] 2 #>  margin_from_types_byname(list(m, m), types = c(\"Product\", \"Product\")) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 #>  margin_from_types_byname(list(m, m), types = c(\"Industry\", \"Industry\")) #> [[1]] #> [1] 2 #>  #> [[2]] #> [1] 2 #>  margin_from_types_byname(list(m, m), types = c(\"Product\", \"Industry\")) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  margin_from_types_byname(list(m, m), types = list(\"Product\", \"Industry\")) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  margin_from_types_byname(list(m, m), types = list(c(\"Product\", \"Industry\"))) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 1 2 #>  margin_from_types_byname(list(m, m), types = list(c(\"Product\", \"Industry\"),                                                    c(\"Product\", \"Industry\"))) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 1 2 #>  # Works in a data frame m2 <- matrix(2) %>%   setrowtype(\"Industry\") %>% setcoltype(\"Product\") df <- tibble::tibble(m = list(m, m2), types = list(\"Product\", c(\"Product\", \"Industry\"))) res <- df %>%   dplyr::mutate(     margin = margin_from_types_byname(m, types)  ) res$margin #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>"},{"path":"/reference/matricize_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Matricize a vector — matricize_byname","title":"Matricize a vector — matricize_byname","text":"Converts vector rows columns named according notation matrix Matrix, depending type .","code":""},{"path":"/reference/matricize_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matricize a vector — matricize_byname","text":"","code":"matricize_byname(a, notation)"},{"path":"/reference/matricize_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matricize a vector — matricize_byname","text":"row (column) vector converted matrix based row (column) names. notation string vector created RCLabels::notation_vec() identifies notation row column names.","code":""},{"path":"/reference/matricize_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matricize a vector — matricize_byname","text":"matrix created vector .","code":""},{"path":"/reference/matricize_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matricize a vector — matricize_byname","text":"","code":"v <- matrix(c(1,               2,               3,                4),              nrow = 4, ncol = 1, dimnames = list(c(\"p1 -> i1\",                                                    \"p2 -> i1\",                                                    \"p1 -> i2\",                                                    \"p2 -> i2\"))) %>%    setrowtype(\"Products -> Industries\") # Default separator is \" -> \". matricize_byname(v, notation = RCLabels::arrow_notation) #>    i1 i2 #> p1  1  3 #> p2  2  4 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\""},{"path":"/reference/matrixproduct_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Name-wise matrix multiplication — matrixproduct_byname","title":"Name-wise matrix multiplication — matrixproduct_byname","text":"Multiplies operands left right (.summarise = FALSE). .summarise = TRUE, operands multiplied first last.","code":""},{"path":"/reference/matrixproduct_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name-wise matrix multiplication — matrixproduct_byname","text":"","code":"matrixproduct_byname(..., .summarise = FALSE)"},{"path":"/reference/matrixproduct_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name-wise matrix multiplication — matrixproduct_byname","text":"... Operands; constants, matrices, lists matrices. .summarise TRUE, matrix multiplication proceeds lists arguments. FALSE (default), items multiplied across lists.","code":""},{"path":"/reference/matrixproduct_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name-wise matrix multiplication — matrixproduct_byname","text":"matrix representing name-wise product operands.","code":""},{"path":"/reference/matrixproduct_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Name-wise matrix multiplication — matrixproduct_byname","text":"Performs union sorting multiplicand rows multiplier columns name prior multiplication. Zeroes inserted missing matrix elements. ensures dimensions multiplicand multiplier matrices conformable. .e., number columns multiplicand equal number rows multiplier, long column names multiplicand unique row names multiplier unique. column type multiplicand row type multiplier step multiplication, function fail. result matrix product row names first multiplicand column names last multiplier.","code":""},{"path":"/reference/matrixproduct_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name-wise matrix multiplication — matrixproduct_byname","text":"","code":"library(dplyr) V <- matrix(1:6, ncol = 3, dimnames = list(c(\"i1\", \"i2\"), c(\"c1\", \"c2\", \"c3\"))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") G <- matrix(1:4, ncol = 2, dimnames = list(c(\"c2\", \"c1\"), c(\"i2\", \"i1\"))) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") Z <- matrix(11:14, ncol = 2, dimnames = list(c(\"i1\", \"i2\"), c(\"s1\", \"s2\"))) %>%    setrowtype(\"Industries\") %>% setcoltype(\"Sectors\") # Succeeds because G is completed to include a row named c3 (that contains zeroes). matrixproduct_byname(V, G) #>    i1 i2 #> i1 13  5 #> i2 20  8 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" if (FALSE) V %*% G # Fails because E lacks a row named c3. matrixproduct_byname(V, G, Z) #>     s1  s2 #> i1 203 239 #> i2 316 372 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Sectors\" # This also works with lists matrixproduct_byname(list(V,V), list(G,G)) #> [[1]] #>    i1 i2 #> i1 13  5 #> i2 20  8 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> i1 13  5 #> i2 20  8 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- data.frame(V = I(list()), G = I(list())) DF[[1,\"V\"]] <- V DF[[2,\"V\"]] <- V DF[[1,\"G\"]] <- G DF[[2,\"G\"]] <- G matrixproduct_byname(DF$V, DF$G) #> [[1]] #>    i1 i2 #> i1 13  5 #> i2 20  8 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> i1 13  5 #> i2 20  8 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF %>% mutate(matprods = matrixproduct_byname(V, G)) #>              V          G     matprods #> 1 1, 2, 3,.... 1, 2, 3, 4 13, 20, 5, 8 #> 2 1, 2, 3,.... 1, 2, 3, 4 13, 20, 5, 8 # Also works with lists, multiplying down the lists if `.summarise = TRUE`. matrixproduct_byname(list(V, G, Z), .summarise = TRUE) #> [[1]] #>     s1  s2 #> i1 203 239 #> i2 316 372 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Sectors\" #>"},{"path":"/reference/matsbyname-package.html","id":null,"dir":"Reference","previous_headings":"","what":"matsbyname: An Implementation of Matrix Mathematics — matsbyname-package","title":"matsbyname: An Implementation of Matrix Mathematics — matsbyname-package","text":"implementation matrix mathematics wherein operations performed \"name.\"","code":""},{"path":[]},{"path":"/reference/matsbyname-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"matsbyname: An Implementation of Matrix Mathematics — matsbyname-package","text":"Maintainer: Matthew Heun matthew.heun@.com (ORCID)","code":""},{"path":"/reference/mean_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Name- and element-wise arithmetic mean of matrices — mean_byname","title":"Name- and element-wise arithmetic mean of matrices — mean_byname","text":"Gives arithmetic mean operands ....","code":""},{"path":"/reference/mean_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name- and element-wise arithmetic mean of matrices — mean_byname","text":"","code":"mean_byname(..., .summarise = FALSE)"},{"path":"/reference/mean_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name- and element-wise arithmetic mean of matrices — mean_byname","text":"... Operands: constants, matrices, lists matrices. .summarise Tells whether operation accomplished across lists (FALSE) lists (TRUE).","code":""},{"path":"/reference/mean_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name- and element-wise arithmetic mean of matrices — mean_byname","text":"name-wise arithmetic mean operands.","code":""},{"path":"/reference/mean_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Name- and element-wise arithmetic mean of matrices — mean_byname","text":"function performs union sorting row column names prior performing arithmetic mean. Zeroes inserted missing matrix elements.","code":""},{"path":"/reference/mean_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name- and element-wise arithmetic mean of matrices — mean_byname","text":"","code":"library(dplyr) mean_byname(100, 50) #> [1] 75 mean_byname(10, 20, 30) #> [1] 20 commoditynames <- c(\"c1\", \"c2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") G <- matrix(rev(1:4), ncol = 2, dimnames = list(rev(commoditynames), rev(industrynames))) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") (U + G) / 2 # Non-sensical. Row and column names not respected. #>     i1  i2 #> c1 2.5 2.5 #> c2 2.5 2.5 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" mean_byname(U, G) # Row and column names respected! Should be 1, 2, 3, and 4.  #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" mean_byname(U, G, G) #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" mean_byname(100, U) #>      i1   i2 #> c1 50.5 51.5 #> c2 51.0 52.0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" mean_byname(100, 50, U) #>          i1       i2 #> c1 50.33333 51.00000 #> c2 50.66667 51.33333 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" mean_byname(10, G) #>     i1  i2 #> c1 5.5 6.5 #> c2 6.0 7.0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" # This also works with lists mean_byname(list(100, 100), list(50, 50)) #> [[1]] #> [1] 75 #>  #> [[2]] #> [1] 75 #>  mean_byname(list(U,U), list(G,G)) #> [[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- data.frame(U = I(list()), G = I(list())) DF[[1,\"U\"]] <- U DF[[2,\"U\"]] <- U DF[[1,\"G\"]] <- G DF[[2,\"G\"]] <- G mean_byname(DF$U, DF$G) #> [[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF %>% mutate(means = mean_byname(U, G)) #>            U          G      means #> 1 1, 2, 3, 4 4, 3, 2, 1 1, 2, 3, 4 #> 2 1, 2, 3, 4 4, 3, 2, 1 1, 2, 3, 4"},{"path":"/reference/naryapply_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function ","title":"Apply a function ","text":"Applies FUN operands .... arguments similar meaning binaryapply_byname(). See details information.","code":""},{"path":"/reference/naryapply_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function ","text":"","code":"naryapply_byname(   FUN,   ...,   .FUNdots = NULL,   match_type = c(\"all\", \"matmult\", \"none\"),   set_rowcoltypes = TRUE,   .organize = TRUE,   .summarise = FALSE )"},{"path":"/reference/naryapply_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function ","text":"FUN binary function applied \"name\" operands .... ... operands FUN. .FUNdots list additional named arguments passed FUN. match_type One \"\", \"matmult\", \"none\". ... matrices, \"\" (default) indicates rowtypes ... matrices must match coltypes ... matrices must match. \"matmult\", coltype first operand must match rowtype second operand every sequential invocation FUN. \"none\", neither coltypes rowtypes checked naryapply_byname(). set_rowcoltypes Tells whether apply row column types operands ... output sequential invocation FUN. Set TRUE (default) apply row column types. Set FALSE, apply row column types output. .organize boolean tells whether automatically complete operands ... relative sort rows columns completed matrices. organizing done sequential invocation FUN. Normally, TRUE (default). However, FUN takes responsibility, set FALSE. .summarise boolean tells whether call considered summarise operation (like dplyr::summarise()). Default FALSE.","code":""},{"path":"/reference/naryapply_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function ","text":"result applying FUN operands ...","code":""},{"path":"/reference/naryapply_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a function ","text":"one ... argument supplied, FUN must capable handling one argument, call routed unaryapply_byname(). set_rowcoltypes TRUE, rowcoltypes argument unaryapply_byname() set \"\", set_rowcoltypes FALSE, rowcoltypes argument unaryapply_byname() set \"none\". finer control desired, caller use unaryapply_byname() directly. one argument passed ..., FUN must binary function, use naryapply_byname() \"n-ary.\" Arguments match_type, set_rowcoltypes, .organize meaning binaryapply_byname(). Thus, operands ... must obey rules type matching match_type TRUE. naryapply_byname() cumapply_byname() similar. differences can described considering data frame. naryapply_byname() applies FUN several columns (variables) data frame. example, sum_byname() applied several variables gives another column containing sums across row data frame. cumapply_byname() applies FUN successive entries single column. example sum_byname() applied single column gives sum numbers column.","code":""},{"path":"/reference/naryapply_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function ","text":"","code":"naryapply_byname(FUN = sum_byname, 2, 3) #> [1] 5 naryapply_byname(FUN = sum_byname, 2, 3, 4, -4, -3, -2) #> [1] 0 # Routes to unaryapply_byname naryapply_byname(FUN = `^`, list(1,2,3), .FUNdots = list(2)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 4 #>  #> [[3]] #> [1] 9 #>"},{"path":"/reference/naryapplylogical_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function logically to numbers, matrices, or lists of numbers or matrices — naryapplylogical_byname","title":"Apply a function logically to numbers, matrices, or lists of numbers or matrices — naryapplylogical_byname","text":"Operands logical, although numerical operands accepted. Numerical operands interpreted 0 FALSE, number TRUE.","code":""},{"path":"/reference/naryapplylogical_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function logically to numbers, matrices, or lists of numbers or matrices — naryapplylogical_byname","text":"","code":"naryapplylogical_byname(   FUN,   ...,   .FUNdots = NULL,   match_type = c(\"all\", \"matmult\", \"none\"),   set_rowcoltypes = TRUE,   .organize = TRUE,   .summarise = FALSE )"},{"path":"/reference/naryapplylogical_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function logically to numbers, matrices, or lists of numbers or matrices — naryapplylogical_byname","text":"FUN binary function (returns logical values) applied operands ... operands; constants, matrices, lists matrices .FUNdots list additional named arguments passed FUN. match_type One \"\", \"matmult\", \"none\". ... matrices, \"\" (default) indicates rowtypes ... matrices must match coltypes ... matrices must match. \"matmult\", coltype first operand must match rowtype second operand every sequential invocation FUN. \"none\", neither coltypes rowtypes checked naryapply_byname(). set_rowcoltypes Tells whether apply row column types operands ... output sequential invocation FUN. Set TRUE (default) apply row column types. Set FALSE, apply row column types output. .organize boolean tells whether automatically complete operands ... relative sort rows columns completed matrices. organizing done sequential invocation FUN. Normally, TRUE (default). However, FUN takes responsibility, set FALSE. .summarise boolean tells whether call considered summarise operation (like dplyr::summarise()). Default FALSE.","code":""},{"path":"/reference/naryapplylogical_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function logically to numbers, matrices, or lists of numbers or matrices — naryapplylogical_byname","text":"result FUN applied logically ...","code":""},{"path":"/reference/naryapplylogical_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a function logically to numbers, matrices, or lists of numbers or matrices — naryapplylogical_byname","text":"function exported, thereby retaining right future changes.","code":""},{"path":"/reference/naryapplylogical_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function logically to numbers, matrices, or lists of numbers or matrices — naryapplylogical_byname","text":"","code":"matsbyname:::naryapplylogical_byname(`&`, TRUE, TRUE, TRUE) #> [1] TRUE matsbyname:::naryapplylogical_byname(`&`, TRUE, TRUE, FALSE) #> [1] FALSE"},{"path":"/reference/ncol_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the number of columns in a ","title":"Get the number of columns in a ","text":"functionn gets number columns \"byname\" matrix, \"byname\" matrix contained column data frame.","code":""},{"path":"/reference/ncol_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the number of columns in a ","text":"","code":"ncol_byname(a)"},{"path":"/reference/ncol_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the number of columns in a ","text":"matrix column data frame populated \"byname\" matrices.","code":""},{"path":"/reference/ncol_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the number of columns in a ","text":"number columns matrix, list containing number columns matrices contained column data frame.","code":""},{"path":"/reference/ncol_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the number of columns in a ","text":"","code":"productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %>%    setrowtype(\"Products\") %>%    setcoltype(\"Industries\") productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\", \"i3\") U2 <- matrix(1:3, ncol = length(industrynames),               nrow = length(productnames), dimnames = list(productnames, industrynames)) %>%    setrowtype(\"Products\") %>%    setcoltype(\"Industries\") productnames <- c(\"p1\", \"p2\", \"p3\") industrynames <- c(\"i1\", \"i2\", \"i3\", \"i4\") U3 <- matrix(1:4, ncol = length(industrynames),               nrow = length(productnames), dimnames = list(productnames, industrynames)) %>%    setrowtype(\"Products\") %>%    setcoltype(\"Industries\") dfUs <- data.frame(   year = numeric(),   matrix_byname = I(list()) )   dfUs <- data.frame( year = numeric(), matrix_byname = I(list()) ) dfUs[[1, \"matrix_byname\"]] <- U dfUs[[2, \"matrix_byname\"]] <- U2 dfUs[[3, \"matrix_byname\"]] <- U3 dfUs[[1, \"year\"]] <- 2000 dfUs[[2, \"year\"]] <- 2001 dfUs[[3, \"year\"]] <- 2002 number_cols <- ncol_byname(dfUs$matrix_byname) %>%  print() #> [[1]] #> [1] 2 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 4 #>"},{"path":"/reference/nrow_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the number of rows in a ","title":"Get the number of rows in a ","text":"functionn gets number rows \"byname\" matrix, \"byname\" matrix contained column data frame.","code":""},{"path":"/reference/nrow_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the number of rows in a ","text":"","code":"nrow_byname(a)"},{"path":"/reference/nrow_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the number of rows in a ","text":"matrix column data frame populated \"byname\" matrices.","code":""},{"path":"/reference/nrow_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the number of rows in a ","text":"number rows matrix, list containing number rows matrices contained column data frame.","code":""},{"path":"/reference/nrow_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the number of rows in a ","text":"","code":"productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %>%    setrowtype(\"Products\") %>%    setcoltype(\"Industries\") productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\", \"i3\") U2 <- matrix(1:3, ncol = length(industrynames),               nrow = length(productnames), dimnames = list(productnames, industrynames)) %>%    setrowtype(\"Products\") %>%    setcoltype(\"Industries\") productnames <- c(\"p1\", \"p2\", \"p3\") industrynames <- c(\"i1\", \"i2\", \"i3\", \"i4\") U3 <- matrix(1:4, ncol = length(industrynames),               nrow = length(productnames), dimnames = list(productnames, industrynames)) %>%    setrowtype(\"Products\") %>%    setcoltype(\"Industries\") dfUs <- data.frame(   year = numeric(),   matrix_byname = I(list()) ) dfUs[[1, \"matrix_byname\"]] <- U dfUs[[2, \"matrix_byname\"]] <- U2 dfUs[[3, \"matrix_byname\"]] <- U3 dfUs[[1, \"year\"]] <- 2000 dfUs[[2, \"year\"]] <- 2001 dfUs[[3, \"year\"]] <- 2002 number_rows <- matsbyname::nrow_byname(dfUs$matrix_byname)"},{"path":"/reference/organize_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Organize binary arguments — organize_args","title":"Organize binary arguments — organize_args","text":"Organizes arguments binary (2 arguments) _byname functions. Actions performed : one argument list, make argument also list equal length. arguments lists, ensure length. one argument matrix constant, make constant matrix. ensures row column types match typematch_margins. ensures list item names match b lists; complaints made neither b names. completes sorts matrices.","code":""},{"path":"/reference/organize_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Organize binary arguments — organize_args","text":"","code":"organize_args(a, b, match_type = \"all\", fill)"},{"path":"/reference/organize_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Organize binary arguments — organize_args","text":"first argument organized b second argument organized match_type one \"\", \"matmult\", \"none\". b matrices, \"\" (default) indicates rowtypes must match rowtypes b coltypes must match coltypes b. \"matmult\", coltypes must match rowtypes b. fill replacement value b either missing NULL.","code":""},{"path":"/reference/organize_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Organize binary arguments — organize_args","text":"list two elements (named b) containing organized versions arguments","code":""},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pow_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Powers of matrix elements — pow_byname","title":"Powers of matrix elements — pow_byname","text":"Gives result raising elements matrix list matrices power.","code":""},{"path":"/reference/pow_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Powers of matrix elements — pow_byname","text":"","code":"pow_byname(a, pow)"},{"path":"/reference/pow_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Powers of matrix elements — pow_byname","text":"matrix list matrices pow power elements raised","code":""},{"path":"/reference/pow_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Powers of matrix elements — pow_byname","text":"element raised pow","code":""},{"path":"/reference/pow_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Powers of matrix elements — pow_byname","text":"","code":"library(dplyr) pow_byname(2, 3) #> [1] 8 m <- matrix(2, nrow = 2, ncol = 3, dimnames = list(paste0(\"r\", 1:2), paste0(\"c\", 1:3))) %>%    setrowtype(\"rows\") %>% setcoltype(\"cols\") pow_byname(m, 2) #>    c1 c2 c3 #> r1  4  4  4 #> r2  4  4  4 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" DF <- data.frame(m = I(list()), pow = I(list())) DF[[1, \"m\"]] <- m DF[[2, \"m\"]] <- m DF[[1, \"pow\"]] <- 0.5 DF[[2, \"pow\"]] <- -1 DF %>% mutate(   sqrtm = pow_byname(m, 0.5),   mtopow = pow_byname(m, pow) ) #>              m pow                                                      sqrtm #> 1 2, 2, 2,.... 0.5 1.414214, 1.414214, 1.414214, 1.414214, 1.414214, 1.414214 #> 2 2, 2, 2,....  -1 1.414214, 1.414214, 1.414214, 1.414214, 1.414214, 1.414214 #>                                                       mtopow #> 1 1.414214, 1.414214, 1.414214, 1.414214, 1.414214, 1.414214 #> 2                               0.5, 0.5, 0.5, 0.5, 0.5, 0.5"},{"path":"/reference/prep_vector_arg.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare a vector argument — prep_vector_arg","title":"Prepare a vector argument — prep_vector_arg","text":"helper function many *_byname functions.","code":""},{"path":"/reference/prep_vector_arg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare a vector argument — prep_vector_arg","text":"","code":"prep_vector_arg(a, vector_arg)"},{"path":"/reference/prep_vector_arg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare a vector argument — prep_vector_arg","text":"matrix list matrices. vector_arg vector argument apply calculation.","code":""},{"path":"/reference/prep_vector_arg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare a vector argument — prep_vector_arg","text":"vector_arg, possibly modified list.","code":""},{"path":"/reference/prep_vector_arg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare a vector argument — prep_vector_arg","text":"potentially ambiguous specify vector matrix argument, say, margin = c(1, 2) applying *_byname functions unary list . Rather, one specify, say, margin = list(c(1, 2)) avoid ambiguity. list, vector_arg list length > 1 length equal length , function returns list value vector_arg. list vector_arg list, function returns un-recursive, unlisted version vector_arg. Note vector_arg single matrix, automatically enclosed list list.","code":""},{"path":"/reference/prep_vector_arg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare a vector argument — prep_vector_arg","text":"","code":"m <- matrix(c(2, 2)) prep_vector_arg(m, vector_arg = c(1,2)) #> [1] 1 2 prep_vector_arg(list(m), vector_arg = c(1,2)) #> [[1]] #> [1] 1 2 #>  prep_vector_arg(list(m, m), vector_arg = c(1,2)) #> [1] 1 2 prep_vector_arg(list(m, m, m), vector_arg = c(1,2)) #> [[1]] #> [1] 1 2 #>"},{"path":"/reference/prepare_.FUNdots.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare the .FUNdots argument for *apply_byname functions. — prepare_.FUNdots","title":"Prepare the .FUNdots argument for *apply_byname functions. — prepare_.FUNdots","text":"helper function various *apply_byname functions.","code":""},{"path":"/reference/prepare_.FUNdots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare the .FUNdots argument for *apply_byname functions. — prepare_.FUNdots","text":"","code":"prepare_.FUNdots(a, .FUNdots)"},{"path":"/reference/prepare_.FUNdots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare the .FUNdots argument for *apply_byname functions. — prepare_.FUNdots","text":"main argument *apply_byname function. .FUNdots list additional arguments applied FUN one *apply_byname functions.","code":""},{"path":"/reference/prepare_.FUNdots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare the .FUNdots argument for *apply_byname functions. — prepare_.FUNdots","text":"reconfigured version .FUNdots, ready use *apply_byname function. item .FUNdots lists item .FUNdots (list ) length different 1 length(), throw error item .FUNdots (list ) length 1, replicate single item list length = length() item .FUNdots (list ) length = length(), use item .FUNdots list, item .FUNdots list pass argument along hope best.  situation probably error. , become apparent soon. list item (argument) .FUNdots list situation ambiguous. say list values length 2, argument margin = c(1, 2). margin = 1 applied [[1]] margin = 2 applied [[2]]? margin = c(1, 2) applied [[1]] [[2]]? ambiguity handled using function prep_vector_arg() within function calls unaryapply_byname(). example, see identize_byname(). arguments coming data frame, ambiguity, information coming .FUNdots[[]] list. Optimizing data frame case, function allows vectors length equal length list , interpreting vectors applying sequence turn. algorithm follows: non-NULL item .FUNdots (list) length 1 length(), throw error. non-NULL item .FUNdots (list) length = 1, replicate single item list length = length(). non-NULL item .FUNdots (list) length = length(), leave -. neither item .FUNdots list length = 1, single matrix reports length number elements matrix. , check length situation. item .FUNdots assumed length 1 passed along","code":""},{"path":"/reference/prepare_.FUNdots.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare the .FUNdots argument for *apply_byname functions. — prepare_.FUNdots","text":"four cases single item .FUNdots: item .FUNdots lists item .FUNdots (list ) length different 1 length(), throw error item .FUNdots (list ) length 1, replicate single item list length = length() item .FUNdots (list ) length = length(), use item .FUNdots list item (argument) .FUNdots list item .FUNdots (list) length != 1, throw error, ambiguity item .FUNdots treated. item .FUNdots (list) length = 1, replicate single item list length = length() list, item .FUNdots list pass argument along hope best.  situation probably error.  , become apparent soon. neither item .FUNdots list length = 1, single matrix reports length number elements matrix. , check length situation. item .FUNdots assumed length 1 passed along","code":""},{"path":"/reference/prodall_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Product of all elements in a matrix — prodall_byname","title":"Product of all elements in a matrix — prodall_byname","text":"function equivalent \\%>\\% rowprods_byname() \\%>\\% colprods_byname(), returns single numeric value instead 1x1 matrix.","code":""},{"path":"/reference/prodall_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Product of all elements in a matrix — prodall_byname","text":"","code":"prodall_byname(a)"},{"path":"/reference/prodall_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Product of all elements in a matrix — prodall_byname","text":"matrix whose elements multiplied.","code":""},{"path":"/reference/prodall_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Product of all elements in a matrix — prodall_byname","text":"product elements numeric.","code":""},{"path":"/reference/prodall_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Product of all elements in a matrix — prodall_byname","text":"","code":"library(dplyr) M <- matrix(2, nrow=2, ncol=2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industry\") %>% setcoltype(\"Product\") prodall_byname(M) #> [1] 16 rowprods_byname(M) %>% colprods_byname #>          Product #> Industry      16 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Product\" # Also works for lists prodall_byname(list(M,M)) #> [[1]] #> [1] 16 #>  #> [[2]] #> [1] 16 #>  DF <- data.frame(M = I(list())) DF[[1,\"M\"]] <- M DF[[2,\"M\"]] <- M prodall_byname(DF$M[[1]]) #> [1] 16 prodall_byname(DF$M) #> [[1]] #> [1] 16 #>  #> [[2]] #> [1] 16 #>  res <- DF %>% mutate(   prods = prodall_byname(M) ) res$prods #> [[1]] #> [1] 16 #>  #> [[2]] #> [1] 16 #>"},{"path":"/reference/quasi-quote-assign.html","id":null,"dir":"Reference","previous_headings":"","what":"Assignment — :=","title":"Assignment — :=","text":"See rlang:::= details.","code":""},{"path":"/reference/quasi-quote-assign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assignment — :=","text":"","code":"x := y"},{"path":"/reference/quotient_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Name-wise matrix element division — quotient_byname","title":"Name-wise matrix element division — quotient_byname","text":"Element-wise division two matrices.","code":""},{"path":"/reference/quotient_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name-wise matrix element division — quotient_byname","text":"","code":"quotient_byname(dividend, divisor)"},{"path":"/reference/quotient_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name-wise matrix element division — quotient_byname","text":"dividend Dividend matrix constant divisor Divisor matrix constant","code":""},{"path":"/reference/quotient_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name-wise matrix element division — quotient_byname","text":"matrix representing name-wise element quotient dividend divisor","code":""},{"path":"/reference/quotient_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Name-wise matrix element division — quotient_byname","text":"Performs union sorting names rows columns dividend divisor prior element division. Zeroes inserted missing matrix elements. ensures dimensions dividend divisor conformable.","code":""},{"path":"/reference/quotient_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name-wise matrix element division — quotient_byname","text":"","code":"library(dplyr) quotient_byname(100, 50) #> [1] 2 commoditynames <- c(\"c1\", \"c2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") G <- matrix(rev(1:4), ncol = 2, dimnames = list(rev(commoditynames), rev(industrynames))) %>%   setrowtype(\"Commodities\") %>% setcoltype(\"Industries\") U / G # Non-sensical.  Names aren't aligned #>           i1  i2 #> c1 0.2500000 1.5 #> c2 0.6666667 4.0 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" quotient_byname(U, G) #>    i1 i2 #> c1  1  1 #> c2  1  1 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" quotient_byname(U, 10) #>     i1  i2 #> c1 0.1 0.3 #> c2 0.2 0.4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" quotient_byname(10, G) #>    i1       i2 #> c1 10 3.333333 #> c2  5 2.500000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" # This also works with lists quotient_byname(10, list(G,G)) #> [[1]] #>    i1       i2 #> c1 10 3.333333 #> c2  5 2.500000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1       i2 #> c1 10 3.333333 #> c2  5 2.500000 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  quotient_byname(list(G,G), 10) #> [[1]] #>     i1  i2 #> c1 0.1 0.3 #> c2 0.2 0.4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>     i1  i2 #> c1 0.1 0.3 #> c2 0.2 0.4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  quotient_byname(list(U, U), list(G, G)) #> [[1]] #>    i1 i2 #> c1  1  1 #> c2  1  1 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  1  1 #> c2  1  1 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- data.frame(U = I(list()), G = I(list())) DF[[1,\"U\"]] <- U DF[[2,\"U\"]] <- U DF[[1,\"G\"]] <- G DF[[2,\"G\"]] <- G quotient_byname(DF$U, DF$G) #> [[1]] #>    i1 i2 #> c1  1  1 #> c2  1  1 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  1  1 #> c2  1  1 #> attr(,\"rowtype\") #> [1] \"Commodities\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF %>% mutate(elementquotients = quotient_byname(U, G)) #>            U          G elementquotients #> 1 1, 2, 3, 4 4, 3, 2, 1       1, 1, 1, 1 #> 2 1, 2, 3, 4 4, 3, 2, 1       1, 1, 1, 1"},{"path":"/reference/rename_to_piece_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Rename matrix rows and columns by piece of row or column names — rename_to_piece_byname","title":"Rename matrix rows and columns by piece of row or column names — rename_to_piece_byname","text":"can convenient rename rows columns matrices based retaining piece row /column names. function provides capability.","code":""},{"path":"/reference/rename_to_piece_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rename matrix rows and columns by piece of row or column names — rename_to_piece_byname","text":"","code":"rename_to_piece_byname(   a,   piece,   margin = list(c(1, 2)),   inf_notation = TRUE,   notation = list(RCLabels::notations_list),   choose_most_specific = FALSE,   prepositions = list(RCLabels::prepositions_list) )"},{"path":"/reference/rename_to_piece_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rename matrix rows and columns by piece of row or column names — rename_to_piece_byname","text":"matrix list matrices whose rows columns renamed. piece character string indicating piece row column names retain, one \"noun\", \"pps\", \"pref\" \"suff\", preposition, indicating part row column name retained. margin character, row type column type renamed. integer, margin renamed. Default c(1, 2), meaning rows (margin = 1) columns (margin = 2) renamed. inf_notation boolean tells whether infer notation. Default TRUE. notation notation used row column labels. Default list(RCLabels::notations_list). default value wrapped list, RCLabels::notations_list , , list. See RCLabels. choose_most_specific boolean indicates whether -specific notation inferred one notation matches row column label allow_multiple = FALSE. FALSE, first matching notation notations returned allow_multiple = FALSE. Default FALSE. prepositions Prepositions can used row column label. Default RCLabels::prepositions_list.","code":""},{"path":"/reference/rename_to_piece_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rename matrix rows and columns by piece of row or column names — rename_to_piece_byname","text":"version renamed rows columns.","code":""},{"path":"/reference/rename_to_piece_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rename matrix rows and columns by piece of row or column names — rename_to_piece_byname","text":"Internally, function finds pieces row column names via RCLabels package. piece can anything RCLabels::get_piece() understands. Note margin can either integer vector character vector. margin character vector, interpreted row column type, margin_from_types_byname() called internally resolve integer margins interest. Note row /column type present, row /column type also renamed according piece.","code":""},{"path":"/reference/rename_to_piece_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rename matrix rows and columns by piece of row or column names — rename_to_piece_byname","text":"","code":"m <- matrix(c(1, 2,                3, 4,                5, 6), nrow = 3, byrow = TRUE,              dimnames = list(c(\"a -> b\", \"r2\", \"r3\"), c(\"a -> b\", \"c -> d\"))) m #>        a -> b c -> d #> a -> b      1      2 #> r2          3      4 #> r3          5      6 rename_to_piece_byname(m, piece = \"pref\", notation = RCLabels::arrow_notation) #>    a c #> a  1 2 #> r2 3 4 #> r3 5 6 m2 <- m %>%   setrowtype(\"rows\") %>% setcoltype(\"cols\") m2 #>        a -> b c -> d #> a -> b      1      2 #> r2          3      4 #> r3          5      6 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" rename_to_piece_byname(m2, piece = \"pref\", margin = \"rows\",                        notation = RCLabels::arrow_notation) #>    a -> b c -> d #> a       1      2 #> r2      3      4 #> r3      5      6 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" rename_to_piece_byname(m2, piece = \"suff\", margin = \"rows\",                        notation = RCLabels::arrow_notation) #>   a -> b c -> d #> b      1      2 #>        3      4 #>        5      6 #> attr(,\"rowtype\") #> [1] \"\" #> attr(,\"coltype\") #> [1] \"cols\""},{"path":"/reference/rename_to_pref_suff_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Rename matrix rows and columns by prefix and suffix — rename_to_pref_suff_byname","title":"Rename matrix rows and columns by prefix and suffix — rename_to_pref_suff_byname","text":"can convenient rename rows columns matrices based retaining prefixes suffixes. function provides capability.","code":""},{"path":"/reference/rename_to_pref_suff_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rename matrix rows and columns by prefix and suffix — rename_to_pref_suff_byname","text":"","code":"rename_to_pref_suff_byname(a, keep, margin = c(1, 2), notation)"},{"path":"/reference/rename_to_pref_suff_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rename matrix rows and columns by prefix and suffix — rename_to_pref_suff_byname","text":"matrix list matrices whose rows columns renamed. keep one \"prefix\" \"suffix\" indicating part row column name retain. margin one 1, 2, c(1, 2) 1 indicates rows 2 indicates columns. notation See notation_vec().","code":""},{"path":"/reference/rename_to_pref_suff_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rename matrix rows and columns by prefix and suffix — rename_to_pref_suff_byname","text":"potentially different row column names.","code":""},{"path":"/reference/rename_to_pref_suff_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rename matrix rows and columns by prefix and suffix — rename_to_pref_suff_byname","text":"prefix defined opening string (prefix_open) closing string (prefix_close). suffix defined opening string (suffix_open) closing string (suffix_close). sep provided none prefix_open, prefix_close, suffix_open, suffix_close provided, default arguments become: * prefix_open: \"\", * prefix_close: sep, * suffix_open: sep, * suffix_close: \"\". keep parameter tells portion retain (prefixes suffixes), prefixes suffixes found row /column name, name unchanged.","code":""},{"path":"/reference/rename_to_pref_suff_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rename matrix rows and columns by prefix and suffix — rename_to_pref_suff_byname","text":"","code":"# This function is superseded.  # Instead, use `rename_to_pieces_byname()`. # For example: m <- matrix(c(1, 2,                3, 4,                5, 6), nrow = 3, byrow = TRUE,              dimnames = list(c(\"a -> b\", \"r2\", \"r3\"), c(\"a -> b\", \"c -> d\"))) m #>        a -> b c -> d #> a -> b      1      2 #> r2          3      4 #> r3          5      6 rename_to_piece_byname(m, piece = \"pref\", notation = RCLabels::arrow_notation) #>    a c #> a  1 2 #> r2 3 4 #> r3 5 6 # Note, labels are lost, because some labels are missing a suffix. rename_to_piece_byname(m, piece = \"suff\", notation = RCLabels::arrow_notation) #>   b d #> b 1 2 #>   3 4 #>   5 6 # Original documentation: rename_to_pref_suff_byname(m, keep = \"pref\", notation = RCLabels::arrow_notation) #>    a c #> a  1 2 #> r2 3 4 #> r3 5 6 rename_to_pref_suff_byname(m, keep = \"suff\", notation = RCLabels::arrow_notation) #>   b d #> b 1 2 #>   3 4 #>   5 6"},{"path":"/reference/replaceNaN_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace NaN values with a value — replaceNaN_byname","title":"Replace NaN values with a value — replaceNaN_byname","text":"matrix within matrices list, replace NaN matrix values val.","code":""},{"path":"/reference/replaceNaN_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace NaN values with a value — replaceNaN_byname","text":"","code":"replaceNaN_byname(a, val = 0)"},{"path":"/reference/replaceNaN_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace NaN values with a value — replaceNaN_byname","text":"matrix list matrices NaN replaced val. val NaNs replace val.","code":""},{"path":"/reference/replaceNaN_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace NaN values with a value — replaceNaN_byname","text":"matrix list matrices NaN replaced val.","code":""},{"path":"/reference/replaceNaN_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace NaN values with a value — replaceNaN_byname","text":"","code":"suppressWarnings(a <- matrix(c(1, sqrt(-1)))) replaceNaN_byname(a) #>      [,1] #> [1,]    1 #> [2,]    0 replaceNaN_byname(a, 42) #>      [,1] #> [1,]    1 #> [2,]   42"},{"path":"/reference/rowprods_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Row products, sorted by name — rowprods_byname","title":"Row products, sorted by name — rowprods_byname","text":"Calculates row products (product elements row) matrix. optional colname resulting column vector can supplied. colname NULL NA (default), column name set column type given coltype().","code":""},{"path":"/reference/rowprods_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row products, sorted by name — rowprods_byname","text":"","code":"rowprods_byname(a, colname = NA)"},{"path":"/reference/rowprods_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row products, sorted by name — rowprods_byname","text":"matrix list matrices row products desired. colname Name output column containing row products.","code":""},{"path":"/reference/rowprods_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row products, sorted by name — rowprods_byname","text":"column vector type matrix containing row products ","code":""},{"path":"/reference/rowprods_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Row products, sorted by name — rowprods_byname","text":"","code":"library(dplyr) M <- matrix(c(1:6), ncol = 2, dimnames = list(paste0(\"i\", 3:1), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Products\") rowprods_byname(M) #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" rowprods_byname(M, \"E.ktoe\") #>    E.ktoe #> i1     18 #> i2     10 #> i3      4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" # This also works with lists rowprods_byname(list(M, M)) #> [[1]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  #> [[2]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  rowprods_byname(list(M, M), \"E.ktoe\") #> [[1]] #>    E.ktoe #> i1     18 #> i2     10 #> i3      4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  #> [[2]] #>    E.ktoe #> i1     18 #> i2     10 #> i3      4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  rowprods_byname(list(M, M), NA) #> [[1]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  #> [[2]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  rowprods_byname(list(M, M), NULL) #> [[1]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  #> [[2]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  DF <- data.frame(M = I(list())) DF[[1,\"M\"]] <- M DF[[2,\"M\"]] <- M rowprods_byname(DF$M[[1]]) #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" rowprods_byname(DF$M) #> [[1]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  #> [[2]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" #>  ans <- DF %>% mutate(rs = rowprods_byname(M)) ans #>              M        rs #> 1 1, 2, 3,.... 18, 10, 4 #> 2 1, 2, 3,.... 18, 10, 4 ans$rs[[1]] #>    Products #> i1       18 #> i2       10 #> i3        4 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Products\" # Nonsensical if (FALSE) rowprods_byname(NULL)"},{"path":"/reference/rowsums_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Row sums, sorted by name — rowsums_byname","title":"Row sums, sorted by name — rowsums_byname","text":"Calculates row sums matrix post-multiplying identity vector (containing 1's). contrast rowSums (returns numeric result), return value rowsums_byname matrix. optional colname resulting column vector can supplied. colname NULL NA (default), column name set column type given coltype(). colname set NULL, column name returned empty.","code":""},{"path":"/reference/rowsums_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row sums, sorted by name — rowsums_byname","text":"","code":"rowsums_byname(a, colname = NA)"},{"path":"/reference/rowsums_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row sums, sorted by name — rowsums_byname","text":"matrix list matrices row sums desired. colname name output column containing row sums.","code":""},{"path":"/reference/rowsums_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row sums, sorted by name — rowsums_byname","text":"column vector type matrix containing row sums m.","code":""},{"path":"/reference/rowsums_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Row sums, sorted by name — rowsums_byname","text":"","code":"library(dplyr) rowsums_byname(42) #> [1] 42 m <- matrix(c(1:6), ncol = 2, dimnames = list(paste0(\"i\", 3:1), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") m #>    c1 c2 #> i3  1  4 #> i2  2  5 #> i1  3  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" rowsums_byname(m) #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" rowsums_byname(m, \"E.ktoe\") #>    E.ktoe #> i1      9 #> i2      7 #> i3      5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # This also works with lists rowsums_byname(list(m, m)) #> [[1]] #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  rowsums_byname(list(m, m), \"E.ktoe\") #> [[1]] #>    E.ktoe #> i1      9 #> i2      7 #> i3      5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    E.ktoe #> i1      9 #> i2      7 #> i3      5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  rowsums_byname(list(m, m), NA) #> [[1]] #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  rowsums_byname(list(m, m), NULL) #> [[1]] #>    [,1] #> i1    9 #> i2    7 #> i3    5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    [,1] #> i1    9 #> i2    7 #> i3    5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  DF <- data.frame(m = I(list())) DF[[1,\"m\"]] <- m DF[[2,\"m\"]] <- m rowsums_byname(DF$m[[1]]) #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" rowsums_byname(DF$m) #> [[1]] #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  ans <- DF %>% mutate(rs = rowsums_byname(m)) ans #>              m      rs #> 1 1, 2, 3,.... 9, 7, 5 #> 2 1, 2, 3,.... 9, 7, 5 ans$rs[[1]] #>    Commodities #> i1           9 #> i2           7 #> i3           5 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # Nonsensical if (FALSE) rowsums_byname(NULL)"},{"path":"/reference/rowtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Row type — rowtype","title":"Row type — rowtype","text":"Extracts row type .","code":""},{"path":"/reference/rowtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row type — rowtype","text":"","code":"rowtype(a)"},{"path":"/reference/rowtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row type — rowtype","text":"object want extract row types.","code":""},{"path":"/reference/rowtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row type — rowtype","text":"row type .","code":""},{"path":"/reference/rowtype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Row type — rowtype","text":"","code":"library(dplyr) commoditynames <- c(\"c1\", \"c2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %>%   setrowtype(rowtype = \"Commodities\") %>% setcoltype(\"Industries\") rowtype(U) #> [1] \"Commodities\" # This also works for lists rowtype(list(U,U)) #> [[1]] #> [1] \"Commodities\" #>  #> [[2]] #> [1] \"Commodities\" #>"},{"path":"/reference/samestructure_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Test whether matrices or lists of matrices have same structure — samestructure_byname","title":"Test whether matrices or lists of matrices have same structure — samestructure_byname","text":"Matrices said structure row column types identical row column names identical. Values can different.","code":""},{"path":"/reference/samestructure_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test whether matrices or lists of matrices have same structure — samestructure_byname","text":"","code":"samestructure_byname(..., .summarise = FALSE)"},{"path":"/reference/samestructure_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test whether matrices or lists of matrices have same structure — samestructure_byname","text":"... Operands compared. .summarise Tells whether operation accomplished across lists (FALSE) lists (TRUE).","code":""},{"path":"/reference/samestructure_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test whether matrices or lists of matrices have same structure — samestructure_byname","text":"TRUE operands structure, FALSE otherwise.","code":""},{"path":"/reference/samestructure_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test whether matrices or lists of matrices have same structure — samestructure_byname","text":"","code":"samestructure_byname(2, 2) #> [1] TRUE productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") samestructure_byname(U, U) #> [1] TRUE samestructure_byname(U, U %>% setrowtype(\"row\")) #> [1] FALSE samestructure_byname(U %>% setcoltype(\"col\"), U) #> [1] FALSE # Also works with lists samestructure_byname(list(U, U), list(U, U)) #> [[1]] #> [1] TRUE #>  #> [[2]] #> [1] TRUE #>"},{"path":"/reference/select_cols_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Select columns of a matrix (or list of matrices) by name — select_cols_byname","title":"Select columns of a matrix (or list of matrices) by name — select_cols_byname","text":"Arguments indicate columns retained removed. maximum flexibility, arguments extended regex patterns matched column names.","code":""},{"path":"/reference/select_cols_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select columns of a matrix (or list of matrices) by name — select_cols_byname","text":"","code":"select_cols_byname(a, retain_pattern = \"$^\", remove_pattern = \"$^\")"},{"path":"/reference/select_cols_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select columns of a matrix (or list of matrices) by name — select_cols_byname","text":"matrix list matrices retain_pattern extended regex list extended regular expressions specifies columns m retain. Default pattern (\"$^\") retains nothing. remove_pattern extended regex list extended regular expressions specifies columns m remove. Default pattern (\"$^\") removes nothing.","code":""},{"path":"/reference/select_cols_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select columns of a matrix (or list of matrices) by name — select_cols_byname","text":"matrix subset columns selected retain_pattern remove_pattern.","code":""},{"path":"/reference/select_cols_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select columns of a matrix (or list of matrices) by name — select_cols_byname","text":"NULL, NULL returned. Patterns compared column names using extended regex. column names match retain_pattern, NULL returned. column names match remove_pattern, returned. Retaining columns takes precedence removing columns, always. typical patterns : \"^Electricity$|^Oil$\": column names EXACTLY \"Electricity\" \"Oil\". \"^Electricity|^Oil\": column names START \"Electricity\" \"Oil\". \"Electricity|Oil\": column names CONTAIN \"Electricity\" \"Oil\" anywhere within . Given list column names, pattern can constructed easily using make_pattern function. RCLabels::make_or_pattern() escapes regex strings using Hmisc::escaprRegex(). function assumes retain_pattern remove_pattern already suitably escaped. Note default retain_pattern remove_pattern (\"$^\") retain nothing remove nothing. Note columns removed , NULL returned.","code":""},{"path":"/reference/select_cols_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select columns of a matrix (or list of matrices) by name — select_cols_byname","text":"","code":"m <- matrix(1:16, ncol = 4, dimnames=list(c(paste0(\"i\", 1:4)), paste0(\"p\", 1:4))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") select_cols_byname(m,                     retain_pattern = RCLabels::make_or_pattern(c(\"p1\", \"p4\"),                     pattern_type = \"exact\")) #>    p1 p4 #> i1  1 13 #> i2  2 14 #> i3  3 15 #> i4  4 16 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" select_cols_byname(m,                     remove_pattern = RCLabels::make_or_pattern(c(\"p1\", \"p3\"),                     pattern_type = \"exact\")) #>    p2 p4 #> i1  5 13 #> i2  6 14 #> i3  7 15 #> i4  8 16 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # Also works for lists and data frames select_cols_byname(list(m,m), retain_pattern = \"^p1$|^p4$\") #> [[1]] #>    p1 p4 #> i1  1 13 #> i2  2 14 #> i3  3 15 #> i4  4 16 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    p1 p4 #> i1  1 13 #> i2  2 14 #> i3  3 15 #> i4  4 16 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>"},{"path":"/reference/select_rowcol_piece_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Select or remove rows or columns based on pieces of the names. — select_rowcol_piece_byname","title":"Select or remove rows or columns based on pieces of the names. — select_rowcol_piece_byname","text":"select_rows_byname() select_cols_byname() select rows columns using regex patterns function performs similar actions based pieces row column labels.","code":""},{"path":"/reference/select_rowcol_piece_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select or remove rows or columns based on pieces of the names. — select_rowcol_piece_byname","text":"","code":"select_rowcol_piece_byname(   a,   retain = NULL,   remove = NULL,   piece = \"all\",   pattern_type = \"exact\",   prepositions = RCLabels::prepositions_list,   notation = RCLabels::notations_list,   margin = c(1, 2) )"},{"path":"/reference/select_rowcol_piece_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select or remove rows or columns based on pieces of the names. — select_rowcol_piece_byname","text":"matrix list matrices whose rows columns selected. retain row column names retained. Default NULL, meaning removal requested. remove row column names removed. Default NULL, meaning retaining requested. piece piece row column names assessed. Default \"\", indicating entire label assessed. pattern_type way match label pieces. pattern_type passed RCLabels::make_or_pattern(). See RCLabels::make_or_pattern() details. Default \"exact\", meaning exact matches retained removed. options \"leading\", \"trailing\", \"anywhere\", \"literal\". prepositions prepositions can used identifying pieces. Default RCLabels::prepositions_list. notation notation row column names. Default RCLabels::notations_list, meaning notations known RCLabels assessed. margin margin row column removal requested. 1 indicates rows; 2 indicates columns. Default c(1, 2), meaning action taken rows columns.","code":""},{"path":"/reference/select_rowcol_piece_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select or remove rows or columns based on pieces of the names. — select_rowcol_piece_byname","text":"rows /column retained removed.","code":""},{"path":"/reference/select_rowcol_piece_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select or remove rows or columns based on pieces of the names. — select_rowcol_piece_byname","text":"function uses RCLabels package match row column names pieces. retain rows columns, specify retain. remove rows columns, specify remove. row column types, string may passed margin, case margin resolved. See examples. notation may list notations apply . function try infer notation applies row column names. Retaining takes precedence removing, always. Options piece \"\" (default), meaning entire label matched, \"pref\", meaning prefix matched, \"suff\", meaning suffix matched, \"noun\", meaning first part matched, \"\" (another preposition), meaning object preposition matched. retaining removing rows columns results rows columns remaining matrix, NULL returned.","code":""},{"path":"/reference/select_rowcol_piece_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select or remove rows or columns based on pieces of the names. — select_rowcol_piece_byname","text":"","code":"m <- matrix(1:4, nrow = 2, ncol = 2, byrow = TRUE,                dimnames = list(c(\"r1 [to a]\", \"r2 [to b]\"),                                c(\"c1 [from c]\", \"c2 [from d]\"))) %>%    setrowtype(\"rows\") %>% setcoltype(\"cols\") m #>           c1 [from c] c2 [from d] #> r1 [to a]           1           2 #> r2 [to b]           3           4 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" select_rowcol_piece_byname(m, retain = \"r1\", piece = \"noun\",                             notation = RCLabels::to_notation,                             margin = 1) #>           c1 [from c] c2 [from d] #> r1 [to a]           1           2 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" select_rowcol_piece_byname(m, retain = \"b\", piece = \"to\",                             notation = RCLabels::bracket_notation,                             margin = 1) #>           c1 [from c] c2 [from d] #> r2 [to b]           3           4 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" select_rowcol_piece_byname(m, retain = \"c1\", piece = \"noun\",                            notation = RCLabels::bracket_notation,                             margin = 2) #>           c1 [from c] #> r1 [to a]           1 #> r2 [to b]           3 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" select_rowcol_piece_byname(m, retain = \"d\", piece = \"from\",                             notation = RCLabels::bracket_notation,                             margin = 2) #>           c2 [from d] #> r1 [to a]           2 #> r2 [to b]           4 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" select_rowcol_piece_byname(m, retain = \"c\", piece = \"from\",                             notation = RCLabels::bracket_notation,                             margin = 2) #>           c1 [from c] #> r1 [to a]           1 #> r2 [to b]           3 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" select_rowcol_piece_byname(m, retain = \"b\", piece = \"to\",                             notation = RCLabels::bracket_notation,                             margin = \"rows\") #>           c1 [from c] c2 [from d] #> r2 [to b]           3           4 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" select_rowcol_piece_byname(m, retain = \"c\", piece = \"from\",                             notation = RCLabels::bracket_notation,                             margin = \"cols\") #>           c1 [from c] #> r1 [to a]           1 #> r2 [to b]           3 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\""},{"path":"/reference/select_rows_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Select (or de-select) rows of a matrix (or list of matrices) by name — select_rows_byname","title":"Select (or de-select) rows of a matrix (or list of matrices) by name — select_rows_byname","text":"Arguments indicate rows retained removed. maximum flexibility, arguments extended regex patterns matched row names.","code":""},{"path":"/reference/select_rows_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select (or de-select) rows of a matrix (or list of matrices) by name — select_rows_byname","text":"","code":"select_rows_byname(a, retain_pattern = \"$^\", remove_pattern = \"$^\")"},{"path":"/reference/select_rows_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select (or de-select) rows of a matrix (or list of matrices) by name — select_rows_byname","text":"matrix list matrices. retain_pattern extended regex list extended regular expressions specifies rows retain. Default pattern (\"$^\") retains nothing. remove_pattern extended regex list extended regular expressions specifies rows remove, Default pattern (\"$^\") removes nothing.","code":""},{"path":"/reference/select_rows_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select (or de-select) rows of a matrix (or list of matrices) by name — select_rows_byname","text":"matrix subset m rows selected retain_pattern remove_pattern.","code":""},{"path":"/reference/select_rows_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select (or de-select) rows of a matrix (or list of matrices) by name — select_rows_byname","text":"NULL, NULL returned. Patterns compared row names using extended regex. row names match retain_pattern, NULL returned. row names match remove_pattern, m returned. Note default retain_pattern remove_pattern (\"$^\") retain nothing remove nothing. Retaining rows takes precedence removing rows, always. typical patterns : \"^Electricity$|^Oil$\": row names EXACTLY \"Electricity\" EXACTLY \"Oil\". \"^Electricity|^Oil\": row names START \"Electricity\" START \"Oil\". \"Electricity|Oil\": row names CONTAIN \"Electricity\" CONTAIN \"Oil\" anywhere within . Given list row names, pattern can constructed easily using RCLabels::make_or_pattern(). RCLabels::make_or_pattern() escapes regex strings using Hmisc::escapeRegex(). function assumes retain_pattern remove_pattern already suitably escaped. Note rows removed , NULL returned.","code":""},{"path":"/reference/select_rows_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select (or de-select) rows of a matrix (or list of matrices) by name — select_rows_byname","text":"","code":"m <- matrix(1:16, ncol = 4, dimnames = list(c(paste0(\"i\", 1:4)), paste0(\"p\", 1:4))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") select_rows_byname(m,                     retain_pattern = RCLabels::make_or_pattern(c(\"i1\", \"i4\"),                    pattern_type = \"exact\")) #>    p1 p2 p3 p4 #> i1  1  5  9 13 #> i4  4  8 12 16 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" select_rows_byname(m,                     remove_pattern = RCLabels::make_or_pattern(c(\"i1\", \"i3\"),                     pattern_type = \"exact\")) #>    p1 p2 p3 p4 #> i2  2  6 10 14 #> i4  4  8 12 16 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" # Also works for lists and data frames select_rows_byname(list(m, m), retain_pattern = \"^i1$|^i4$\") #> [[1]] #>    p1 p2 p3 p4 #> i1  1  5  9 13 #> i4  4  8 12 16 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    p1 p2 p3 p4 #> i1  1  5  9 13 #> i4  4  8 12 16 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>"},{"path":"/reference/selectzerocols_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Select zero columns — selectzerocols_byname","title":"Select zero columns — selectzerocols_byname","text":"Matrices columns containing zeroes invertible (singular). diagnose problem, useful find zero columns singular matrix. function selects (extracts) zero columns matrix.","code":""},{"path":"/reference/selectzerocols_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select zero columns — selectzerocols_byname","text":"","code":"selectzerocols_byname(a, tol = 1e-06)"},{"path":"/reference/selectzerocols_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select zero columns — selectzerocols_byname","text":"matrix list matrices. tol allowable deviation 0 element.","code":""},{"path":"/reference/selectzerocols_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select zero columns — selectzerocols_byname","text":"zero columns selected.","code":""},{"path":"/reference/selectzerocols_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select zero columns — selectzerocols_byname","text":"column said zero column elements within tol zero.","code":""},{"path":"/reference/selectzerocols_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select zero columns — selectzerocols_byname","text":"","code":"m <- matrix(c(1, 0, 1,               1, 0, 1),             dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\", \"c3\")),              nrow = 2, ncol = 3, byrow = TRUE) %>%    setrowtype(\"rows\") %>% setcoltype(\"cols\") selectzerocols_byname(m) #>    c2 #> r1  0 #> r2  0 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\""},{"path":"/reference/selectzerorows_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Select zero rows — selectzerorows_byname","title":"Select zero rows — selectzerorows_byname","text":"Matrices rows containing zeroes invertible (singular). diagnose problem, useful find zero rows singular matrix. function selects (extracts) zero rows matrix.","code":""},{"path":"/reference/selectzerorows_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select zero rows — selectzerorows_byname","text":"","code":"selectzerorows_byname(a, tol = 1e-06)"},{"path":"/reference/selectzerorows_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select zero rows — selectzerorows_byname","text":"matrix list matrices. tol allowable deviation 0 element.","code":""},{"path":"/reference/selectzerorows_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select zero rows — selectzerorows_byname","text":"zero rows selected.","code":""},{"path":"/reference/selectzerorows_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select zero rows — selectzerorows_byname","text":"row said zero row elements within tol zero.","code":""},{"path":"/reference/selectzerorows_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select zero rows — selectzerorows_byname","text":"","code":"m <- matrix(c(0, 0, 1,               0, 0, 0),              dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\", \"c3\")),              nrow = 2, ncol = 3, byrow = TRUE) %>%    setrowtype(\"rows\") %>% setcoltype(\"cols\") m #>    c1 c2 c3 #> r1  0  0  1 #> r2  0  0  0 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\" selectzerorows_byname(m) #>    c1 c2 c3 #> r2  0  0  0 #> attr(,\"rowtype\") #> [1] \"rows\" #> attr(,\"coltype\") #> [1] \"cols\""},{"path":"/reference/setcolnames_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Sets column names — setcolnames_byname","title":"Sets column names — setcolnames_byname","text":"Sets column names way amenable use piping operations functional programming way. NULL, NULL returned. constant, converted matrix colnames applied. matrix, colnames vector new column names long number columns . list matrices, colnames can also list, long . colnames can vector column names applied every matrix list . item list vector containing column names corresponding matrix .","code":""},{"path":"/reference/setcolnames_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sets column names — setcolnames_byname","text":"","code":"setcolnames_byname(a, colnames)"},{"path":"/reference/setcolnames_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sets column names — setcolnames_byname","text":"matrix list matrices column names set colnames vector new column names list vectors new column names","code":""},{"path":"/reference/setcolnames_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sets column names — setcolnames_byname","text":"copy new column names","code":""},{"path":"/reference/setcolnames_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sets column names — setcolnames_byname","text":"","code":"m <- matrix(c(1:6), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:3))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") setcolnames_byname(m, c(\"a\", \"b\", \"c\")) #>    a b c #> i1 1 3 5 #> i2 2 4 6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\""},{"path":"/reference/setcoltype.html","id":null,"dir":"Reference","previous_headings":"","what":"Sets column type for a matrix or a list of matrices — setcoltype","title":"Sets column type for a matrix or a list of matrices — setcoltype","text":"function wrapper attr() setting can accomplished pipe operator (%>%). Column types strings stored coltype attribute.","code":""},{"path":"/reference/setcoltype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sets column type for a matrix or a list of matrices — setcoltype","text":"","code":"setcoltype(a, coltype)"},{"path":"/reference/setcoltype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sets column type for a matrix or a list of matrices — setcoltype","text":"matrix column type set. coltype type item stored columns.","code":""},{"path":"/reference/setcoltype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sets column type for a matrix or a list of matrices — setcoltype","text":"coltype attribute set.","code":""},{"path":"/reference/setcoltype.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sets column type for a matrix or a list of matrices — setcoltype","text":".null(coltype), coltype attribute deleted subsequent calls coltype return NULL.","code":""},{"path":"/reference/setcoltype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sets column type for a matrix or a list of matrices — setcoltype","text":"","code":"library(dplyr) commoditynames <- c(\"c1\", \"c2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) U %>% setcoltype(\"Industries\") #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\" # This also works for lists setcoltype(list(U,U), coltype = \"Industries\") #> [[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\" #>  setcoltype(list(U,U), coltype = list(\"Industries\", \"Industries\")) #> [[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- data.frame(U = I(list())) DF[[1,\"U\"]] <- U DF[[2,\"U\"]] <- U setcoltype(DF$U, \"Industries\") #> [[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- DF %>% mutate(newcol = setcoltype(U, \"Industries\")) DF$newcol[[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\" DF$newcol[[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"coltype\") #> [1] \"Industries\""},{"path":"/reference/setrownames_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Sets row names — setrownames_byname","title":"Sets row names — setrownames_byname","text":"Sets row names way amenable use piping operations functional programming way. NULL, NULL returned. constant, converted matrix rownames applied. matrix, rownames vector new row names long number rows . list matrices, rownames can also list, long . rownames can vector row names applied every matrix list . item list vector containing row names corresponding matrix .","code":""},{"path":"/reference/setrownames_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sets row names — setrownames_byname","text":"","code":"setrownames_byname(a, rownames)"},{"path":"/reference/setrownames_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sets row names — setrownames_byname","text":"matrix list matrices row names set rownames vector new row names list vectors new row names","code":""},{"path":"/reference/setrownames_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sets row names — setrownames_byname","text":"copy m new row names","code":""},{"path":"/reference/setrownames_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sets row names — setrownames_byname","text":"","code":"library(dplyr) m <- matrix(c(1:6), nrow = 2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:3))) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Commodities\") setrownames_byname(m, c(\"a\", \"b\")) #>   c1 c2 c3 #> a  1  3  5 #> b  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" setrownames_byname(m %>% setrowtype(\"Industries\") %>% setcoltype(\"Commodities\"), c(\"c\", \"d\")) #>   c1 c2 c3 #> c  1  3  5 #> d  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" m %>% setrownames_byname(NULL) #>      c1 c2 c3 #> [1,]  1  3  5 #> [2,]  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" m %>% setrownames_byname(c(NA, NA)) #>      c1 c2 c3 #> <NA>  1  3  5 #> <NA>  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" 2 %>% setrownames_byname(\"row\") #>     [,1] #> row    2 # This also works for lists setrownames_byname(list(m,m), list(c(\"a\", \"b\"))) #> [[1]] #>   c1 c2 c3 #> a  1  3  5 #> b  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>   c1 c2 c3 #> a  1  3  5 #> b  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  DF <- data.frame(m = I(list())) DF[[1,\"m\"]] <- m DF[[2,\"m\"]] <- m setrownames_byname(DF$m, list(c(\"r1\", \"r2\"))) #> [[1]] #>    c1 c2 c3 #> r1  1  3  5 #> r2  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>    c1 c2 c3 #> r1  1  3  5 #> r2  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  setrownames_byname(DF$m, list(c(\"c\", \"d\"))) #> [[1]] #>   c1 c2 c3 #> c  1  3  5 #> d  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  #> [[2]] #>   c1 c2 c3 #> c  1  3  5 #> d  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\" #>  DF <- DF %>% mutate(m = setrownames_byname(m, list(c(\"r1\", \"r2\")))) DF$m[[1]] #>    c1 c2 c3 #> r1  1  3  5 #> r2  2  4  6 #> attr(,\"rowtype\") #> [1] \"Industries\" #> attr(,\"coltype\") #> [1] \"Commodities\""},{"path":"/reference/setrowtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Sets row type for a matrix or a list of matrices — setrowtype","title":"Sets row type for a matrix or a list of matrices — setrowtype","text":"function wrapper attr() setting can accomplished pipe operator (%>%). Row types strings stored rowtype attribute.","code":""},{"path":"/reference/setrowtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sets row type for a matrix or a list of matrices — setrowtype","text":"","code":"setrowtype(a, rowtype)"},{"path":"/reference/setrowtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sets row type for a matrix or a list of matrices — setrowtype","text":"matrix row type set. rowtype type item stored rows.","code":""},{"path":"/reference/setrowtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sets row type for a matrix or a list of matrices — setrowtype","text":"rowtype attribute set rowtype.","code":""},{"path":"/reference/setrowtype.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sets row type for a matrix or a list of matrices — setrowtype","text":".null(rowtype), rowtype attribute deleted subsequent calls rowtype return NULL.","code":""},{"path":"/reference/setrowtype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sets row type for a matrix or a list of matrices — setrowtype","text":"","code":"library(dplyr) commoditynames <- c(\"c1\", \"c2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) U %>% setrowtype(\"Commodities\") #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" # This also works for lists setrowtype(list(U,U), rowtype = \"Commodities\") #> [[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #>  #> [[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #>  setrowtype(list(U,U), rowtype = list(\"Commodities\", \"Commodities\")) #> [[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #>  #> [[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #>  DF <- data.frame(U = I(list())) DF[[1,\"U\"]] <- U DF[[2,\"U\"]] <- U setrowtype(DF$U, \"Commodities\") #> [[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #>  #> [[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" #>  DF <- DF %>% mutate(newcol = setrowtype(U, \"Commodities\")) DF$newcol[[1]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\" DF$newcol[[2]] #>    i1 i2 #> c1  1  3 #> c2  2  4 #> attr(,\"rowtype\") #> [1] \"Commodities\""},{"path":"/reference/sort_rows_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Sorts rows and columns of a matrix — sort_rows_cols","title":"Sorts rows and columns of a matrix — sort_rows_cols","text":"Checks row names unique column names unique. , sorts rows columns way ensures matrix row column names order.","code":""},{"path":"/reference/sort_rows_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sorts rows and columns of a matrix — sort_rows_cols","text":"","code":"sort_rows_cols(a, margin = c(1, 2), roworder = NA, colorder = NA)"},{"path":"/reference/sort_rows_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sorts rows and columns of a matrix — sort_rows_cols","text":"matrix data frame whose rows columns sorted. margin Specifies subscript(s) sorting occur. margin nearly semantic meaning base::apply. rows , give 1; columns , give 2; rows columns, give c(1,2), default value. roworder Specifies order rows default sort(rownames()). NA (default), default sort order used. Unspecified rows removed output, thus providing way delete rows . Extraneous row names (row names roworder appear ) ignored. colorder Specifies order rows default sort(colnames()). NA (default), default sort order used. Unspecified columns removed output, thus providing way delete columns . Extraneous column names (column names colorder appear ) ignored.","code":""},{"path":"/reference/sort_rows_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sorts rows and columns of a matrix — sort_rows_cols","text":"modified version sorted rows columns","code":""},{"path":"/reference/sort_rows_cols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sorts rows and columns of a matrix — sort_rows_cols","text":"Default sort order given base::sort() decreasing = FALSE.","code":""},{"path":"/reference/sort_rows_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sorts rows and columns of a matrix — sort_rows_cols","text":"","code":"m <- matrix(c(1:6), nrow=3, dimnames = list(c(\"r3\", \"r5\", \"r1\"), c(\"c4\", \"c2\"))) sort_rows_cols(m) #>    c2 c4 #> r1  6  3 #> r3  4  1 #> r5  5  2 sort_rows_cols(t(m)) #>    r1 r3 r5 #> c2  6  4  5 #> c4  3  1  2 sort_rows_cols(m, margin=1) # Sorts rows #>    c4 c2 #> r1  3  6 #> r3  1  4 #> r5  2  5 sort_rows_cols(m, margin=2) # Sorts columns #>    c2 c4 #> r3  4  1 #> r5  5  2 #> r1  6  3 v <- matrix(c(1:5), ncol=1, dimnames=list(rev(paste0(\"r\", 1:5)), \"c1\")) # Column vector sort_rows_cols(v) #>    c1 #> r1  5 #> r2  4 #> r3  3 #> r4  2 #> r5  1 sort_rows_cols(v, margin = 1) # Sorts rows #>    c1 #> r1  5 #> r2  4 #> r3  3 #> r4  2 #> r5  1 sort_rows_cols(v, margin = 2) # No effect: only one column #>    c1 #> r5  1 #> r4  2 #> r3  3 #> r2  4 #> r1  5 r <- matrix(c(1:4), nrow=1, dimnames=list(\"r1\", rev(paste0(\"c\", 1:4)))) # Row vector sort_rows_cols(r) # Sorts columns #>    c1 c2 c3 c4 #> r1  4  3  2  1 n <- matrix(c(1,2), nrow = 1, dimnames = list(NULL, c(\"c2\", \"c1\"))) # No row name sort_rows_cols(n) # Sorts columns, because only one row. #>      c1 c2 #> [1,]  2  1 # Also works with lists sort_rows_cols(list(m,m)) # Sorts rows and columns for both m's. #> [[1]] #>    c4 c2 #> r1  3  6 #> r3  1  4 #> r5  2  5 #>  #> [[2]] #>    c2 c4 #> r3  4  1 #> r5  5  2 #> r1  6  3 #>  # Sort rows only for first one, sort rows and columns for second one.   # Row order is applied to all m's.  Column order is natural. sort_rows_cols(a = list(m,m), margin = 1, roworder = list(c(\"r5\", \"r3\", \"r1\"))) #> [[1]] #>    c4 c2 #> r5  2  5 #> r3  1  4 #> r1  3  6 #>  #> [[2]] #>    c4 c2 #> r5  2  5 #> r3  1  4 #> r1  3  6 #>  # Columns are sorted as default, because no colorder is given. # roworder is ignored.  sort_rows_cols(a = list(m,m), margin = 2, roworder = list(c(\"r5\", \"r3\", \"r1\"))) #> [[1]] #>    c2 c4 #> r3  4  1 #> r5  5  2 #> r1  6  3 #>  #> [[2]] #>    c2 c4 #> r3  4  1 #> r5  5  2 #> r1  6  3 #>  # Both columns and rows sorted, rows by the list, columns in natural order. sort_rows_cols(a = list(m,m), margin = c(1,2), roworder = list(c(\"r5\", \"r3\", \"r1\"))) #> [[1]] #>    c4 c2 #> r5  2  5 #> r3  1  4 #> r1  3  6 #>  #> [[2]] #>    c2 c4 #> r3  4  1 #> r5  5  2 #> r1  6  3 #>"},{"path":"/reference/sum_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Name-wise addition of matrices — sum_byname","title":"Name-wise addition of matrices — sum_byname","text":"Performs union sorting addend augend row column names prior summation. Zeroes inserted missing matrix elements. Treats missing NULL operands 0.","code":""},{"path":"/reference/sum_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name-wise addition of matrices — sum_byname","text":"","code":"sum_byname(..., .summarise = FALSE)"},{"path":"/reference/sum_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name-wise addition of matrices — sum_byname","text":"... Operands: constants, matrices, lists matrices. .summarise TRUE, operands summed lists. FALSE (default), items summed across lists.","code":""},{"path":"/reference/sum_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name-wise addition of matrices — sum_byname","text":"matrix representing name-wise sum arguments.","code":""},{"path":"/reference/sum_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Name-wise addition of matrices — sum_byname","text":"function, list lists operands ambiguous. operands summed across lists (first items summed across lists, second items summed across list, etc.) list summed along list? first case, return object length equal length lists ... argument. second case, return object length equal number lists ... argument. first case like summing across rows data frame. second case like summing columns data frame. summarise argument distinguishes two cases. default value summarise FALSE, giving first behavior. Set summarise TRUE cause function act like dplyr::summarise() list arguments. .summarise = TRUE, data value guaranteed list. call sum_byname(.summarise = TRUE) made context data frame, column returned guaranteed list column. See aggregation vignette additional details examples.","code":""},{"path":"/reference/sum_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name-wise addition of matrices — sum_byname","text":"","code":"library(dplyr) sum_byname(2, 2) #> [1] 4 sum_byname(2, 2, 2) #> [1] 6 sum_byname(2, 2, -2, -2) #> [1] 0 productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") Y <- matrix(1:4, ncol = 2, dimnames = list(rev(productnames), rev(industrynames))) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") sum_byname(U, 100) #>     i1  i2 #> p1 101 103 #> p2 102 104 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" sum_byname(200, Y) #>     i1  i2 #> p1 204 202 #> p2 203 201 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" U + Y # Non-sensical.  Row and column names not respected. #>    i1 i2 #> p1  2  6 #> p2  4  8 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" sum_byname(U, U) #>    i1 i2 #> p1  2  6 #> p2  4  8 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" sum_byname(U, Y) #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" sum_byname(U, U, Y, Y) #>    i1 i2 #> p1 10 10 #> p2 10 10 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" V <- matrix(1:4, ncol = 2, dimnames = list(industrynames, productnames)) %>%   setrowtype(\"Industries\") %>% setcoltype(\"Products\") U + V # row and column names are non-sensical and blindly taken from first argument (U) #>    i1 i2 #> p1  2  6 #> p2  4  8 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" if (FALSE) sum_byname(U, V) # Fails, because row and column types are different # This also works with lists sum_byname(list(U,U), list(Y,Y)) #> [[1]] #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  sum_byname(list(U,U), list(100,100)) #> [[1]] #>     i1  i2 #> p1 101 103 #> p2 102 104 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>     i1  i2 #> p1 101 103 #> p2 102 104 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  sum_byname(list(U,U), as.list(rep_len(100, 2))) #> [[1]] #>     i1  i2 #> p1 101 103 #> p2 102 104 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>     i1  i2 #> p1 101 103 #> p2 102 104 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF <- data.frame(U = I(list()), Y = I(list())) DF[[1,\"U\"]] <- U DF[[2,\"U\"]] <- U DF[[1,\"Y\"]] <- Y DF[[2,\"Y\"]] <- Y sum_byname(DF$U, DF$Y) #> [[1]] #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF %>% mutate(sums = sum_byname(U, Y)) #>            U          Y       sums #> 1 1, 2, 3, 4 1, 2, 3, 4 5, 5, 5, 5 #> 2 1, 2, 3, 4 1, 2, 3, 4 5, 5, 5, 5 sum_byname(U) # If only one argument, return it. #>    i1 i2 #> p1  1  3 #> p2  2  4 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" sum_byname(2, NULL) # Gives 2 #> [1] 2 sum_byname(2, NA)   # Gives NA #> [1] NA sum_byname(NULL, 1) # Gives 1 #> [1] 1 sum_byname(list(NULL, 1), list(1, 1)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  DF2 <- data.frame(U = I(list()), Y = I(list())) DF2[[1,\"U\"]] <- NULL DF2[[2,\"U\"]] <- U DF2[[1,\"Y\"]] <- Y DF2[[2,\"Y\"]] <- Y sum_byname(DF2$U, DF2$Y) #> [[1]] #>    i1 i2 #> p1  4  2 #> p2  3  1 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  #> [[2]] #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" #>  DF3 <- DF2 %>% mutate(sums = sum_byname(U, Y)) DF3 #>            U          Y       sums #> 1            1, 2, 3, 4 4, 3, 2, 1 #> 2 1, 2, 3, 4 1, 2, 3, 4 5, 5, 5, 5 DF3$sums[[1]] #>    i1 i2 #> p1  4  2 #> p2  3  1 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" DF3$sums[[2]] #>    i1 i2 #> p1  5  5 #> p2  5  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\""},{"path":"/reference/sumall_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Sum of all elements in a matrix — sumall_byname","title":"Sum of all elements in a matrix — sumall_byname","text":"function equivalent \\%>\\% rowsums_byname() \\%>\\% colsums_byname(), returns single numeric value instead 1x1 matrix.","code":""},{"path":"/reference/sumall_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sum of all elements in a matrix — sumall_byname","text":"","code":"sumall_byname(a)"},{"path":"/reference/sumall_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sum of all elements in a matrix — sumall_byname","text":"matrix whose elements summed.","code":""},{"path":"/reference/sumall_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sum of all elements in a matrix — sumall_byname","text":"sum elements numeric.","code":""},{"path":"/reference/sumall_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sum of all elements in a matrix — sumall_byname","text":"","code":"library(dplyr) sumall_byname(42) #> [1] 42 m <- matrix(2, nrow=2, ncol=2, dimnames = list(paste0(\"i\", 1:2), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industry\") %>% setcoltype(\"Commodity\") m #>    c1 c2 #> i1  2  2 #> i2  2  2 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\" sumall_byname(m) #> [1] 8 rowsums_byname(m) %>% colsums_byname #>          Commodity #> Industry         8 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\" # Also works for lists sumall_byname(list(m,m)) #> [[1]] #> [1] 8 #>  #> [[2]] #> [1] 8 #>  DF <- data.frame(m = I(list())) DF[[1,\"m\"]] <- m DF[[2,\"m\"]] <- m sumall_byname(DF$m[[1]]) #> [1] 8 sumall_byname(DF$m) #> [[1]] #> [1] 8 #>  #> [[2]] #> [1] 8 #>  res <- DF %>% mutate(   sums = sumall_byname(m) ) res$sums #> [[1]] #> [1] 8 #>  #> [[2]] #> [1] 8 #>  sumall_byname(list(m, NULL)) #> [[1]] #> [1] 8 #>  #> [[2]] #> NULL #>"},{"path":"/reference/svd_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the singular value decomposition of a matrix — svd_byname","title":"Calculate the singular value decomposition of a matrix — svd_byname","text":"singular value decomposition decomposes matrix = U D V^T, U V orthogonal matrices D diagonal matrix. U left singular vectors . V right singular vectors .","code":""},{"path":"/reference/svd_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the singular value decomposition of a matrix — svd_byname","text":"","code":"svd_byname(a, which = c(\"d\", \"u\", \"v\"))"},{"path":"/reference/svd_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the singular value decomposition of a matrix — svd_byname","text":"matrix decomposed. matrix returned. Default \"d\". See details.","code":""},{"path":"/reference/svd_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the singular value decomposition of a matrix — svd_byname","text":"matrix singular value decomposition .","code":""},{"path":"/reference/svd_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the singular value decomposition of a matrix — svd_byname","text":"determines part singular value decomposition returned. \"d\" (default) gives D matrix. \"u\" gives U matrix. \"v\" gives V matrix (transpose).","code":""},{"path":"/reference/svd_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the singular value decomposition of a matrix — svd_byname","text":"","code":"A = matrix(c(4, 0,               3, -5), nrow = 2, ncol = 2, byrow = TRUE,             dimnames = list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\"))) %>%    setrowtype(\"Product\") %>% setcoltype(\"Industry\") A #>    c1 c2 #> r1  4  0 #> r2  3 -5 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" svd_byname(A) # Gives D matrix, by default #>          c1       c2 #> r1 6.324555 0.000000 #> r2 0.000000 3.162278 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" svd_byname(A, which = \"d\") #>          c1       c2 #> r1 6.324555 0.000000 #> r2 0.000000 3.162278 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" svd_byname(A, which = \"u\") #>            r1         r2 #> r1 -0.4472136 -0.8944272 #> r2 -0.8944272  0.4472136 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Product\" svd_byname(A, which = \"v\") #>            c1         c2 #> c1 -0.7071068 -0.7071068 #> c2  0.7071068 -0.7071068 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Industry\""},{"path":"/reference/switch_notation_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Change row and column name notation — switch_notation_byname","title":"Change row and column name notation — switch_notation_byname","text":"function switches matrix row /column names one type notation another based arguments. Optionally, prefix suffix can flipped.","code":""},{"path":"/reference/switch_notation_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change row and column name notation — switch_notation_byname","text":"","code":"switch_notation_byname(a, margin = c(1, 2), from, to, flip = FALSE)"},{"path":"/reference/switch_notation_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change row and column name notation — switch_notation_byname","text":"matrix list matrices whose row /column notation changed. margin 1 rows, 2 columns, c(1, 2) rows columns. Default c(1, 2). notation switch away . notation switch . flip boolean tells whether also flip notation. Default FALSE.","code":""},{"path":"/reference/switch_notation_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change row and column name notation — switch_notation_byname","text":"Matrices row column names switched notation, per arguments.","code":""},{"path":"/reference/switch_notation_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change row and column name notation — switch_notation_byname","text":"","code":"m <- matrix(c(1, 2,                3, 4), nrow = 2, ncol = 2, byrow = TRUE,              dimnames = list(c(\"b [a]\", \"d [c]\"), c(\"f [e]\", \"h [g]\"))) %>%    setrowtype(\"Products [Industries]\") %>% setcoltype(\"Industries [Products]\") m #>       f [e] h [g] #> b [a]     1     2 #> d [c]     3     4 #> attr(,\"rowtype\") #> [1] \"Products [Industries]\" #> attr(,\"coltype\") #> [1] \"Industries [Products]\" switch_notation_byname(m, from = RCLabels::bracket_notation, to = RCLabels::arrow_notation,                         flip = TRUE) #>        e -> f g -> h #> a -> b      1      2 #> c -> d      3      4 #> attr(,\"rowtype\") #> [1] \"Industries -> Products\" #> attr(,\"coltype\") #> [1] \"Products -> Industries\" # Also works for lists. # Note that margin must be specified as a list here. switch_notation_byname(list(m, m), margin = list(c(1, 2)),                         from = RCLabels::bracket_notation,                         to = RCLabels::arrow_notation, flip = TRUE) #> [[1]] #>        e -> f g -> h #> a -> b      1      2 #> c -> d      3      4 #> attr(,\"rowtype\") #> [1] \"Industries -> Products\" #> attr(,\"coltype\") #> [1] \"Products -> Industries\" #>  #> [[2]] #>        e -> f g -> h #> a -> b      1      2 #> c -> d      3      4 #> attr(,\"rowtype\") #> [1] \"Industries -> Products\" #> attr(,\"coltype\") #> [1] \"Products -> Industries\" #>"},{"path":"/reference/transpose_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose a matrix by name — transpose_byname","title":"Transpose a matrix by name — transpose_byname","text":"Gives transpose matrix list matrices.","code":""},{"path":"/reference/transpose_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose a matrix by name — transpose_byname","text":"","code":"transpose_byname(a)"},{"path":"/reference/transpose_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose a matrix by name — transpose_byname","text":"matrix transposed.","code":""},{"path":"/reference/transpose_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transpose a matrix by name — transpose_byname","text":"transposed matrix.","code":""},{"path":"/reference/transpose_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transpose a matrix by name — transpose_byname","text":"","code":"m <- matrix(c(11,21,31,12,22,32), ncol = 2, dimnames = list(paste0(\"i\", 1:3), paste0(\"c\", 1:2))) %>%   setrowtype(\"Industry\") %>% setcoltype(\"Commodity\") m #>    c1 c2 #> i1 11 12 #> i2 21 22 #> i3 31 32 #> attr(,\"rowtype\") #> [1] \"Industry\" #> attr(,\"coltype\") #> [1] \"Commodity\" transpose_byname(m) #>    i1 i2 i3 #> c1 11 21 31 #> c2 12 22 32 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Industry\" transpose_byname(list(m,m)) #> [[1]] #>    i1 i2 i3 #> c1 11 21 31 #> c2 12 22 32 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Industry\" #>  #> [[2]] #>    i1 i2 i3 #> c1 11 21 31 #> c2 12 22 32 #> attr(,\"rowtype\") #> [1] \"Commodity\" #> attr(,\"coltype\") #> [1] \"Industry\" #>"},{"path":"/reference/trim_rows_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Trim rows and/or columns from a matrix — trim_rows_cols","title":"Trim rows and/or columns from a matrix — trim_rows_cols","text":"default, matsbyname package expends matrices 0 rows columns prior matrix operations ensure rows columns match. times trimming rows columns preferred default behavior. function trims rows columns match rows columns mat. return value rows columns removed appear mat.","code":""},{"path":"/reference/trim_rows_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trim rows and/or columns from a matrix — trim_rows_cols","text":"","code":"trim_rows_cols(   a = NULL,   mat = NULL,   margin = c(1, 2),   warn_if_a_incomplete = TRUE,   a_piece = \"all\",   mat_piece = \"all\",   notation = RCLabels::bracket_notation,   prepositions = RCLabels::prepositions_list )"},{"path":"/reference/trim_rows_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trim rows and/or columns from a matrix — trim_rows_cols","text":"matrix trimmed. mat matrix margin dimension trimmed. 1 means rows; 2 means columns. Default c(1,2). warn_if_a_incomplete TRUE (default), warning emitted missing entries margin present mat. a_piece portion labels used comparison. Default \"\". mat_piece portion mat labels used comparison. Default \"\". notation notation row column labels. Default RCLabels::bracket_notation. prepositions strings treated prepositions row column labels. Default RCLabels::prepositions_list.","code":""},{"path":"/reference/trim_rows_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trim rows and/or columns from a matrix — trim_rows_cols","text":"Matrix rows columns trimmed match mat.","code":""},{"path":"/reference/trim_rows_cols.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Trim rows and/or columns from a matrix — trim_rows_cols","text":"NULL, NULL returned. mat NULL, returned unmodified. mat NULL dimnames, returned unmodified. mat NULL dimnames margin, error returned. common use case function trim , many entries margins compared mat. trimming result smaller result mathematical operations involving mat. Typically, cover entries mat margin. Thus, default, function warns missing entries margin present mat. turn checking behavior, set warn_if_a_incomplete = FALSE. a_piece mat_piece control part row column names compared trimming. default values a_piece mat_piece \"\", meaning entire label matched. options a_piece mat_piece \"pref\" \"suff\", match prefix suffix labels. Alternatively, prepositions can given objects prepositions matched. Examples include \"\" \"\".","code":""},{"path":[]},{"path":"/reference/trim_rows_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trim rows and/or columns from a matrix — trim_rows_cols","text":"","code":"a <- matrix(c(1, 2, 3,                4, 5, 6,                7, 8, 9), nrow = 3, ncol = 3, byrow = TRUE,              dimnames = list(c(\"r1\", \"r2\", \"r3\"), c(\"c1\", \"c2\", \"c3\"))) %>%   setrowtype(\"rowtype\") %>% setcoltype(\"coltype\") mat <- matrix(c(1, 2, 3,                 4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE,              dimnames = list(c(\"r1\", \"bogus\"), c(\"c1\", \"bogus\", \"c2\"))) %>%   setrowtype(\"rowtype\") %>% setcoltype(\"coltype\") trim_rows_cols(a, mat, margin = 1) #> Warning: In trim_rows_cols, 'a' is missing the following rows or columns relative to 'mat': bogus #>    c1 c2 c3 #> r1  1  2  3 #> attr(,\"rowtype\") #> [1] \"rowtype\" #> attr(,\"coltype\") #> [1] \"coltype\" trim_rows_cols(a, mat, margin = 2) #> Warning: In trim_rows_cols, 'a' is missing the following rows or columns relative to 'mat': bogus #>    c1 c2 #> r1  1  2 #> r2  4  5 #> r3  7  8 #> attr(,\"rowtype\") #> [1] \"rowtype\" #> attr(,\"coltype\") #> [1] \"coltype\" trim_rows_cols(a, mat) #> Warning: In trim_rows_cols, 'a' is missing the following rows or columns relative to 'mat': bogus #> Warning: In trim_rows_cols, 'a' is missing the following rows or columns relative to 'mat': bogus #>    c1 c2 #> r1  1  2 #> attr(,\"rowtype\") #> [1] \"rowtype\" #> attr(,\"coltype\") #> [1] \"coltype\""},{"path":"/reference/unaryapply_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a unary function by name — unaryapply_byname","title":"Apply a unary function by name — unaryapply_byname","text":"FUN applied using additional arguments .FUNdots FUN. list, names applied output.","code":""},{"path":"/reference/unaryapply_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a unary function by name — unaryapply_byname","text":"","code":"unaryapply_byname(   FUN,   a,   .FUNdots = NULL,   rowcoltypes = c(\"all\", \"transpose\", \"row\", \"col\", \"none\") )"},{"path":"/reference/unaryapply_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a unary function by name — unaryapply_byname","text":"FUN unary function applied \"name\" . argument FUN. .FUNdots list additional named arguments passed FUN. rowcoltypes string tells transfer row column types output. See details.","code":""},{"path":"/reference/unaryapply_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a unary function by name — unaryapply_byname","text":"result applying FUN \"name\" .","code":""},{"path":"/reference/unaryapply_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a unary function by name — unaryapply_byname","text":"Note .FUNdots can rectangular two-dimensional list arguments FUN. , .FUNdots interpreted follows: first dimension .FUNdots contains named arguments FUN. second dimension .FUNdots contains unique values named arguments applied along list . length first dimension .FUNdots number arguments supplied FUN. length second dimension .FUNdots must equal length . See prepare_.FUNdots() details .FUNdots argument. Options rowcoltypes argument : \"\": transfer row column types directly output. \"transpose\": rowtype becomes coltype output; coltype becomes rowtype output. \"transpose\" helpful FUNs transpose upon output. \"row\": rowtype becomes rowtype coltype output. \"col\": coltype becomes rowtype coltype output. \"none\": rowtype coltype set unaryapply_byname. Rather, FUN set rowtype coltype. Note rowcoltypes vector list strings. Rather, single string.","code":""},{"path":"/reference/unaryapply_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a unary function by name — unaryapply_byname","text":"","code":"productnames <- c(\"p1\", \"p2\") industrynames <- c(\"i1\", \"i2\") U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %>%   setrowtype(\"Products\") %>% setcoltype(\"Industries\") difference_byname(0, U) #>    i1 i2 #> p1 -1 -3 #> p2 -2 -4 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" unaryapply_byname(`-`, U) #>    i1 i2 #> p1 -1 -3 #> p2 -2 -4 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\""},{"path":"/reference/vec_from_store_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a vector with labels from a matrix and values from a vector store — vec_from_store_byname","title":"Create a vector with labels from a matrix and values from a vector store — vec_from_store_byname","text":"matrix multiplied vector byname, naming can tricky. times pieces vector labels matched pieces matrix labels. function helps performing matching byname. function, vector v considered store values output vector created using special matching rules v.","code":""},{"path":"/reference/vec_from_store_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a vector with labels from a matrix and values from a vector store — vec_from_store_byname","text":"","code":"vec_from_store_byname(   a,   v,   a_piece = \"all\",   v_piece = \"all\",   colname = NULL,   column = TRUE,   notation = if (is.list(a)) {      list(RCLabels::bracket_notation)  } else {          RCLabels::bracket_notation  },   prepositions = if (is.list(a)) {      list(RCLabels::prepositions_list)  } else {          RCLabels::prepositions_list  },   missing = NA_real_ )"},{"path":"/reference/vec_from_store_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a vector with labels from a matrix and values from a vector store — vec_from_store_byname","text":"matrix row column labels taken. Can also list name column data frame. v vector values taken, a_piece matches v_piece. Can also list name column data frame. a_piece piece labels matched. Default \"\". v_piece piece labels v matched. Default \"\". colname name output vector's 1-sized dimension (column column TRUE, row otherwise). Default NULL, meaning name 1-sized dimension v used. column Tells whether column vector (TRUE, default) row vector (FALSE) created. notation notation row column labels. Default RCLabels::bracket_notation, wrapped list list. prepositions strings count prepositions. Default RCLabels::prepositions, wrapped list list. missing value used desired value found v. Default NA_real_.","code":""},{"path":"/reference/vec_from_store_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a vector with labels from a matrix and values from a vector store — vec_from_store_byname","text":"vector names values v.","code":""},{"path":"/reference/vec_from_store_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a vector with labels from a matrix and values from a vector store — vec_from_store_byname","text":"output function vector (column vector column TRUE, default; row vector column FALSE). label size = 1 dimension taken colname (named, default return column vector). labels long dimension taken matrix (row names column TRUE; column names column FALSE). values output vector obtained v a_piece matches v_piece using RCLabels package. v_pieces v must unique. default values a_piece v_piece \"\", meaning entire label matched. options a_piece v_piece \"pref\" \"suff\", match prefix suffix labels. Alternatively, prepositions can given objects prepositions matched. Examples include \"\" \"\". Row column types v applied output. piece given a_piece present row column names , NA_real_ returned. piece given v_piece present row column names v, NA_real_ returned. Note notation prepositions lists list single value otherwise. default values notation prepositions take care requirement, switching type (list ). class output object determined . Matrix, output Matrix. Otherwise, output matrix.","code":""},{"path":"/reference/vec_from_store_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a vector with labels from a matrix and values from a vector store — vec_from_store_byname","text":"","code":"a <- matrix(42, nrow = 3, ncol = 5,              dimnames = list(c(\"Electricity [from b in c]\",                                \"Coal [from e in f]\",                                \"Crude oil [from Production in USA]\"),                              c(\"Main activity producer electricity plants\",                                \"Wind turbines\",                                \"Oil refineries\",                                \"Coal mines\",                                \"Automobiles\"))) %>%   setrowtype(\"Product\") %>% setcoltype(\"Industry\") a #>                                    Main activity producer electricity plants #> Electricity [from b in c]                                                 42 #> Coal [from e in f]                                                        42 #> Crude oil [from Production in USA]                                        42 #>                                    Wind turbines Oil refineries Coal mines #> Electricity [from b in c]                     42             42         42 #> Coal [from e in f]                            42             42         42 #> Crude oil [from Production in USA]            42             42         42 #>                                    Automobiles #> Electricity [from b in c]                   42 #> Coal [from e in f]                          42 #> Crude oil [from Production in USA]          42 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"Industry\" v <- matrix(1:7, nrow = 7, ncol = 1,              dimnames = list(c(\"Electricity\",                                \"Peat\",                                \"Hydro\",                                \"Crude oil\",                               \"Coal\",                                \"Hard coal (if no detail)\",                                \"Brown coal\"),                              \"phi\")) %>%   setrowtype(\"Product\") %>% setcoltype(\"phi\") v #>                          phi #> Electricity                1 #> Peat                       2 #> Hydro                      3 #> Crude oil                  4 #> Coal                       5 #> Hard coal (if no detail)   6 #> Brown coal                 7 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"phi\" vec_from_store_byname(a, v, a_piece = \"pref\") #>                                    phi #> Electricity [from b in c]            1 #> Coal [from e in f]                   5 #> Crude oil [from Production in USA]   4 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"phi\" vec_from_store_byname(a, v, a_piece = \"noun\") #>                                    phi #> Electricity [from b in c]            1 #> Coal [from e in f]                   5 #> Crude oil [from Production in USA]   4 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"phi\"  v2 <- matrix(1:7, nrow = 7, ncol = 1,               dimnames = list(c(\"Electricity\",                                 \"Peat\",                                 \"USA\",                                 \"c\",                                \"Coal\",                                 \"Hard coal (if no detail)\",                                 \"f\"),                               \"phi\")) %>%   setrowtype(\"Product\") %>% setcoltype(\"phi\") vec_from_store_byname(a, v2, a_piece = \"in\") #>                                    phi #> Electricity [from b in c]            4 #> Coal [from e in f]                   7 #> Crude oil [from Production in USA]   3 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"phi\"  # Works with lists v3 <- matrix(1:7, nrow = 7, ncol = 1,               dimnames = list(c(\"Electricity [from USA]\",                                 \"Peat [from nowhere]\",                                 \"Production [from GHA]\",                                 \"e [from ZAF]\",                                \"Coal [from AUS]\",                                 \"Hard coal (if no detail) [from GBR]\",                                 \"b [from Nebraska]\"),                               \"phi\")) %>%   setrowtype(\"Product\") %>% setcoltype(\"phi\") a_list <- list(a, a) v_list <- list(v3, v3) vec_from_store_byname(a_list, v_list, a_piece = \"in\", v_piece = \"from\") #> [[1]] #>                                    phi #> Electricity [from b in c]           NA #> Coal [from e in f]                  NA #> Crude oil [from Production in USA]   1 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"phi\" #>  #> [[2]] #>                                    phi #> Electricity [from b in c]           NA #> Coal [from e in f]                  NA #> Crude oil [from Production in USA]   1 #> attr(,\"rowtype\") #> [1] \"Product\" #> attr(,\"coltype\") #> [1] \"phi\" #>   # Also works in a data frame df <- tibble::tibble(a = list(a, a, a),                       v = list(v3, v3, v3)) df %>%   dplyr::mutate(     actual = vec_from_store_byname(a = a, v = v, a_piece = \"in\", v_piece = \"from\")   ) #> # A tibble: 3 × 3 #>   a             v             actual        #>   <list>        <list>        <list>        #> 1 <dbl [3 × 5]> <int [7 × 1]> <dbl [3 × 1]> #> 2 <dbl [3 × 5]> <int [7 × 1]> <dbl [3 × 1]> #> 3 <dbl [3 × 5]> <int [7 × 1]> <dbl [3 × 1]>"},{"path":"/reference/vectorize_byname.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorize a matrix — vectorize_byname","title":"Vectorize a matrix — vectorize_byname","text":"Converts matrix column vector. element matrix becomes entry column vector, rows named via notation argument. Callers may want transpose matrix first transpose_byname().","code":""},{"path":"/reference/vectorize_byname.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorize a matrix — vectorize_byname","text":"","code":"vectorize_byname(a, notation)"},{"path":"/reference/vectorize_byname.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorize a matrix — vectorize_byname","text":"matrix vectorized. notation string vector created notation_vec().","code":""},{"path":"/reference/vectorize_byname.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorize a matrix — vectorize_byname","text":"column vector containing elements , row names assigned \"rowname sep colname\".","code":""},{"path":"/reference/vectorize_byname.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vectorize a matrix — vectorize_byname","text":"notation also applied rowtype coltype attributes.","code":""},{"path":"/reference/vectorize_byname.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorize a matrix — vectorize_byname","text":"","code":"m <- matrix(c(1, 5,               4, 5),             nrow = 2, ncol = 2, byrow = TRUE,              dimnames = list(c(\"p1\", \"p2\"), c(\"i1\", \"i2\"))) %>%    setrowtype(\"Products\") %>% setcoltype(\"Industries\") m #>    i1 i2 #> p1  1  5 #> p2  4  5 #> attr(,\"rowtype\") #> [1] \"Products\" #> attr(,\"coltype\") #> [1] \"Industries\" vectorize_byname(m, notation = RCLabels::arrow_notation) #>          [,1] #> p1 -> i1    1 #> p2 -> i1    4 #> p1 -> i2    5 #> p2 -> i2    5 #> attr(,\"rowtype\") #> [1] \"Products -> Industries\" # If a single number is provided, the number will be returned as a 1x1 column vector  # with some additional attributes. vectorize_byname(42, notation = RCLabels::arrow_notation) #>      [,1] #> [1,]   42 attributes(vectorize_byname(42, notation = RCLabels::arrow_notation)) #> $dim #> [1] 1 1 #>"},{"path":"/news/index.html","id":"matsbyname-062-2023-05-04","dir":"Changelog","previous_headings":"","what":"matsbyname 0.6.2 (2023-05-04)","title":"matsbyname 0.6.2 (2023-05-04)","text":"Move latest version GitHub test coverage workflow. version released CRAN. Still 2082 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-061-2023-04-25-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.6.1 (2023-04-25)","title":"matsbyname 0.6.1 (2023-04-25)","text":"CRAN release: 2023-04-25 equal_byname() gains tol argument control precision equality decided. Fixed bug equal_byname() wasn’t using equal_matrix_or_Matrix(). result, difficult tell whether matrix Matrix equal. Now 2082 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-060-2023-03-04-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.6.0 (2023-03-04)","title":"matsbyname 0.6.0 (2023-03-04)","text":"CRAN release: 2023-03-04 Fixed bug aggregate_pieces_byname() failure occurred repeated row (column) names included aggregation_map. functions now work Matrix objects, thereby enabling use sparse matrices. Use matsbyname::Matrix() create sparse matrices desired. create_matrix_byname() gains matrix.class argument tells whether created object class matrix Matrix. Default “matrix”. New function .Matrix() assists determining whether object Matrix. base functionis.matrix() assists determining whether object matrix. First function (sum_byname()) now works Matrix objects, paving way sparse matrix representation throughout matsbyname. tests, cleaned many warnings emanating change testthat v3. Reacted change grouping policy dplyr caused one test issue deprecation warning. Update latest GitHub actions continuous integration workflow. Now 2078 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-051-2023-01-16-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.5.1 (2023-01-16)","title":"matsbyname 0.5.1 (2023-01-16)","text":"CRAN release: 2023-01-16 Responded deprecation warnings purrr::cross2(). Responded deprecation warnings tidyselect. transpose_byname() longer converts constant 1x1 matrix without row column names. New function select_rowcol_piece_byname() enables selecting rows columns using RCLabels notation label pieces. New function svd_byname() calculates singular value decomposition matrix. New argument method invert_byname() allows callers select method inverting matrix. New functions eigenvalues_byname() eigenvectors_byname() calculate eigenvalues eigenvectors matrices lists matrices. Added tol argument added invert_byname(). value tol argument passed base::solve(). invert_byname() now reports names zero rows columns attempting invert singular matrix. new error message huge help debugging. New functions select_zero_rows_byname() select_zero_cols_byname() assist detecting problem areas singular matrices. rowsums_byname(), colsums_byname(), sumall_byname() now correctly return single number single number input. aggregate_byname() now returns argument (a_mat) string margin resolves NA (isn’t row column type). margins renaming aggregating can determined row column types inference row column label notation. Renaming aggregation functions now (default) infer row column notations. Now 1165 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-050-2022-04-01-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.5.0 (2022-04-01)","title":"matsbyname 0.5.0 (2022-04-01)","text":"CRAN release: 2022-04-01 New format documentation pages, including search function! New vignette “Using summarise matsbyname” clarifies issues around ambiguities functions use ... argument. aggregation-vignette now includes details using sum_byname(.summarise = TRUE) dplyr::summarise(). sum_byname(), matrixproduct_byname(), hadamardproduct_byname(), mean_byname(), geometricmean_byname(), equal_byname(), identical_byname(), samestructure_byname(), and_byname() gain argument .summarise signal intention operate column (.summarise = TRUE) along list (.summarise = FALSE). default value .summarise = FALSE, thereby maintaining previous behavior. New functions agg_table_to_agg_map() agg_map_to_agg_table() assist manipulating aggregation maps. New vignette aggregation-vignette demonstrates new aggregation functions. Functions rename_to_pref_suff_byname() aggregate_to_pref_suff_byname() now route new functions rename_to_piece_byname() aggregate_pieces_byname(), thereby avoiding code duplication. change may break code. functions now return empty string (““) suffix requested one found. Previously, functions returned entire string suffix found. New function aggregate_pieces_byname() brings flexibility RCLabels matsbyname. Remove (comment now) notation functions notation.R moved RCLabels. New function rename_to_piece_byname() assist renaming aggregating according pieces row column names. New function vec_from_store_byname() creates vectors matrix (row column names taken) vector (acts store values) based matching pieces labels. new function made possible new RCLabels package. Notation code moved new package, RCLabels. RCLabels::make_or_pattern() gains new pattern_type, “literal”, returns row_col_names argument unmodified. trim_rows_cols() gains warn_if_a_incomplete argument. TRUE, warning issued argument missing entries margin present mat. Now 1072 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0425-2021-10-12-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.25 (2021-10-12)","title":"matsbyname 0.4.25 (2021-10-12)","text":"CRAN release: 2021-10-12 New notation functions preposition_notation(), from_notation(), of_notation(). Now 1077 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0424-2021-10-01-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.24 (2021-10-01)","title":"matsbyname 0.4.24 (2021-10-01)","text":"CRAN release: 2021-10-02 Added test trigger errors dimnames NULL. Fixed bug 0x0 matrix completed another matrix. New function trim_rows_cols() eliminates rows /columns one matrix based another. Now 1057 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0423-2021-09-01-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.23 (2021-09-01)","title":"matsbyname 0.4.23 (2021-09-01)","text":"CRAN release: 2021-09-02 hatize_byname() now allows missing keep argument, eliminating regression reverse dependency matsindf package. release CRAN. Now 1039 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0422-2021-07-26-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.22 (2021-07-26)","title":"matsbyname 0.4.22 (2021-07-26)","text":"Now issuing helpful warning hatize_byname() called keep argument different structure vector. safe way encourage callers specify expectations function call. Note version released CRAN, due frequent revisions. Now 1040 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0421-2021-07-23-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.21 (2021-07-23)","title":"matsbyname 0.4.21 (2021-07-23)","text":"hatize_byname() hatinv_byname() gain new argument keep tells whether keep row names column names 1x1 matrix supplied. feature assists code may occasionally encounter 1x1 vectors input. Note version released CRAN, due frequent revisions. Now 1030 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0420-2021-07-19-doi","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.20 (2021-07-19)","title":"matsbyname 0.4.20 (2021-07-19)","text":"CRAN release: 2021-07-21 New function keep_pref_suff() keeps prefixes suffixes individual strings lists strings, based notation provided. Now 1025 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0419-2021-07-17","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.19 (2021-07-17)","title":"matsbyname 0.4.19 (2021-07-17)","text":"CRAN release: 2021-07-18 Breaking change: New logic situations prefix suffix found split_pref_suff(). Previously, NULL returned missing prefix suffix. Now, empty string (\"\") returned. New tests whether split_pref_suff() works data frame. Now 1009 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0418-2021-06-02","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.18 (2021-06-02)","title":"matsbyname 0.4.18 (2021-06-02)","text":"CRAN release: 2021-06-03 New function kvec_from_template_byname() creates row column vector template matrix. New function create_colvec_byname() builds create_matrix_byname(). New function create_rowvec_byname() builds create_matrix_byname(). New function create_matrix_byname() behaves much like matrix() “byname” characteristics. Now 1000 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0417-2021-04-10","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.17 (2021-04-10)","title":"matsbyname 0.4.17 (2021-04-10)","text":"Transition GitHub actions continuous integration. Still 906 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0416-2020-11-25","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.16 (2020-11-25)","title":"matsbyname 0.4.16 (2020-11-25)","text":"CRAN release: 2020-11-26 Moved URLs https:// appropriate. Fixed bug rename_to_pref_suff_byname() column vector fail “subscript bounds” error. fix wrap return list containing “pref” “suff” list, rest function expected, single row present. Fixed bug colsums_byname() rowsums_byname() setting rowname colname argument NULL result empty row name column name. Fixed bug hatize_byname() 1x1 vector gave error: length 'dimnames' [1] equal array extent. solution check 1x1 vectors act accordingly. Fixed warning emitted stringi. New tests bug fixes. Now 906 tests, passing. Test coverage remains 100 %.","code":""},{"path":"/news/index.html","id":"matsbyname-0415-2020-05-29","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.15 (2020-05-29)","title":"matsbyname 0.4.15 (2020-05-29)","text":"CRAN release: 2020-05-29 Now 900 tests, passing. Test coverage remains 100%. Added tol argument clean_byname(), allowing machine precision issues addressed. Ensured old functions, rename_to_pref_suff_byname(), aggregate_byname(), aggregate_to_pref_suff_byname() respect notation using notation renaming rows columns. New functions manipulating names rows columns: notation_vec(), arrow_notation(), paren_notation(), bracket_notation(), split_pref_suff(), join_pref_suff(), flip_pref_suff(), switch_notation(), switch_notation_byname(). Eliminated warning GitHub actions README.md requiring nonempty <title> element.","code":""},{"path":"/news/index.html","id":"matsbyname-0414-2020-05-01","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.14 (2020-05-01)","title":"matsbyname 0.4.14 (2020-05-01)","text":"CRAN release: 2020-05-01 Now 829 tests, passing. Test coverage remains 100%. Enhanced prep_vector_arg() duplicate matrices present vector_arg. Better error messages sort_rows_cols(). Now telling row column names duplicates. Added function aggregate_pref_suff_byname() combines rename_to_pref_suff_byname() aggregate_byname(). Fixed crashing bug appeared aggregate_byname() collapsed rows columns single row single column . Added new function aggregate_byname() aggregates rows, columns, , according aggregation_map. wanted add function long time, finally found reason, namely need aggregate prefixes suffixes IEATools package. Furthermore, aggregation_map idea seems solid. Note aggregation_map = NULL (default) aggregates rows names columns names. Added function rename_rowcol_to_pref_suff_byname() renames rows columns prefixes suffixes row column names. Fixed bug clean_byname() caused NULL response unnamed rows columns present. Now using new prepare_.FUNdots() function *apply_byname() functions. Refactored new code unaryapply_byname() function prepare_.FUNdots(), can used *apply_byname() functions.","code":""},{"path":"/news/index.html","id":"matsbyname-0413-2020-04-17","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.13 (2020-04-17)","title":"matsbyname 0.4.13 (2020-04-17)","text":"CRAN release: 2020-04-18 Now 766 tests, passing. Code coverage remains 100%. First dimension contains named arguments FUN. Second dimension contains unique values named arguments applied along main argument .","code":""},{"path":"/news/index.html","id":"matsbyname-0412-2020-03-21","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.12 (2020-03-21)","title":"matsbyname 0.4.12 (2020-03-21)","text":"CRAN release: 2020-03-22 move data.frame tibble creating data frames testing eliminate use (), tibble friendly list columns. Added new function matricize_byname() converts column (row) vector matrix. matricize_byname() inverse vectorize_byname(). Added new function vectorize_byname converts matrix column vector. Added section vignette matsindf. section re-added now matsindf now CRAN.","code":""},{"path":"/news/index.html","id":"matsbyname-0411-2019-12-04","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.11 (2019-12-04)","title":"matsbyname 0.4.11 (2019-12-04)","text":"CRAN release: 2019-12-05 Maintenance release get ready R4.0.0. matrix objects now inherit matrix array. Thus, code longer assume class() returns object length 1 matrix. , eliminated instances class() == \"matrix\" statements favor inherits(, \"matrix\"). See https://developer.r-project.org/Blog/public/2019/11/09/--think-class.-think-/index.html details.","code":""},{"path":"/news/index.html","id":"matsbyname-0410-2019-02-16","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.10 (2019-02-16)","title":"matsbyname 0.4.10 (2019-02-16)","text":"CRAN release: 2019-02-16 Added CRAN installation instructions README.Rmd, now package CRAN. Added CITATION file. citation(\"matsbyname\") now gives useful information. Fixed bug matrixproduct_byname row column types set correctly one operand matrix operand NA.","code":""},{"path":"/news/index.html","id":"matsbyname-049-2019-01-17","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.9 (2019-01-17)","title":"matsbyname 0.4.9 (2019-01-17)","text":"CRAN release: 2019-01-25 Improved LICENSE file submission CRAN. First version appear CRAN. Added CRAN lifecycle badges.","code":""},{"path":"/news/index.html","id":"matsbyname-048-2019-01-16","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.8 (2019-01-16)","title":"matsbyname 0.4.8 (2019-01-16)","text":"Improved cran-comments.md submission CRAN.","code":""},{"path":"/news/index.html","id":"matsbyname-047-2019-01-07","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.7 (2019-01-07)","title":"matsbyname 0.4.7 (2019-01-07)","text":"Cleaned dependencies testing.","code":""},{"path":"/news/index.html","id":"matsbyname-046-2019-01-07","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.6 (2019-01-07)","title":"matsbyname 0.4.6 (2019-01-07)","text":"Now external function calls fully qualified.","code":""},{"path":"/news/index.html","id":"matsbyname-045-2019-01-07","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.5 (2019-01-07)","title":"matsbyname 0.4.5 (2019-01-07)","text":"New function elementapply_byname() applies function element matrix specified row col arguments. elementproduct_byname() changed hadamardproduct_byname() avoid name collision elementapply_byname(). elementquotient_byname() changed quotient_byname(). elementpow_byname() changed pow_byname(). elementexp_byname() changed exp_byname().","code":""},{"path":"/news/index.html","id":"matsbyname-044-2019-01-02","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.4 (2019-01-02)","title":"matsbyname 0.4.4 (2019-01-02)","text":"Added tests achieve 100% code coverage.","code":""},{"path":"/news/index.html","id":"matsbyname-043-2019-01-02","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.3 (2019-01-02)","title":"matsbyname 0.4.3 (2019-01-02)","text":"complete_rows_cols() now agnostic order columns fillrow order rows fillcol.","code":""},{"path":"/news/index.html","id":"matsbyname-042-2019-01-02","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.2 (2019-01-02)","title":"matsbyname 0.4.2 (2019-01-02)","text":"sort_rows_cols() now allows entries roworder colorder presently names rows columns. Extraneous names silently ignored.","code":""},{"path":"/news/index.html","id":"matsbyname-041-2019-01-01","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.1 (2019-01-01)","title":"matsbyname 0.4.1 (2019-01-01)","text":"Adding code coverage badge.","code":""},{"path":"/news/index.html","id":"matsbyname-040-2018-12-27","dir":"Changelog","previous_headings":"","what":"matsbyname 0.4.0 (2018-12-27)","title":"matsbyname 0.4.0 (2018-12-27)","text":"Attempted first release CRAN. (Failed.)","code":""},{"path":"/news/index.html","id":"matsbyname-038-2018-12-21","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.8 (2018-12-21)","title":"matsbyname 0.3.8 (2018-12-21)","text":"fractionize_byname() now correctly handles non-square matrices.","code":""},{"path":"/news/index.html","id":"matsbyname-037-2018-12-02","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.7 (2018-12-02)","title":"matsbyname 0.3.7 (2018-12-02)","text":"hatinv_byname() now handles 0 values input vectors gracefully. default, 0 values become .Machine$double.xmax. choose different value, set new argument inf_becomes numerical value. suppress default behavior, set inf_becomes = NULL.","code":""},{"path":"/news/index.html","id":"matsbyname-036-2018-11-25","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.6 (2018-11-25)","title":"matsbyname 0.3.6 (2018-11-25)","text":"iszero_byname() now checks values abs() <= tol. (Previously, iszero_byname() tested < tol.) change allows zero matrix pass test tol = 0, want. Reverted equal_byname() use isTRUE(.equal()) checking equality. New function identical_byname() checks exact equality using identical. Now 672 tests.","code":""},{"path":"/news/index.html","id":"matsbyname-035-2018-11-18","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.5 (2018-11-18)","title":"matsbyname 0.3.5 (2018-11-18)","text":"Now using identical() instead isTRUE(.equal()) equal_byname() function.","code":""},{"path":"/news/index.html","id":"matsbyname-034-2018-11-18","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.4 (2018-11-18)","title":"matsbyname 0.3.4 (2018-11-18)","text":"Added new function hatinv_byname(). Documented defaults arguments count_* functions. Now importing pipe operator magrittr package global level","code":""},{"path":"/news/index.html","id":"matsbyname-033-2018-10-29","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.3 (2018-10-29)","title":"matsbyname 0.3.3 (2018-10-29)","text":"Fix version number pkgdown website. Updated many details pkgdown website better user navigation.","code":""},{"path":"/news/index.html","id":"matsbyname-032-2018-10-29","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.2 (2018-10-29)","title":"matsbyname 0.3.2 (2018-10-29)","text":"First release CRAN didn’t work. Added online documentation github pkgdown.","code":""},{"path":"/news/index.html","id":"matsbyname-031-2018-08-25","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.1 (2018-08-25)","title":"matsbyname 0.3.1 (2018-08-25)","text":"Updated new version Roxygen changed line breaks .Rd files. First release CRAN.","code":""},{"path":"/news/index.html","id":"matsbyname-030-2018-06-20","dir":"Changelog","previous_headings":"","what":"matsbyname 0.3.0 (2018-06-20)","title":"matsbyname 0.3.0 (2018-06-20)","text":"Removed parallelism features introduced v0.2.6. Detailed timings revealed parallel code slower single-thread code. topic may revisited future. now, best remove multicore code. longer mc.cores arguments matsbyname functions.","code":""},{"path":"/news/index.html","id":"matsbyname-029-2018-05-24","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.9 (2018-05-24)","title":"matsbyname 0.2.9 (2018-05-24)","text":"Beginnings S3 class matbyname. sure want keep . Fixed argument name error exposed check.","code":""},{"path":"/news/index.html","id":"matsbyname-028-2018-05-17","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.8 (2018-05-17)","title":"matsbyname 0.2.8 (2018-05-17)","text":"New functions all_byname() any_byname() make logical tests easy. New function replaceNaN_byname() replaces NaN entries value (default 0).","code":""},{"path":"/news/index.html","id":"matsbyname-027-2018-04-15","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.7 (2018-04-15)","title":"matsbyname 0.2.7 (2018-04-15)","text":"Refactored *col*_byname functions call respective *row*_byname functions transposed argument, thereby simplifying code. Fixed bug caused refactoring. select_cols_byname, NULL result terminated executing thread. Added new function replaceNaNWith0. Added new functions count_vals_byname, count_vals_inrows_byname, count_vals_incols_byname return number matrix entries meet criterion entire matrix, row, column, respectively. Improvements documentation. Now 646 passing tests.","code":""},{"path":"/news/index.html","id":"matsbyname-026-2018-03-16","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.6 (2018-03-16)","title":"matsbyname 0.2.6 (2018-03-16)","text":"New functions set_mc_cores get_mc_cores set get package-wide mc.cores variable. Default 1, functions work previously unless mc.cores 1. Alternatively, specify mc.cores argument function specify number cores used individual calculation. Default get_mc_cores(). useful approach set_mc_cores(detectCores(logical = FALSE)). sum_byname(list(1,2,3,4), list(1,2,3,4), mc.cores = 4) send sum different core. set_mc_cores(4L); sum_byname(list(1,2,3,4), list(1,2,3,4), mc.cores = 4); set_mc_cores(1L) thing set package-wide value back 1.","code":""},{"path":"/news/index.html","id":"matsbyname-025-2018-03-13","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.5 (2018-03-13)","title":"matsbyname 0.2.5 (2018-03-13)","text":"API changes, shouldn’t affect existing code, calls binary functions “just work.” naryapply_byname: enables ... arguments naryapplylogical_byname: enables logical functions Add ... arguments functions deserve . sum_byname matrixproduct_byname elementproduct_byname mean_byname geometricmean_byname equal_byname samestructure_byname infrastructure place add logical functions future: or_byname, xor_byname, not_byname.","code":""},{"path":"/news/index.html","id":"matsbyname-024-2018-03-08","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.4 (2018-03-08)","title":"matsbyname 0.2.4 (2018-03-08)","text":"Preparing submission CRAN. Changed many variable names APIs standardize “” “b” names matrix list matrices arguments.","code":""},{"path":"/news/index.html","id":"matsbyname-023-2018-03-08","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.3 (2018-03-08)","title":"matsbyname 0.2.3 (2018-03-08)","text":"Eliminate dependence (temporarily) matsindf. allows matsbyname submitted first CRAN. Also, Travis builds now successful, eliminated circular dependence matsbyname matsindf.","code":""},{"path":"/news/index.html","id":"matsbyname-022-2018-03-02","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.2 (2018-03-02)","title":"matsbyname 0.2.2 (2018-03-02)","text":"New function elementpow_byname raises elements matrix power.","code":""},{"path":"/news/index.html","id":"matsbyname-021-2018-02-28","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.1 (2018-02-28)","title":"matsbyname 0.2.1 (2018-02-28)","text":"complete_rows_cols now accepts fillrow fillcol arguments. arguments can used (instead fill argument) specify values filled rows columns completing matrix. conflicts arise, precedence among fill* arguments fillrow fillcol fill.","code":""},{"path":"/news/index.html","id":"matsbyname-020-2018-02-23","dir":"Changelog","previous_headings":"","what":"matsbyname 0.2.0 (2018-02-23)","title":"matsbyname 0.2.0 (2018-02-23)","text":"Name change matsbyname.","code":""}]
